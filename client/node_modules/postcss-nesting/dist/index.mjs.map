{"version":3,"file":"index.mjs","sources":["../src/lib/shift-nodes-before-parent.js","../src/lib/cleanup-parent.js","../src/lib/merge-selectors/combinations-of-size-n.js","../src/lib/merge-selectors/wrap-multiple-tag-selectors-with-is-pseudo.js","../src/lib/merge-selectors/compound-selector-order.js","../src/lib/merge-selectors/specificity.js","../src/lib/merge-selectors/merge-selectors.js","../src/lib/rule-within-rule.js","../src/lib/list.js","../src/lib/valid-atrules.js","../src/lib/atrule-within-atrule.js","../src/lib/merge-params.js","../src/lib/walk.js","../src/lib/nest-rule-within-rule.js","../src/lib/atrule-within-rule.js","../src/index.js"],"sourcesContent":["export default function shiftNodesBeforeParent(node) {\n\tconst parent = node.parent;\n\tconst index = parent.index(node);\n\n\t// conditionally move previous siblings into a clone of the parent\n\tif (index) {\n\t\tparent.cloneBefore().removeAll().append(parent.nodes.slice(0, index));\n\t}\n\n\t// move the current node before the parent (and after the conditional clone)\n\tparent.before(node);\n\n\treturn parent;\n}\n","export default function cleanupParent(parent) {\n\tif (!parent.nodes.length) {\n\t\tparent.remove();\n\t}\n}\n","export function combinationsWithSizeN(set, n) {\n\t// set is the list of parent selectors\n\t// n is the amount of `&` selectors in the current selector.\n\t// all combinations of values in the set with an array size of n must be generated to match the nesting selector behavior.\n\t//\n\t// for example :\n\t// a current selector like: `& + & {}`\n\t// with parent : `.foo, .bar {}`\n\t//\n\t// the set is `['.foo', '.bar']` and n is 2, the resulting combinations are:\n\t// ['.foo', '.bar']\n\t// ['.foo', '.foo']\n\t// ['.bar', '.foo']\n\t// ['.bar', '.bar']\n\t//\n\t// outputted like :\n\t// .foo + .bar,\n\t// .foo + .foo,\n\t// .bar + .foo,\n\t// .bar + .bar {}\n\n\n\tif (n < 2) {\n\t\t// should never happen and is checked by caller\n\t\tthrow new Error('n must be greater than 1');\n\t}\n\n\tif (set.length < 2) {\n\t\t// should never happen and is checked by caller\n\t\tthrow new Error('s must be greater than 1');\n\t}\n\n\tif (Math.pow(set.length, n) > 10000) {\n\t\t// Throwing is best here as a warning would be impossible to handle gracefully on our end.\n\t\t// This will error mid transform and there is no possible fallback at this point.\n\t\t// The user should reduce complexity.\n\t\tthrow new Error('Too many combinations when trying to resolve a nested selector with lists, reduce the complexity of your selectors');\n\t}\n\n\tconst counters = [];\n\n\tfor (let i = 0; i < n; i++) {\n\t\tcounters[i] = 0;\n\t}\n\n\tconst result = [];\n\n\t// eslint-disable-next-line no-constant-condition\n\twhile (true) {\n\t\tconst ss = [];\n\t\tfor (let i = n-1; i >=0; i--) {\n\t\t\tlet currentCounter = counters[i];\n\t\t\tif (currentCounter >= set.length) {\n\t\t\t\tcurrentCounter = 0;\n\t\t\t\tcounters[i] = 0;\n\n\t\t\t\tif (i === 0) {\n\t\t\t\t\treturn result;\n\t\t\t\t} else {\n\t\t\t\t\tcounters[i-1] += 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tss[i] = set[currentCounter];\n\t\t}\n\n\t\tresult.push(ss);\n\t\tcounters[counters.length -1]++;\n\t}\n}\n","import parser from 'postcss-selector-parser';\n\nconst isPseudo = parser.pseudo({ value: ':is' });\n\nexport function wrapMultipleTagSelectorsWithIsPseudo(node) {\n\t// This is a fallback for broken selectors like:\n\t// `h1h2`\n\t// These selectors are also useless as `h1:is(h2)`.\n\t// Wrapping with is only prevents accidentally forming other words which might have meaning.\n\n\tconst tagNodes = node.nodes.filter((x) => {\n\t\treturn x.type === 'tag';\n\t});\n\n\tif (tagNodes.length > 1) {\n\t\ttagNodes.slice(1).forEach((child) => {\n\t\t\tconst isPseudoClone = isPseudo.clone();\n\t\t\tchild.replaceWith(isPseudoClone);\n\t\t\tisPseudoClone.append(child);\n\t\t});\n\t}\n}\n","import parser from 'postcss-selector-parser';\n\nimport { wrapMultipleTagSelectorsWithIsPseudo } from './wrap-multiple-tag-selectors-with-is-pseudo';\n\nexport function sortCompoundSelectorsInsideComplexSelector(node, wrapWithIsPseudo) {\n\tlet compound = [];\n\tlet foundOtherNesting = false;\n\n\tconst nodes = [...node.nodes];\n\n\tfor (let i = 0; i < (nodes.length+1); i++) {\n\t\tconst child = nodes[i];\n\t\tif (!child || child.type === 'combinator') {\n\t\t\tif (foundOtherNesting) {\n\t\t\t\t// nesting walker will further manipulate the selector and revisit this function later.\n\t\t\t\t// not skipping here will break the nesting walker as the order and contents of the nodes have changed too much.\n\t\t\t\tcompound = [];\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (compound.length > 1) {\n\t\t\t\tconst compoundSelector = parser.selector();\n\t\t\t\tcompound[0].replaceWith(compoundSelector);\n\n\t\t\t\tcompound.slice(1).forEach((compoundPart) => {\n\t\t\t\t\tcompoundPart.remove();\n\t\t\t\t});\n\n\t\t\t\tcompound.forEach((compoundPart) => {\n\t\t\t\t\tcompoundSelector.append(compoundPart);\n\t\t\t\t});\n\n\t\t\t\tsortCompoundSelector(compoundSelector);\n\t\t\t\tif (wrapWithIsPseudo) {\n\t\t\t\t\twrapMultipleTagSelectorsWithIsPseudo(compoundSelector);\n\t\t\t\t}\n\t\t\t\tcompoundSelector.replaceWith(...(compoundSelector.nodes));\n\t\t\t}\n\n\t\t\tcompound = [];\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (child.type === 'nesting') {\n\t\t\tfoundOtherNesting = true;\n\t\t}\n\n\t\tcompound.push(child);\n\t}\n}\n\nexport function sortCompoundSelector(node) {\n\t// compound selectors with nesting can be written with tag selectors as later parts.\n\t// for example : `&h1`\n\t//\n\t// simply concating with parent selectors can lead to :\n\t// `.fooh1`\n\t//\n\t// applying a sort where tag selectors are first will result in :\n\t// `h1.foo`\n\n\tnode.nodes.sort((a, b) => {\n\t\tif (a.type === b.type) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (selectorTypeOrder[a.type] < selectorTypeOrder[b.type]) {\n\t\t\treturn -1;\n\t\t}\n\n\t\treturn 1;\n\t});\n}\n\nconst selectorTypeOrder = {\n\tuniversal: 0,\n\ttag: 1,\n\tid: 2,\n\tclass: 3,\n\tattribute: 4,\n\tpseudo: 5,\n\tselector: 7,\n\tstring: 8,\n\troot : 9,\n\tcomment: 10,\n\n\tnesting: 9999,\n};\n","import parser from 'postcss-selector-parser';\n\nexport function nodesAreEquallySpecific(nodes) {\n\t// Selector specificity is important when the parent selector is a list.\n\t// These cases should be resolved with `:is()` pseudo.\n\t// Since browser support for `:is()` is not great, we try to avoid it.\n\t// If the selector specificity is equal for all items in the selector list, we don't need `:is`.\n\n\tconst specificities = nodes.map((node) => {\n\t\treturn parser().astSync(node);\n\t}).map((ast) => {\n\t\treturn selectorSpecificity(ast);\n\t});\n\n\tconst first = specificities[0];\n\tfor (let i = 1; i < specificities.length; i++) {\n\t\tif (first.a === specificities[i].a && first.b === specificities[i].b && first.c === specificities[i].c) {\n\t\t\tcontinue;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nexport function selectorSpecificity(node) {\n\tlet a = 0;\n\tlet b = 0;\n\tlet c = 0;\n\n\tif (node.type === 'id') {\n\t\ta += 1;\n\t} else if (node.type === 'tag') {\n\t\tc += 1;\n\t} else if (node.type === 'class') {\n\t\tb += 1;\n\t} else if (node.type === 'attribute') {\n\t\tb += 1;\n\t} else if (node.type === 'pseudo') {\n\t\tswitch (node.value) {\n\t\t\tcase '::after':\n\t\t\tcase ':after':\n\t\t\tcase '::backdrop':\n\t\t\tcase '::before':\n\t\t\tcase ':before':\n\t\t\tcase '::cue':\n\t\t\tcase '::cue-region':\n\t\t\tcase '::first-letter':\n\t\t\tcase ':first-letter':\n\t\t\tcase '::first-line':\n\t\t\tcase ':first-line':\n\t\t\tcase '::file-selector-button':\n\t\t\tcase '::grammar-error':\n\t\t\tcase '::marker':\n\t\t\tcase '::part':\n\t\t\tcase '::placeholder':\n\t\t\tcase '::selection':\n\t\t\tcase '::slotted':\n\t\t\tcase '::spelling-error':\n\t\t\tcase '::target-text':\n\t\t\t\tc += 1;\n\t\t\t\tbreak;\n\n\t\t\tcase ':is':\n\t\t\tcase ':has':\n\t\t\tcase ':not':\n\t\t\t\t{\n\t\t\t\t\tconst pseudoSpecificity = selectorSpecificity(node.nodes[0]);\n\t\t\t\t\ta += pseudoSpecificity.a;\n\t\t\t\t\tb += pseudoSpecificity.b;\n\t\t\t\t\tc += pseudoSpecificity.c;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tcase 'where':\n\t\t\t\tbreak;\n\n\t\t\tcase ':nth-child':\n\t\t\tcase ':nth-last-child':\n\t\t\t\t{\n\t\t\t\t\tconst ofSeparatorIndex = node.nodes.findIndex((x) => {\n\t\t\t\t\t\tx.value === 'of';\n\t\t\t\t\t});\n\n\t\t\t\t\tif (ofSeparatorIndex > -1) {\n\t\t\t\t\t\tconst ofSpecificity = selectorSpecificity(parser.selector({ nodes: node.nodes.slice(ofSeparatorIndex + 1) }));\n\t\t\t\t\t\ta += ofSpecificity.a;\n\t\t\t\t\t\tb += ofSpecificity.b;\n\t\t\t\t\t\tc += ofSpecificity.c;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ta += a;\n\t\t\t\t\t\tb += b;\n\t\t\t\t\t\tc += c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tb += 1;\n\t\t}\n\t} else if (node.nodes && node.nodes.length > 0) {\n\t\tnode.nodes.forEach((child) => {\n\t\t\tconst specificity = selectorSpecificity(child);\n\t\t\ta += specificity.a;\n\t\t\tb += specificity.b;\n\t\t\tc += specificity.c;\n\t\t});\n\t}\n\n\treturn {\n\t\ta,\n\t\tb,\n\t\tc,\n\t};\n}\n\n","import parser from 'postcss-selector-parser';\nimport { combinationsWithSizeN } from './combinations-of-size-n';\nimport { sortCompoundSelector, sortCompoundSelectorsInsideComplexSelector } from './compound-selector-order';\nimport { nodesAreEquallySpecific } from './specificity';\nimport { wrapMultipleTagSelectorsWithIsPseudo } from './wrap-multiple-tag-selectors-with-is-pseudo';\n\nexport default function mergeSelectors(fromSelectors, toSelectors, opts) {\n\tconst fromListHasUniformSpecificity = nodesAreEquallySpecific(fromSelectors);\n\n\tlet fromSelectorsAST = [];\n\n\tif (fromListHasUniformSpecificity || opts.noIsPseudoSelector) {\n\t\tfromSelectorsAST = fromSelectors.map((selector) => {\n\t\t\treturn parser().astSync(selector);\n\t\t});\n\t} else {\n\t\tfromSelectorsAST = [parser().astSync(`:is(${fromSelectors.join(',')})`)];\n\t}\n\n\tlet result = [];\n\n\tfor (let x = 0; x < toSelectors.length; x++) {\n\t\tconst toSelector = toSelectors[x];\n\n\t\tlet iterations = 1;\n\t\tlet fromSelectorCombinations = [];\n\n\t\tlet nestingCounter = 0;\n\t\tparser().astSync(toSelector).walkNesting(() => {\n\t\t\tnestingCounter++;\n\t\t});\n\n\t\tif (nestingCounter > 1 && fromSelectorsAST.length > 1) {\n\t\t\tfromSelectorCombinations = combinationsWithSizeN(fromSelectorsAST, nestingCounter);\n\t\t\titerations = fromSelectorCombinations.length;\n\t\t} else {\n\t\t\titerations = fromSelectorsAST.length;\n\t\t\tfor (let i = 0; i < fromSelectorsAST.length; i++) {\n\t\t\t\tfromSelectorCombinations.push([]);\n\n\t\t\t\tfor (let j = 0; j < nestingCounter; j++) {\n\t\t\t\t\tfromSelectorCombinations[i].push(fromSelectorsAST[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (let y = 0; y < iterations; y++) {\n\t\t\tlet counter = 0;\n\n\t\t\tconst toSelectorAST = parser().astSync(toSelector);\n\t\t\ttoSelectorAST.walk((nesting) => {\n\t\t\t\tif (nesting.type !== 'nesting') {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tlet fromSelectorAST = fromSelectorCombinations[y][counter];\n\t\t\t\tcounter++;\n\n\t\t\t\t// If the from selector is simple we extract the first non root, non selector node\n\t\t\t\tif (fromSelectorAST.type === 'root' && fromSelectorAST.nodes.length === 1) {\n\t\t\t\t\tfromSelectorAST = fromSelectorAST.nodes[0];\n\t\t\t\t}\n\n\t\t\t\tconst fromSelectorWithIsAST = parser().astSync(`:is(${fromSelectorAST.toString()})`);\n\n\t\t\t\tconst fromIsSimple = isSimpleSelector(fromSelectorAST.nodes[0]); // this function looks at the parent of the node passed as an argument\n\t\t\t\tconst fromIsCompound = isCompoundSelector(fromSelectorAST.nodes[0]); // this function looks at the parent of the node passed as an argument\n\n\t\t\t\tconst toIsSimple = isSimpleSelector(nesting);\n\t\t\t\tconst toIsCompound = isCompoundSelector(nesting);\n\n\t\t\t\t// Parent and child are simple\n\t\t\t\tif (fromIsSimple && toIsSimple) {\n\t\t\t\t\tnesting.replaceWith(fromSelectorAST.clone());\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Parent and child are simple or compound\n\t\t\t\tif ((fromIsSimple || fromIsCompound) && (toIsSimple || toIsCompound)) {\n\t\t\t\t\tconst parent = nesting.parent;\n\n\t\t\t\t\tif (fromIsSimple && fromSelectorAST.type === 'selector') {\n\t\t\t\t\t\t// fromSelectorAST has type selector with a single child\n\t\t\t\t\t\tnesting.replaceWith(fromSelectorAST.clone().nodes[0]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// fromSelectorAST has type selector containing a compound selector\n\t\t\t\t\t\tnesting.replaceWith(...(fromSelectorAST.clone().nodes));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (parent && parent.nodes.length > 1) {\n\t\t\t\t\t\tsortCompoundSelector(parent);\n\n\t\t\t\t\t\tif (!opts.noIsPseudoSelector) {\n\t\t\t\t\t\t\twrapMultipleTagSelectorsWithIsPseudo(parent);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (fromIsSimple) {\n\t\t\t\t\tconst parent = nesting.parent;\n\t\t\t\t\tnesting.replaceWith(fromSelectorAST.clone().nodes[0]);\n\n\t\t\t\t\tif (parent) {\n\t\t\t\t\t\tsortCompoundSelectorsInsideComplexSelector(parent, !opts.noIsPseudoSelector);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (fromIsCompound) {\n\t\t\t\t\tconst parent = nesting.parent;\n\t\t\t\t\tnesting.replaceWith(...(fromSelectorAST.clone().nodes));\n\n\t\t\t\t\tif (parent) {\n\t\t\t\t\t\tsortCompoundSelectorsInsideComplexSelector(parent, !opts.noIsPseudoSelector);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (nestingIsFirstAndOnlyInSelectorWithEitherSpaceOrChildCombinator(nesting)) {\n\t\t\t\t\tconst parent = nesting.parent;\n\t\t\t\t\tnesting.replaceWith(...(fromSelectorAST.clone().nodes));\n\n\t\t\t\t\tif (parent) {\n\t\t\t\t\t\tsortCompoundSelectorsInsideComplexSelector(parent, !opts.noIsPseudoSelector);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (nestingIsNotInsideCompoundSelector(nesting)) {\n\t\t\t\t\tconst parent = nesting.parent;\n\t\t\t\t\tnesting.replaceWith(...(fromSelectorAST.clone().nodes));\n\n\t\t\t\t\tif (parent) {\n\t\t\t\t\t\tsortCompoundSelectorsInsideComplexSelector(parent, !opts.noIsPseudoSelector);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst parent = nesting.parent;\n\t\t\t\tif (opts.noIsPseudoSelector) {\n\t\t\t\t\tnesting.replaceWith(...(fromSelectorAST.clone().nodes));\n\t\t\t\t} else {\n\t\t\t\t\tnesting.replaceWith(...(fromSelectorWithIsAST.clone().nodes));\n\t\t\t\t}\n\n\t\t\t\tif (parent) {\n\t\t\t\t\tsortCompoundSelectorsInsideComplexSelector(parent, !opts.noIsPseudoSelector);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tresult.push(toSelectorAST.toString());\n\t\t}\n\t}\n\n\treturn result;\n}\n\nfunction isSimpleSelector(selector) {\n\tif (selector.type === 'combinator') {\n\t\treturn false;\n\t}\n\n\tif (selector.parent && selector.parent.nodes.length > 1) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nfunction isCompoundSelector(selector, toSelector = null) {\n\tif (isSimpleSelector(selector)) {\n\t\treturn false;\n\t}\n\n\tif (!selector.parent) {\n\t\treturn false;\n\t}\n\n\tconst hasCombinators = !!(selector.parent.nodes.find((x) => {\n\t\treturn x.type === 'combinator' || x.type === 'comment';\n\t}));\n\n\tif (hasCombinators) {\n\t\treturn false;\n\t}\n\n\tconst hasExtraNesting = !!(selector.parent.nodes.find((x) => {\n\t\treturn x.type === 'nesting';\n\t}));\n\n\tif (hasExtraNesting && toSelector && !isCompoundSelector(toSelector)) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n\nfunction nestingIsFirstAndOnlyInSelectorWithEitherSpaceOrChildCombinator(selector) {\n\tif (!selector.parent) {\n\t\treturn false;\n\t}\n\n\tif (selector.parent.nodes.indexOf(selector) !== 0) {\n\t\treturn false;\n\t}\n\n\tfor (let i = 1; i < selector.parent.nodes.length; i++) {\n\t\tif (selector.parent.nodes[i].type === 'combinator' && (selector.parent.nodes[i].value !== ' ' && selector.parent.nodes[i].value !== '>')) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nfunction nestingIsNotInsideCompoundSelector(selector) {\n\tif (isSimpleSelector(selector)) {\n\t\treturn true;\n\t}\n\n\tif (!selector.parent) {\n\t\treturn false;\n\t}\n\n\tfor (let i = 0; i < selector.parent.nodes.length; i++) {\n\t\tif (!selector.parent.nodes[i].type === 'nesting') {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!selector.parent.nodes[i].prev() && !selector.parent.nodes[i].next()) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (selector.parent.nodes[i].prev() && selector.parent.nodes[i].prev().type !== 'combinator') {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (selector.parent.nodes[i].next() && selector.parent.nodes[i].next().type !== 'combinator') {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n","import shiftNodesBeforeParent from './shift-nodes-before-parent.js';\nimport cleanupParent from './cleanup-parent.js';\nimport mergeSelectors from './merge-selectors/merge-selectors.js';\n\nexport default function transformRuleWithinRule(node, opts) {\n\t// move previous siblings and the node to before the parent\n\tconst parent = shiftNodesBeforeParent(node);\n\n\t// update the selectors of the node to be merged with the parent\n\tnode.selectors = mergeSelectors(parent.selectors, node.selectors, opts);\n\n\t// merge similar rules back together\n\tconst areSameRule = (node.type === 'rule' && parent.type === 'rule' && node.selector === parent.selector) || (node.type === 'atrule' && parent.type === 'atrule' && node.params === parent.params);\n\n\tif (areSameRule) {\n\t\tnode.append(...parent.nodes);\n\t}\n\n\t// conditionally cleanup an empty parent rule\n\tcleanupParent(parent);\n}\n\nexport const isRuleWithinRule = (node) => node.type === 'rule' && Object(node.parent).type === 'rule' && node.selectors.every((selector) => selector.trim().indexOf('&') === 0 && selector.indexOf('|') === -1);\n","export const comma = (string) => {\n\tlet array = [];\n\tlet current = '';\n\tlet split = false;\n\n\tlet func = 0;\n\tlet quote = false;\n\tlet escape = false;\n\n\tfor (let letter of string) {\n\t\tif (escape) {\n\t\t\tescape = false;\n\t\t} else if (letter === '\\\\') {\n\t\t\tescape = true;\n\t\t} else if (quote) {\n\t\t\tif (letter === quote) {\n\t\t\t\tquote = false;\n\t\t\t}\n\t\t} else if (letter === '\"' || letter === '\\'') {\n\t\t\tquote = letter;\n\t\t} else if (letter === '(') {\n\t\t\tfunc += 1;\n\t\t} else if (letter === ')') {\n\t\t\tif (func > 0) func -= 1;\n\t\t} else if (func === 0) {\n\t\t\tif (letter === ',') split = true;\n\t\t}\n\n\t\tif (split) {\n\t\t\tif (current !== '') array.push(current.trim());\n\t\t\tcurrent = '';\n\t\t\tsplit = false;\n\t\t} else {\n\t\t\tcurrent += letter;\n\t\t}\n\t}\n\n\tarray.push(current.trim());\n\treturn array;\n};\n","export default ['container', 'document', 'media', 'supports'];\n","import cleanupParent from './cleanup-parent.js';\nimport mergeParams from './merge-params.js';\nimport shiftNodesBeforeParent from './shift-nodes-before-parent.js';\nimport validAtrules from './valid-atrules.js';\n\n/*\n * DEPRECATED: In v7.0.0 these features will be removed as they are not part of\n * the nesting proposal.\n */\n\nexport default function transformAtruleWithinAtrule(node) {\n\t// move previous siblings and the node to before the parent\n\tconst parent = shiftNodesBeforeParent(node);\n\n\t// update the params of the node to be merged with the parent\n\tnode.params = mergeParams(parent.params, node.params);\n\n\t// conditionally cleanup an empty parent rule\n\tcleanupParent(parent);\n}\n\nexport const isAtruleWithinAtrule = (node) => node.type === 'atrule' && validAtrules.includes(node.name) && Object(node.parent).type === 'atrule' && node.name === node.parent.name;\n","import { comma } from './list.js';\n\nexport default function mergeParams(fromParams, toParams) {\n\treturn comma(fromParams)\n\t\t.map((params1) =>\n\t\t\tcomma(toParams)\n\t\t\t\t.map((params2) => `${params1} and ${params2}`)\n\t\t\t\t.join(', '),\n\t\t)\n\t\t.join(', ');\n}\n","import transformRuleWithinRule, { isRuleWithinRule } from './rule-within-rule.js';\nimport transformNestRuleWithinRule, { isNestRuleWithinRule } from './nest-rule-within-rule.js';\nimport transformAtruleWithinRule, { isAtruleWithinRule } from './atrule-within-rule.js';\nimport transformAtruleWithinAtrule, { isAtruleWithinAtrule } from './atrule-within-atrule.js';\n\nexport default function walk(node, opts) {\n\tnode.each((child) => {\n\t\tif (isRuleWithinRule(child)) {\n\t\t\ttransformRuleWithinRule(child, opts);\n\t\t} else if (isNestRuleWithinRule(child)) {\n\t\t\ttransformNestRuleWithinRule(child, walk, opts);\n\t\t} else if (isAtruleWithinRule(child)) {\n\t\t\ttransformAtruleWithinRule(child, walk, opts);\n\t\t} else if (isAtruleWithinAtrule(child)) {\n\t\t\ttransformAtruleWithinAtrule(child);\n\t\t}\n\n\t\tif (Object(child.nodes).length) {\n\t\t\twalk(child, opts);\n\t\t}\n\t});\n}\n","import { comma } from './list.js';\nimport shiftNodesBeforeParent from './shift-nodes-before-parent.js';\nimport cleanupParent from './cleanup-parent.js';\nimport mergeSelectors from './merge-selectors/merge-selectors.js';\n\nexport default function transformNestRuleWithinRule(node, walk, opts) {\n\t// move previous siblings and the node to before the parent\n\tconst parent = shiftNodesBeforeParent(node);\n\n\t// clone the parent as a new rule with children appended to it\n\tconst rule = parent.clone().removeAll().append(node.nodes);\n\n\t// replace the node with the new rule\n\tnode.replaceWith(rule);\n\n\t// update the selectors of the node to be merged with the parent\n\trule.selectors = mergeSelectors(parent.selectors, comma(node.params), opts);\n\n\t// conditionally cleanup an empty parent rule\n\tcleanupParent(parent);\n\n\t// walk the children of the new rule\n\twalk(rule, opts);\n}\n\nexport const isNestRuleWithinRule = (node) => node.type === 'atrule' && node.name === 'nest' && Object(node.parent).type === 'rule' && comma(node.params).every((selector) => selector.split('&').length >= 2 && selector.indexOf('|') === -1);\n","import cleanupParent from './cleanup-parent.js';\nimport shiftNodesBeforeParent from './shift-nodes-before-parent.js';\nimport validAtrules from './valid-atrules.js';\n\nexport default function atruleWithinRule(node, walk, opts) {\n\t// move previous siblings and the node to before the parent\n\tconst parent = shiftNodesBeforeParent(node);\n\n\t// clone the parent as a new rule with children appended to it\n\tconst rule = parent.clone().removeAll().append(node.nodes);\n\n\t// append the new rule to the node\n\tnode.append(rule);\n\n\t// conditionally cleanup an empty parent rule\n\tcleanupParent(parent);\n\n\t// walk the children of the new rule\n\twalk(rule, opts);\n}\n\nexport const isAtruleWithinRule = (node) => node.type === 'atrule' && validAtrules.includes(node.name) && Object(node.parent).type === 'rule';\n","import walk from './lib/walk.js';\n\n/**\n * @param {{noIsPseudoSelector?: boolean}} opts\n * @returns {import('postcss').Plugin}\n */\nexport default function postcssNesting(opts) {\n\tconst noIsPseudoSelector = Object(opts).noIsPseudoSelector || false;\n\treturn {\n\t\tpostcssPlugin: 'postcss-nesting',\n\t\tRule(rule) {\n\t\t\twalk(rule, {noIsPseudoSelector: noIsPseudoSelector});\n\t\t},\n\t};\n}\n\npostcssNesting.postcss = true;\n"],"names":["shiftNodesBeforeParent","node","parent","index","cloneBefore","removeAll","append","nodes","slice","before","cleanupParent","length","remove","combinationsWithSizeN","set","n","Error","Math","pow","counters","i","result","ss","currentCounter","push","isPseudo","parser","pseudo","value","wrapMultipleTagSelectorsWithIsPseudo","tagNodes","filter","x","type","forEach","child","isPseudoClone","clone","replaceWith","sortCompoundSelectorsInsideComplexSelector","wrapWithIsPseudo","compound","foundOtherNesting","compoundSelector","selector","compoundPart","sortCompoundSelector","sort","a","b","selectorTypeOrder","universal","tag","id","class","attribute","string","root","comment","nesting","nodesAreEquallySpecific","specificities","map","astSync","ast","selectorSpecificity","first","c","pseudoSpecificity","ofSeparatorIndex","findIndex","ofSpecificity","specificity","mergeSelectors","fromSelectors","toSelectors","opts","fromSelectorsAST","noIsPseudoSelector","join","toSelector","iterations","fromSelectorCombinations","nestingCounter","walkNesting","j","y","counter","toSelectorAST","walk","fromSelectorAST","fromSelectorWithIsAST","toString","fromIsSimple","isSimpleSelector","fromIsCompound","isCompoundSelector","toIsSimple","toIsCompound","nestingIsFirstAndOnlyInSelectorWithEitherSpaceOrChildCombinator","nestingIsNotInsideCompoundSelector","find","indexOf","prev","next","comma","array","current","split","func","quote","escape","letter","trim","transformAtruleWithinAtrule","fromParams","toParams","params","params1","params2","each","Object","selectors","every","isRuleWithinRule","transformRuleWithinRule","name","isNestRuleWithinRule","rule","transformNestRuleWithinRule","validAtrules","includes","isAtruleWithinRule","transformAtruleWithinRule","isAtruleWithinAtrule","postcssNesting","postcssPlugin","Rule","postcss"],"mappings":"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"}