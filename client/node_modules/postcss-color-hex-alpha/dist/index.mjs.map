{"version":3,"file":"index.mjs","sources":["../src/options.js","../src/onCSSDeclaration.js","../src/index.js"],"sourcesContent":["export default {\n\t/** Whether to preserve the original functional color declaration. */\n\tpreserve: false,\n};\n","import valuesParser from 'postcss-value-parser';\nimport options from './options';\n\n/** @type {(decl: CSSDeclaration) => void} Transform 4 & 8 character hex color notation in CSS Declarations. */\nconst onCSSDeclaration = (decl) => {\n\tif (hasAlphaHex(decl)) {\n\t\tconst { value: originalValue } = decl;\n\n\t\t// replace instances of hexa with rgba()\n\t\tconst valueAST = valuesParser(originalValue);\n\n\t\tvalueAST.walk((node) => {\n\t\t\tif (isAlphaHex(node)) {\n\t\t\t\thexa2rgba(node);\n\t\t\t}\n\t\t});\n\n\t\tconst modifiedValue = valueAST.toString();\n\n\t\tif (modifiedValue !== originalValue) {\n\t\t\tif (options.preserve) decl.cloneBefore({ value: modifiedValue });\n\t\t\telse decl.value = modifiedValue;\n\t\t}\n\t}\n};\n\n/** Expresssion to match an exact hexa */\nconst alphaHexValueRegExp = /^#([0-9A-Fa-f]{4}(?:[0-9A-Fa-f]{4})?)$/;\n\n/** Expresssion to match any hexa */\nconst alphaHexRegExp = /#([0-9A-Fa-f]{4}(?:[0-9A-Fa-f]{4})?)\\b/;\n\n/** Returns whether a node has a hexa. */\nconst hasAlphaHex = (node) => alphaHexRegExp.test(node.value);\n\n/** Returns whether a node matches a hexa node. */\nconst isAlphaHex = (node) =>\n\tnode.type === 'word' && alphaHexValueRegExp.test(node.value);\n\n/** Decimal precision. */\nconst alphaDecimalPrecision = 100000;\n\nconst hexa2rgba = (node) => {\n\t// hex is the node value\n\tconst hex = node.value;\n\n\t// conditionally expand a hex\n\tconst hex8 = `0x${\n\t\thex.length === 5 ? hex.slice(1).replace(/[0-9A-f]/g, '$&$&') : hex.slice(1)\n\t}`;\n\n\t// extract the red, blue, green, and alpha values from the hex\n\tconst [r, g, b, a] = [\n\t\tparseInt(hex8.slice(2, 4), 16),\n\t\tparseInt(hex8.slice(4, 6), 16),\n\t\tparseInt(hex8.slice(6, 8), 16),\n\t\tMath.round(\n\t\t\t(parseInt(hex8.slice(8, 10), 16) / 255) * alphaDecimalPrecision,\n\t\t) / alphaDecimalPrecision,\n\t];\n\n\tnode.value = `rgba(${r},${g},${b},${a})`;\n};\n\nexport default onCSSDeclaration;\n\n/** @typedef {import('postcss').Declaration} CSSDeclaration */\n","import onCSSDeclaration from './onCSSDeclaration';\nimport options from './options';\n\n/** Transform 4 & 8 character hex color notation in CSS. */\nexport default function postcssColorHexAlpha(/** @type {PostCSSPluginInitializer} */ opts) {\n\toptions.preserve = 'preserve' in Object(opts) ? Boolean(opts.preserve) : false;\n\n\treturn {\n\t\tpostcssPlugin: 'postcss-color-hex-alpha',\n\t\tDeclaration: onCSSDeclaration,\n\t};\n}\n\npostcssColorHexAlpha.postcss = true;\n"],"names":["preserve","onCSSDeclaration","decl","hasAlphaHex","value","originalValue","valueAST","valuesParser","walk","node","isAlphaHex","hexa2rgba","modifiedValue","toString","options","cloneBefore","alphaHexValueRegExp","alphaHexRegExp","test","type","hex","hex8","length","slice","replace","r","g","b","a","parseInt","Math","round","postcssColorHexAlpha","opts","Object","Boolean","postcssPlugin","Declaration","postcss"],"mappings":"oCAAA,MAAe,CAEdA,UAAU,GCEX,MAAMC,EAAoBC,OACrBC,EAAYD,GAAO,OACdE,MAAOC,GAAkBH,EAG3BI,EAAWC,EAAaF,GAE9BC,EAASE,MAAMC,IACVC,EAAWD,IACdE,EAAUF,YAING,EAAgBN,EAASO,WAE3BD,IAAkBP,IACjBS,EAAQd,SAAUE,EAAKa,YAAY,CAAEX,MAAOQ,IAC3CV,EAAKE,MAAQQ,KAMfI,EAAsB,yCAGtBC,EAAiB,yCAGjBd,EAAeM,GAASQ,EAAeC,KAAKT,EAAKL,OAGjDM,EAAcD,GACL,SAAdA,EAAKU,MAAmBH,EAAoBE,KAAKT,EAAKL,OAKjDO,EAAaF,UAEZW,EAAMX,EAAKL,MAGXiB,EAAQ,KACE,IAAfD,EAAIE,OAAeF,EAAIG,MAAM,GAAGC,QAAQ,YAAa,QAAUJ,EAAIG,MAAM,MAInEE,EAAGC,EAAGC,EAAGC,GAAK,CACpBC,SAASR,EAAKE,MAAM,EAAG,GAAI,IAC3BM,SAASR,EAAKE,MAAM,EAAG,GAAI,IAC3BM,SAASR,EAAKE,MAAM,EAAG,GAAI,IAC3BO,KAAKC,MACHF,SAASR,EAAKE,MAAM,EAAG,IAAK,IAAM,IAjBR,KAAA,KAqB7Bd,EAAKL,MAAS,QAAOqB,KAAKC,KAAKC,KAAKC,MCzDtB,SAASI,EAA6DC,UACpFnB,EAAQd,SAAW,aAAckC,OAAOD,IAAQE,QAAQF,EAAKjC,UAEtD,CACNoC,cAAe,0BACfC,YAAapC,GAIf+B,EAAqBM,SAAU"}