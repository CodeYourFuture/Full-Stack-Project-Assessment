{"ast":null,"code":"'use strict';\n\n// wrapper around mkdirp for tar's needs.\n\n// TODO: This should probably be a class, not functionally\n// passing around state in a gazillion args.\nvar _classCallCheck = require(\"C:\\\\Users\\\\cuney\\\\OneDrive\\\\Belgeler\\\\GitHub\\\\Full-Stack-Project-Assessment\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\nvar _createClass = require(\"C:\\\\Users\\\\cuney\\\\OneDrive\\\\Belgeler\\\\GitHub\\\\Full-Stack-Project-Assessment\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\nvar _possibleConstructorReturn = require(\"C:\\\\Users\\\\cuney\\\\OneDrive\\\\Belgeler\\\\GitHub\\\\Full-Stack-Project-Assessment\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\nvar _getPrototypeOf = require(\"C:\\\\Users\\\\cuney\\\\OneDrive\\\\Belgeler\\\\GitHub\\\\Full-Stack-Project-Assessment\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\nvar _inherits = require(\"C:\\\\Users\\\\cuney\\\\OneDrive\\\\Belgeler\\\\GitHub\\\\Full-Stack-Project-Assessment\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\nvar _wrapNativeSuper = require(\"C:\\\\Users\\\\cuney\\\\OneDrive\\\\Belgeler\\\\GitHub\\\\Full-Stack-Project-Assessment\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/wrapNativeSuper\");\nvar mkdirp = require('mkdirp');\nvar fs = require('fs');\nvar path = require('path');\nvar chownr = require('chownr');\nvar normPath = require('./normalize-windows-path.js');\nvar SymlinkError = /*#__PURE__*/function (_Error) {\n  _inherits(SymlinkError, _Error);\n  function SymlinkError(symlink, path) {\n    var _this;\n    _classCallCheck(this, SymlinkError);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(SymlinkError).call(this, 'Cannot extract through symbolic link'));\n    _this.path = path;\n    _this.symlink = symlink;\n    return _this;\n  }\n  _createClass(SymlinkError, [{\n    key: \"name\",\n    get: function get() {\n      return 'SylinkError';\n    }\n  }]);\n  return SymlinkError;\n}(_wrapNativeSuper(Error));\nvar CwdError = /*#__PURE__*/function (_Error2) {\n  _inherits(CwdError, _Error2);\n  function CwdError(path, code) {\n    var _this2;\n    _classCallCheck(this, CwdError);\n    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(CwdError).call(this, code + ': Cannot cd into \\'' + path + '\\''));\n    _this2.path = path;\n    _this2.code = code;\n    return _this2;\n  }\n  _createClass(CwdError, [{\n    key: \"name\",\n    get: function get() {\n      return 'CwdError';\n    }\n  }]);\n  return CwdError;\n}(_wrapNativeSuper(Error));\nvar cGet = function cGet(cache, key) {\n  return cache.get(normPath(key));\n};\nvar cSet = function cSet(cache, key, val) {\n  return cache.set(normPath(key), val);\n};\nvar checkCwd = function checkCwd(dir, cb) {\n  fs.stat(dir, function (er, st) {\n    if (er || !st.isDirectory()) {\n      er = new CwdError(dir, er && er.code || 'ENOTDIR');\n    }\n    cb(er);\n  });\n};\nmodule.exports = function (dir, opt, cb) {\n  dir = normPath(dir);\n\n  // if there's any overlap between mask and mode,\n  // then we'll need an explicit chmod\n  var umask = opt.umask;\n  var mode = opt.mode | 448;\n  var needChmod = (mode & umask) !== 0;\n  var uid = opt.uid;\n  var gid = opt.gid;\n  var doChown = typeof uid === 'number' && typeof gid === 'number' && (uid !== opt.processUid || gid !== opt.processGid);\n  var preserve = opt.preserve;\n  var unlink = opt.unlink;\n  var cache = opt.cache;\n  var cwd = normPath(opt.cwd);\n  var done = function done(er, created) {\n    if (er) {\n      cb(er);\n    } else {\n      cSet(cache, dir, true);\n      if (created && doChown) {\n        chownr(created, uid, gid, function (er) {\n          return done(er);\n        });\n      } else if (needChmod) {\n        fs.chmod(dir, mode, cb);\n      } else {\n        cb();\n      }\n    }\n  };\n  if (cache && cGet(cache, dir) === true) {\n    return done();\n  }\n  if (dir === cwd) {\n    return checkCwd(dir, done);\n  }\n  if (preserve) {\n    return mkdirp(dir, {\n      mode: mode\n    }).then(function (made) {\n      return done(null, made);\n    }, done);\n  }\n  var sub = normPath(path.relative(cwd, dir));\n  var parts = sub.split('/');\n  mkdir_(cwd, parts, mode, cache, unlink, cwd, null, done);\n};\nvar mkdir_ = function mkdir_(base, parts, mode, cache, unlink, cwd, created, cb) {\n  if (!parts.length) {\n    return cb(null, created);\n  }\n  var p = parts.shift();\n  var part = normPath(path.resolve(base + '/' + p));\n  if (cGet(cache, part)) {\n    return mkdir_(part, parts, mode, cache, unlink, cwd, created, cb);\n  }\n  fs.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb));\n};\nvar onmkdir = function onmkdir(part, parts, mode, cache, unlink, cwd, created, cb) {\n  return function (er) {\n    if (er) {\n      fs.lstat(part, function (statEr, st) {\n        if (statEr) {\n          statEr.path = statEr.path && normPath(statEr.path);\n          cb(statEr);\n        } else if (st.isDirectory()) {\n          mkdir_(part, parts, mode, cache, unlink, cwd, created, cb);\n        } else if (unlink) {\n          fs.unlink(part, function (er) {\n            if (er) {\n              return cb(er);\n            }\n            fs.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb));\n          });\n        } else if (st.isSymbolicLink()) {\n          return cb(new SymlinkError(part, part + '/' + parts.join('/')));\n        } else {\n          cb(er);\n        }\n      });\n    } else {\n      created = created || part;\n      mkdir_(part, parts, mode, cache, unlink, cwd, created, cb);\n    }\n  };\n};\nvar checkCwdSync = function checkCwdSync(dir) {\n  var ok = false;\n  var code = 'ENOTDIR';\n  try {\n    ok = fs.statSync(dir).isDirectory();\n  } catch (er) {\n    code = er.code;\n  } finally {\n    if (!ok) {\n      throw new CwdError(dir, code);\n    }\n  }\n};\nmodule.exports.sync = function (dir, opt) {\n  dir = normPath(dir);\n  // if there's any overlap between mask and mode,\n  // then we'll need an explicit chmod\n  var umask = opt.umask;\n  var mode = opt.mode | 448;\n  var needChmod = (mode & umask) !== 0;\n  var uid = opt.uid;\n  var gid = opt.gid;\n  var doChown = typeof uid === 'number' && typeof gid === 'number' && (uid !== opt.processUid || gid !== opt.processGid);\n  var preserve = opt.preserve;\n  var unlink = opt.unlink;\n  var cache = opt.cache;\n  var cwd = normPath(opt.cwd);\n  var done = function done(created) {\n    cSet(cache, dir, true);\n    if (created && doChown) {\n      chownr.sync(created, uid, gid);\n    }\n    if (needChmod) {\n      fs.chmodSync(dir, mode);\n    }\n  };\n  if (cache && cGet(cache, dir) === true) {\n    return done();\n  }\n  if (dir === cwd) {\n    checkCwdSync(cwd);\n    return done();\n  }\n  if (preserve) {\n    return done(mkdirp.sync(dir, mode));\n  }\n  var sub = normPath(path.relative(cwd, dir));\n  var parts = sub.split('/');\n  var created = null;\n  for (var p = parts.shift(), part = cwd; p && (part += '/' + p); p = parts.shift()) {\n    part = normPath(path.resolve(part));\n    if (cGet(cache, part)) {\n      continue;\n    }\n    try {\n      fs.mkdirSync(part, mode);\n      created = created || part;\n      cSet(cache, part, true);\n    } catch (er) {\n      var st = fs.lstatSync(part);\n      if (st.isDirectory()) {\n        cSet(cache, part, true);\n        continue;\n      } else if (unlink) {\n        fs.unlinkSync(part);\n        fs.mkdirSync(part, mode);\n        created = created || part;\n        cSet(cache, part, true);\n        continue;\n      } else if (st.isSymbolicLink()) {\n        return new SymlinkError(part, part + '/' + parts.join('/'));\n      }\n    }\n  }\n  return done(created);\n};","map":null,"metadata":{},"sourceType":"script"}