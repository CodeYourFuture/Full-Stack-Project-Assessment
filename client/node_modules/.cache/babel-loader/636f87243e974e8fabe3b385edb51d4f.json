{"ast":null,"code":"'use strict';\n/**\n * Calculate data maxRate\n * @param {Number} [samplesCount= 10]\n * @param {Number} [min= 1000]\n * @returns {Function}\n */\n\nfunction speedometer(samplesCount, min) {\n  samplesCount = samplesCount || 10;\n  const bytes = new Array(samplesCount);\n  const timestamps = new Array(samplesCount);\n  let head = 0;\n  let tail = 0;\n  let firstSampleTS;\n  min = min !== undefined ? min : 1000;\n  return function push(chunkLength) {\n    const now = Date.now();\n    const startedAt = timestamps[tail];\n\n    if (!firstSampleTS) {\n      firstSampleTS = now;\n    }\n\n    bytes[head] = chunkLength;\n    timestamps[head] = now;\n    let i = tail;\n    let bytesCount = 0;\n\n    while (i !== head) {\n      bytesCount += bytes[i++];\n      i = i % samplesCount;\n    }\n\n    head = (head + 1) % samplesCount;\n\n    if (head === tail) {\n      tail = (tail + 1) % samplesCount;\n    }\n\n    if (now - firstSampleTS < min) {\n      return;\n    }\n\n    const passed = startedAt && now - startedAt;\n    return passed ? Math.round(bytesCount * 1000 / passed) : undefined;\n  };\n}\n\nexport default speedometer;","map":{"version":3,"sources":["/Users/anuthapaliya/Documents/GitHub/Full-Stack-Project-Assessment/client/node_modules/axios/lib/helpers/speedometer.js"],"names":["speedometer","samplesCount","min","bytes","Array","timestamps","head","tail","firstSampleTS","undefined","push","chunkLength","now","Date","startedAt","i","bytesCount","passed","Math","round"],"mappings":"AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASA,WAAT,CAAqBC,YAArB,EAAmCC,GAAnC,EAAwC;AACtCD,EAAAA,YAAY,GAAGA,YAAY,IAAI,EAA/B;AACA,QAAME,KAAK,GAAG,IAAIC,KAAJ,CAAUH,YAAV,CAAd;AACA,QAAMI,UAAU,GAAG,IAAID,KAAJ,CAAUH,YAAV,CAAnB;AACA,MAAIK,IAAI,GAAG,CAAX;AACA,MAAIC,IAAI,GAAG,CAAX;AACA,MAAIC,aAAJ;AAEAN,EAAAA,GAAG,GAAGA,GAAG,KAAKO,SAAR,GAAoBP,GAApB,GAA0B,IAAhC;AAEA,SAAO,SAASQ,IAAT,CAAcC,WAAd,EAA2B;AAChC,UAAMC,GAAG,GAAGC,IAAI,CAACD,GAAL,EAAZ;AAEA,UAAME,SAAS,GAAGT,UAAU,CAACE,IAAD,CAA5B;;AAEA,QAAI,CAACC,aAAL,EAAoB;AAClBA,MAAAA,aAAa,GAAGI,GAAhB;AACD;;AAEDT,IAAAA,KAAK,CAACG,IAAD,CAAL,GAAcK,WAAd;AACAN,IAAAA,UAAU,CAACC,IAAD,CAAV,GAAmBM,GAAnB;AAEA,QAAIG,CAAC,GAAGR,IAAR;AACA,QAAIS,UAAU,GAAG,CAAjB;;AAEA,WAAOD,CAAC,KAAKT,IAAb,EAAmB;AACjBU,MAAAA,UAAU,IAAIb,KAAK,CAACY,CAAC,EAAF,CAAnB;AACAA,MAAAA,CAAC,GAAGA,CAAC,GAAGd,YAAR;AACD;;AAEDK,IAAAA,IAAI,GAAG,CAACA,IAAI,GAAG,CAAR,IAAaL,YAApB;;AAEA,QAAIK,IAAI,KAAKC,IAAb,EAAmB;AACjBA,MAAAA,IAAI,GAAG,CAACA,IAAI,GAAG,CAAR,IAAaN,YAApB;AACD;;AAED,QAAIW,GAAG,GAAGJ,aAAN,GAAsBN,GAA1B,EAA+B;AAC7B;AACD;;AAED,UAAMe,MAAM,GAAGH,SAAS,IAAIF,GAAG,GAAGE,SAAlC;AAEA,WAAOG,MAAM,GAAGC,IAAI,CAACC,KAAL,CAAWH,UAAU,GAAG,IAAb,GAAoBC,MAA/B,CAAH,GAA4CR,SAAzD;AACD,GAjCD;AAkCD;;AAED,eAAeT,WAAf","sourcesContent":["'use strict';\n\n/**\n * Calculate data maxRate\n * @param {Number} [samplesCount= 10]\n * @param {Number} [min= 1000]\n * @returns {Function}\n */\nfunction speedometer(samplesCount, min) {\n  samplesCount = samplesCount || 10;\n  const bytes = new Array(samplesCount);\n  const timestamps = new Array(samplesCount);\n  let head = 0;\n  let tail = 0;\n  let firstSampleTS;\n\n  min = min !== undefined ? min : 1000;\n\n  return function push(chunkLength) {\n    const now = Date.now();\n\n    const startedAt = timestamps[tail];\n\n    if (!firstSampleTS) {\n      firstSampleTS = now;\n    }\n\n    bytes[head] = chunkLength;\n    timestamps[head] = now;\n\n    let i = tail;\n    let bytesCount = 0;\n\n    while (i !== head) {\n      bytesCount += bytes[i++];\n      i = i % samplesCount;\n    }\n\n    head = (head + 1) % samplesCount;\n\n    if (head === tail) {\n      tail = (tail + 1) % samplesCount;\n    }\n\n    if (now - firstSampleTS < min) {\n      return;\n    }\n\n    const passed = startedAt && now - startedAt;\n\n    return passed ? Math.round(bytesCount * 1000 / passed) : undefined;\n  };\n}\n\nexport default speedometer;\n"]},"metadata":{},"sourceType":"module"}