{"ast":null,"code":"'use client';\n\nimport _slicedToArray from \"/home/coder/Documents/CYF1/Full-Stack-Project-Assessment/client/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\n\nfunction areEqual(a, b) {\n  return a === b;\n}\n\nvar EMPTY_OBJECT = {};\n\nvar NOOP = function NOOP() {};\n/**\n * Gets the current state augmented with controlled values from the outside.\n * If a state item has a corresponding controlled value, it will be used instead of the internal state.\n */\n\n\nfunction getControlledState(internalState, controlledProps) {\n  var augmentedState = _extends({}, internalState);\n\n  Object.keys(controlledProps).forEach(function (key) {\n    if (controlledProps[key] !== undefined) {\n      augmentedState[key] = controlledProps[key];\n    }\n  });\n  return augmentedState;\n}\n/**\n * Defines an effect that compares the next state with the previous state and calls\n * the `onStateChange` callback if the state has changed.\n * The comparison is done based on the `stateComparers` parameter.\n */\n\n\nfunction useStateChangeDetection(parameters) {\n  var nextState = parameters.nextState,\n      initialState = parameters.initialState,\n      stateComparers = parameters.stateComparers,\n      onStateChange = parameters.onStateChange,\n      controlledProps = parameters.controlledProps,\n      lastActionRef = parameters.lastActionRef;\n  var internalPreviousStateRef = React.useRef(initialState);\n  React.useEffect(function () {\n    if (lastActionRef.current === null) {\n      // Detect changes only if an action has been dispatched.\n      return;\n    }\n\n    var previousState = getControlledState(internalPreviousStateRef.current, controlledProps);\n    Object.keys(nextState).forEach(function (key) {\n      var _stateComparers$key; // go through all state keys and compare them with the previous state\n\n\n      var stateComparer = (_stateComparers$key = stateComparers[key]) != null ? _stateComparers$key : areEqual;\n      var nextStateItem = nextState[key];\n      var previousStateItem = previousState[key];\n\n      if (previousStateItem == null && nextStateItem != null || previousStateItem != null && nextStateItem == null || previousStateItem != null && nextStateItem != null && !stateComparer(nextStateItem, previousStateItem)) {\n        var _event, _type;\n\n        onStateChange == null ? void 0 : onStateChange((_event = lastActionRef.current.event) != null ? _event : null, key, nextStateItem, (_type = lastActionRef.current.type) != null ? _type : '', nextState);\n      }\n    });\n    internalPreviousStateRef.current = nextState;\n    lastActionRef.current = null;\n  }, [internalPreviousStateRef, nextState, lastActionRef, onStateChange, stateComparers, controlledProps]);\n}\n/**\n * The alternative to `React.useReducer` that lets you control the state from the outside.\n *\n * It can be used in an uncontrolled mode, similar to `React.useReducer`, or in a controlled mode, when the state is controlled by the props.\n * It also supports partially controlled state, when some state items are controlled and some are not.\n *\n * The controlled state items are provided via the `controlledProps` parameter.\n * When a reducer action is dispatched, the internal state is updated with the new values.\n * A change event (`onStateChange`) is then triggered (for each changed state item) if the new state is different from the previous state.\n * This event can be used to update the controlled values.\n *\n * The comparison of the previous and next states is done using the `stateComparers` parameter.\n * If a state item has a corresponding comparer, it will be used to determine if the state has changed.\n * This is useful when the state item is an object and you want to compare only a subset of its properties or if it's an array and you want to compare its contents.\n *\n * An additional feature is the `actionContext` parameter. It allows you to add additional properties to every action object,\n * similarly to how React context is implicitly available to every component.\n *\n * @template State - The type of the state calculated by the reducer.\n * @template Action - The type of the actions that can be dispatched.\n * @template ActionContext - The type of the additional properties that will be added to every action object.\n *\n * @ignore - internal hook.\n */\n\n\nexport function useControllableReducer(parameters) {\n  var lastActionRef = React.useRef(null);\n  var reducer = parameters.reducer,\n      initialState = parameters.initialState,\n      _parameters$controlle = parameters.controlledProps,\n      controlledProps = _parameters$controlle === void 0 ? EMPTY_OBJECT : _parameters$controlle,\n      _parameters$stateComp = parameters.stateComparers,\n      stateComparers = _parameters$stateComp === void 0 ? EMPTY_OBJECT : _parameters$stateComp,\n      _parameters$onStateCh = parameters.onStateChange,\n      onStateChange = _parameters$onStateCh === void 0 ? NOOP : _parameters$onStateCh,\n      actionContext = parameters.actionContext; // The reducer that is passed to React.useReducer is wrapped with a function that augments the state with controlled values.\n\n  var reducerWithControlledState = React.useCallback(function (state, action) {\n    lastActionRef.current = action;\n    var controlledState = getControlledState(state, controlledProps);\n    var newState = reducer(controlledState, action);\n    return newState;\n  }, [controlledProps, reducer]);\n\n  var _React$useReducer = React.useReducer(reducerWithControlledState, initialState),\n      _React$useReducer2 = _slicedToArray(_React$useReducer, 2),\n      nextState = _React$useReducer2[0],\n      dispatch = _React$useReducer2[1]; // The action that is passed to dispatch is augmented with the actionContext.\n\n\n  var dispatchWithContext = React.useCallback(function (action) {\n    dispatch(_extends({}, action, {\n      context: actionContext\n    }));\n  }, [actionContext]);\n  useStateChangeDetection({\n    nextState: nextState,\n    initialState: initialState,\n    stateComparers: stateComparers != null ? stateComparers : EMPTY_OBJECT,\n    onStateChange: onStateChange != null ? onStateChange : NOOP,\n    controlledProps: controlledProps,\n    lastActionRef: lastActionRef\n  });\n  return [getControlledState(nextState, controlledProps), dispatchWithContext];\n}","map":{"version":3,"sources":["/home/coder/Documents/CYF1/Full-Stack-Project-Assessment/client/node_modules/@mui/base/utils/useControllableReducer.js"],"names":["_extends","React","areEqual","a","b","EMPTY_OBJECT","NOOP","getControlledState","internalState","controlledProps","augmentedState","Object","keys","forEach","key","undefined","useStateChangeDetection","parameters","nextState","initialState","stateComparers","onStateChange","lastActionRef","internalPreviousStateRef","useRef","useEffect","current","previousState","_stateComparers$key","stateComparer","nextStateItem","previousStateItem","_event","_type","event","type","useControllableReducer","reducer","actionContext","reducerWithControlledState","useCallback","state","action","controlledState","newState","useReducer","dispatch","dispatchWithContext","context"],"mappings":"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","sourcesContent":["'use client';\n\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nfunction areEqual(a, b) {\n  return a === b;\n}\nconst EMPTY_OBJECT = {};\nconst NOOP = () => {};\n\n/**\n * Gets the current state augmented with controlled values from the outside.\n * If a state item has a corresponding controlled value, it will be used instead of the internal state.\n */\nfunction getControlledState(internalState, controlledProps) {\n  const augmentedState = _extends({}, internalState);\n  Object.keys(controlledProps).forEach(key => {\n    if (controlledProps[key] !== undefined) {\n      augmentedState[key] = controlledProps[key];\n    }\n  });\n  return augmentedState;\n}\n/**\n * Defines an effect that compares the next state with the previous state and calls\n * the `onStateChange` callback if the state has changed.\n * The comparison is done based on the `stateComparers` parameter.\n */\nfunction useStateChangeDetection(parameters) {\n  const {\n    nextState,\n    initialState,\n    stateComparers,\n    onStateChange,\n    controlledProps,\n    lastActionRef\n  } = parameters;\n  const internalPreviousStateRef = React.useRef(initialState);\n  React.useEffect(() => {\n    if (lastActionRef.current === null) {\n      // Detect changes only if an action has been dispatched.\n      return;\n    }\n    const previousState = getControlledState(internalPreviousStateRef.current, controlledProps);\n    Object.keys(nextState).forEach(key => {\n      var _stateComparers$key;\n      // go through all state keys and compare them with the previous state\n      const stateComparer = (_stateComparers$key = stateComparers[key]) != null ? _stateComparers$key : areEqual;\n      const nextStateItem = nextState[key];\n      const previousStateItem = previousState[key];\n      if (previousStateItem == null && nextStateItem != null || previousStateItem != null && nextStateItem == null || previousStateItem != null && nextStateItem != null && !stateComparer(nextStateItem, previousStateItem)) {\n        var _event, _type;\n        onStateChange == null ? void 0 : onStateChange((_event = lastActionRef.current.event) != null ? _event : null, key, nextStateItem, (_type = lastActionRef.current.type) != null ? _type : '', nextState);\n      }\n    });\n    internalPreviousStateRef.current = nextState;\n    lastActionRef.current = null;\n  }, [internalPreviousStateRef, nextState, lastActionRef, onStateChange, stateComparers, controlledProps]);\n}\n\n/**\n * The alternative to `React.useReducer` that lets you control the state from the outside.\n *\n * It can be used in an uncontrolled mode, similar to `React.useReducer`, or in a controlled mode, when the state is controlled by the props.\n * It also supports partially controlled state, when some state items are controlled and some are not.\n *\n * The controlled state items are provided via the `controlledProps` parameter.\n * When a reducer action is dispatched, the internal state is updated with the new values.\n * A change event (`onStateChange`) is then triggered (for each changed state item) if the new state is different from the previous state.\n * This event can be used to update the controlled values.\n *\n * The comparison of the previous and next states is done using the `stateComparers` parameter.\n * If a state item has a corresponding comparer, it will be used to determine if the state has changed.\n * This is useful when the state item is an object and you want to compare only a subset of its properties or if it's an array and you want to compare its contents.\n *\n * An additional feature is the `actionContext` parameter. It allows you to add additional properties to every action object,\n * similarly to how React context is implicitly available to every component.\n *\n * @template State - The type of the state calculated by the reducer.\n * @template Action - The type of the actions that can be dispatched.\n * @template ActionContext - The type of the additional properties that will be added to every action object.\n *\n * @ignore - internal hook.\n */\nexport function useControllableReducer(parameters) {\n  const lastActionRef = React.useRef(null);\n  const {\n    reducer,\n    initialState,\n    controlledProps = EMPTY_OBJECT,\n    stateComparers = EMPTY_OBJECT,\n    onStateChange = NOOP,\n    actionContext\n  } = parameters;\n\n  // The reducer that is passed to React.useReducer is wrapped with a function that augments the state with controlled values.\n  const reducerWithControlledState = React.useCallback((state, action) => {\n    lastActionRef.current = action;\n    const controlledState = getControlledState(state, controlledProps);\n    const newState = reducer(controlledState, action);\n    return newState;\n  }, [controlledProps, reducer]);\n  const [nextState, dispatch] = React.useReducer(reducerWithControlledState, initialState);\n\n  // The action that is passed to dispatch is augmented with the actionContext.\n  const dispatchWithContext = React.useCallback(action => {\n    dispatch(_extends({}, action, {\n      context: actionContext\n    }));\n  }, [actionContext]);\n  useStateChangeDetection({\n    nextState,\n    initialState,\n    stateComparers: stateComparers != null ? stateComparers : EMPTY_OBJECT,\n    onStateChange: onStateChange != null ? onStateChange : NOOP,\n    controlledProps,\n    lastActionRef\n  });\n  return [getControlledState(nextState, controlledProps), dispatchWithContext];\n}"]},"metadata":{},"sourceType":"module"}