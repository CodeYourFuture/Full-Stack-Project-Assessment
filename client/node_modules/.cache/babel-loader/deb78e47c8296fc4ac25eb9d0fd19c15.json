{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\cuney\\\\OneDrive\\\\Belgeler\\\\GitHub\\\\Full-Stack-Project-Assessment\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\nvar _createClass = require(\"C:\\\\Users\\\\cuney\\\\OneDrive\\\\Belgeler\\\\GitHub\\\\Full-Stack-Project-Assessment\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\nvar _possibleConstructorReturn = require(\"C:\\\\Users\\\\cuney\\\\OneDrive\\\\Belgeler\\\\GitHub\\\\Full-Stack-Project-Assessment\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\nvar _get = require(\"C:\\\\Users\\\\cuney\\\\OneDrive\\\\Belgeler\\\\GitHub\\\\Full-Stack-Project-Assessment\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/get\");\nvar _getPrototypeOf = require(\"C:\\\\Users\\\\cuney\\\\OneDrive\\\\Belgeler\\\\GitHub\\\\Full-Stack-Project-Assessment\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\nvar _inherits = require(\"C:\\\\Users\\\\cuney\\\\OneDrive\\\\Belgeler\\\\GitHub\\\\Full-Stack-Project-Assessment\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\nvar MiniPass = require('minipass');\nvar EE = require('events').EventEmitter;\nvar fs = require('fs');\nvar writev = fs.writev;\n/* istanbul ignore next */\nif (!writev) {\n  // This entire block can be removed if support for earlier than Node.js\n  // 12.9.0 is not needed.\n  var binding = process.binding('fs');\n  var FSReqWrap = binding.FSReqWrap || binding.FSReqCallback;\n  writev = function writev(fd, iovec, pos, cb) {\n    var done = function done(er, bw) {\n      return cb(er, bw, iovec);\n    };\n    var req = new FSReqWrap();\n    req.oncomplete = done;\n    binding.writeBuffers(fd, iovec, pos, req);\n  };\n}\nvar _autoClose = Symbol('_autoClose');\nvar _close = Symbol('_close');\nvar _ended = Symbol('_ended');\nvar _fd = Symbol('_fd');\nvar _finished = Symbol('_finished');\nvar _flags = Symbol('_flags');\nvar _flush = Symbol('_flush');\nvar _handleChunk = Symbol('_handleChunk');\nvar _makeBuf = Symbol('_makeBuf');\nvar _mode = Symbol('_mode');\nvar _needDrain = Symbol('_needDrain');\nvar _onerror = Symbol('_onerror');\nvar _onopen = Symbol('_onopen');\nvar _onread = Symbol('_onread');\nvar _onwrite = Symbol('_onwrite');\nvar _open = Symbol('_open');\nvar _path = Symbol('_path');\nvar _pos = Symbol('_pos');\nvar _queue = Symbol('_queue');\nvar _read = Symbol('_read');\nvar _readSize = Symbol('_readSize');\nvar _reading = Symbol('_reading');\nvar _remain = Symbol('_remain');\nvar _size = Symbol('_size');\nvar _write = Symbol('_write');\nvar _writing = Symbol('_writing');\nvar _defaultFlag = Symbol('_defaultFlag');\nvar _errored = Symbol('_errored');\nvar ReadStream = /*#__PURE__*/function (_MiniPass) {\n  _inherits(ReadStream, _MiniPass);\n  function ReadStream(path, opt) {\n    var _this;\n    _classCallCheck(this, ReadStream);\n    opt = opt || {};\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ReadStream).call(this, opt));\n    _this.readable = true;\n    _this.writable = false;\n    if (typeof path !== 'string') throw new TypeError('path must be a string');\n    _this[_errored] = false;\n    _this[_fd] = typeof opt.fd === 'number' ? opt.fd : null;\n    _this[_path] = path;\n    _this[_readSize] = opt.readSize || 16 * 1024 * 1024;\n    _this[_reading] = false;\n    _this[_size] = typeof opt.size === 'number' ? opt.size : Infinity;\n    _this[_remain] = _this[_size];\n    _this[_autoClose] = typeof opt.autoClose === 'boolean' ? opt.autoClose : true;\n    if (typeof _this[_fd] === 'number') _this[_read]();else _this[_open]();\n    return _this;\n  }\n  _createClass(ReadStream, [{\n    key: \"write\",\n    value: function write() {\n      throw new TypeError('this is a readable stream');\n    }\n  }, {\n    key: \"end\",\n    value: function end() {\n      throw new TypeError('this is a readable stream');\n    }\n  }, {\n    key: _open,\n    value: function value() {\n      var _this2 = this;\n      fs.open(this[_path], 'r', function (er, fd) {\n        return _this2[_onopen](er, fd);\n      });\n    }\n  }, {\n    key: _onopen,\n    value: function value(er, fd) {\n      if (er) this[_onerror](er);else {\n        this[_fd] = fd;\n        this.emit('open', fd);\n        this[_read]();\n      }\n    }\n  }, {\n    key: _makeBuf,\n    value: function value() {\n      return Buffer.allocUnsafe(Math.min(this[_readSize], this[_remain]));\n    }\n  }, {\n    key: _read,\n    value: function value() {\n      var _this3 = this;\n      if (!this[_reading]) {\n        this[_reading] = true;\n        var buf = this[_makeBuf]();\n        /* istanbul ignore if */\n        if (buf.length === 0) return process.nextTick(function () {\n          return _this3[_onread](null, 0, buf);\n        });\n        fs.read(this[_fd], buf, 0, buf.length, null, function (er, br, buf) {\n          return _this3[_onread](er, br, buf);\n        });\n      }\n    }\n  }, {\n    key: _onread,\n    value: function value(er, br, buf) {\n      this[_reading] = false;\n      if (er) this[_onerror](er);else if (this[_handleChunk](br, buf)) this[_read]();\n    }\n  }, {\n    key: _close,\n    value: function value() {\n      var _this4 = this;\n      if (this[_autoClose] && typeof this[_fd] === 'number') {\n        var fd = this[_fd];\n        this[_fd] = null;\n        fs.close(fd, function (er) {\n          return er ? _this4.emit('error', er) : _this4.emit('close');\n        });\n      }\n    }\n  }, {\n    key: _onerror,\n    value: function value(er) {\n      this[_reading] = true;\n      this[_close]();\n      this.emit('error', er);\n    }\n  }, {\n    key: _handleChunk,\n    value: function value(br, buf) {\n      var ret = false;\n      // no effect if infinite\n      this[_remain] -= br;\n      if (br > 0) ret = _get(_getPrototypeOf(ReadStream.prototype), \"write\", this).call(this, br < buf.length ? buf.slice(0, br) : buf);\n      if (br === 0 || this[_remain] <= 0) {\n        ret = false;\n        this[_close]();\n        _get(_getPrototypeOf(ReadStream.prototype), \"end\", this).call(this);\n      }\n      return ret;\n    }\n  }, {\n    key: \"emit\",\n    value: function emit(ev, data) {\n      switch (ev) {\n        case 'prefinish':\n        case 'finish':\n          break;\n        case 'drain':\n          if (typeof this[_fd] === 'number') this[_read]();\n          break;\n        case 'error':\n          if (this[_errored]) return;\n          this[_errored] = true;\n          return _get(_getPrototypeOf(ReadStream.prototype), \"emit\", this).call(this, ev, data);\n        default:\n          return _get(_getPrototypeOf(ReadStream.prototype), \"emit\", this).call(this, ev, data);\n      }\n    }\n  }, {\n    key: \"fd\",\n    get: function get() {\n      return this[_fd];\n    }\n  }, {\n    key: \"path\",\n    get: function get() {\n      return this[_path];\n    }\n  }]);\n  return ReadStream;\n}(MiniPass);\nvar ReadStreamSync = /*#__PURE__*/function (_ReadStream) {\n  _inherits(ReadStreamSync, _ReadStream);\n  function ReadStreamSync() {\n    _classCallCheck(this, ReadStreamSync);\n    return _possibleConstructorReturn(this, _getPrototypeOf(ReadStreamSync).apply(this, arguments));\n  }\n  _createClass(ReadStreamSync, [{\n    key: _open,\n    value: function value() {\n      var threw = true;\n      try {\n        this[_onopen](null, fs.openSync(this[_path], 'r'));\n        threw = false;\n      } finally {\n        if (threw) this[_close]();\n      }\n    }\n  }, {\n    key: _read,\n    value: function value() {\n      var threw = true;\n      try {\n        if (!this[_reading]) {\n          this[_reading] = true;\n          do {\n            var buf = this[_makeBuf]();\n            /* istanbul ignore next */\n            var br = buf.length === 0 ? 0 : fs.readSync(this[_fd], buf, 0, buf.length, null);\n            if (!this[_handleChunk](br, buf)) break;\n          } while (true);\n          this[_reading] = false;\n        }\n        threw = false;\n      } finally {\n        if (threw) this[_close]();\n      }\n    }\n  }, {\n    key: _close,\n    value: function value() {\n      if (this[_autoClose] && typeof this[_fd] === 'number') {\n        var fd = this[_fd];\n        this[_fd] = null;\n        fs.closeSync(fd);\n        this.emit('close');\n      }\n    }\n  }]);\n  return ReadStreamSync;\n}(ReadStream);\nvar WriteStream = /*#__PURE__*/function (_EE) {\n  _inherits(WriteStream, _EE);\n  function WriteStream(path, opt) {\n    var _this5;\n    _classCallCheck(this, WriteStream);\n    opt = opt || {};\n    _this5 = _possibleConstructorReturn(this, _getPrototypeOf(WriteStream).call(this, opt));\n    _this5.readable = false;\n    _this5.writable = true;\n    _this5[_errored] = false;\n    _this5[_writing] = false;\n    _this5[_ended] = false;\n    _this5[_needDrain] = false;\n    _this5[_queue] = [];\n    _this5[_path] = path;\n    _this5[_fd] = typeof opt.fd === 'number' ? opt.fd : null;\n    _this5[_mode] = opt.mode === undefined ? 438 : opt.mode;\n    _this5[_pos] = typeof opt.start === 'number' ? opt.start : null;\n    _this5[_autoClose] = typeof opt.autoClose === 'boolean' ? opt.autoClose : true;\n\n    // truncating makes no sense when writing into the middle\n    var defaultFlag = _this5[_pos] !== null ? 'r+' : 'w';\n    _this5[_defaultFlag] = opt.flags === undefined;\n    _this5[_flags] = _this5[_defaultFlag] ? defaultFlag : opt.flags;\n    if (_this5[_fd] === null) _this5[_open]();\n    return _this5;\n  }\n  _createClass(WriteStream, [{\n    key: \"emit\",\n    value: function emit(ev, data) {\n      if (ev === 'error') {\n        if (this[_errored]) return;\n        this[_errored] = true;\n      }\n      return _get(_getPrototypeOf(WriteStream.prototype), \"emit\", this).call(this, ev, data);\n    }\n  }, {\n    key: _onerror,\n    value: function value(er) {\n      this[_close]();\n      this[_writing] = true;\n      this.emit('error', er);\n    }\n  }, {\n    key: _open,\n    value: function value() {\n      var _this6 = this;\n      fs.open(this[_path], this[_flags], this[_mode], function (er, fd) {\n        return _this6[_onopen](er, fd);\n      });\n    }\n  }, {\n    key: _onopen,\n    value: function value(er, fd) {\n      if (this[_defaultFlag] && this[_flags] === 'r+' && er && er.code === 'ENOENT') {\n        this[_flags] = 'w';\n        this[_open]();\n      } else if (er) this[_onerror](er);else {\n        this[_fd] = fd;\n        this.emit('open', fd);\n        this[_flush]();\n      }\n    }\n  }, {\n    key: \"end\",\n    value: function end(buf, enc) {\n      if (buf) this.write(buf, enc);\n      this[_ended] = true;\n\n      // synthetic after-write logic, where drain/finish live\n      if (!this[_writing] && !this[_queue].length && typeof this[_fd] === 'number') this[_onwrite](null, 0);\n      return this;\n    }\n  }, {\n    key: \"write\",\n    value: function write(buf, enc) {\n      if (typeof buf === 'string') buf = Buffer.from(buf, enc);\n      if (this[_ended]) {\n        this.emit('error', new Error('write() after end()'));\n        return false;\n      }\n      if (this[_fd] === null || this[_writing] || this[_queue].length) {\n        this[_queue].push(buf);\n        this[_needDrain] = true;\n        return false;\n      }\n      this[_writing] = true;\n      this[_write](buf);\n      return true;\n    }\n  }, {\n    key: _write,\n    value: function value(buf) {\n      var _this7 = this;\n      fs.write(this[_fd], buf, 0, buf.length, this[_pos], function (er, bw) {\n        return _this7[_onwrite](er, bw);\n      });\n    }\n  }, {\n    key: _onwrite,\n    value: function value(er, bw) {\n      if (er) this[_onerror](er);else {\n        if (this[_pos] !== null) this[_pos] += bw;\n        if (this[_queue].length) this[_flush]();else {\n          this[_writing] = false;\n          if (this[_ended] && !this[_finished]) {\n            this[_finished] = true;\n            this[_close]();\n            this.emit('finish');\n          } else if (this[_needDrain]) {\n            this[_needDrain] = false;\n            this.emit('drain');\n          }\n        }\n      }\n    }\n  }, {\n    key: _flush,\n    value: function value() {\n      var _this8 = this;\n      if (this[_queue].length === 0) {\n        if (this[_ended]) this[_onwrite](null, 0);\n      } else if (this[_queue].length === 1) this[_write](this[_queue].pop());else {\n        var iovec = this[_queue];\n        this[_queue] = [];\n        writev(this[_fd], iovec, this[_pos], function (er, bw) {\n          return _this8[_onwrite](er, bw);\n        });\n      }\n    }\n  }, {\n    key: _close,\n    value: function value() {\n      var _this9 = this;\n      if (this[_autoClose] && typeof this[_fd] === 'number') {\n        var fd = this[_fd];\n        this[_fd] = null;\n        fs.close(fd, function (er) {\n          return er ? _this9.emit('error', er) : _this9.emit('close');\n        });\n      }\n    }\n  }, {\n    key: \"fd\",\n    get: function get() {\n      return this[_fd];\n    }\n  }, {\n    key: \"path\",\n    get: function get() {\n      return this[_path];\n    }\n  }]);\n  return WriteStream;\n}(EE);\nvar WriteStreamSync = /*#__PURE__*/function (_WriteStream) {\n  _inherits(WriteStreamSync, _WriteStream);\n  function WriteStreamSync() {\n    _classCallCheck(this, WriteStreamSync);\n    return _possibleConstructorReturn(this, _getPrototypeOf(WriteStreamSync).apply(this, arguments));\n  }\n  _createClass(WriteStreamSync, [{\n    key: _open,\n    value: function value() {\n      var fd;\n      // only wrap in a try{} block if we know we'll retry, to avoid\n      // the rethrow obscuring the error's source frame in most cases.\n      if (this[_defaultFlag] && this[_flags] === 'r+') {\n        try {\n          fd = fs.openSync(this[_path], this[_flags], this[_mode]);\n        } catch (er) {\n          if (er.code === 'ENOENT') {\n            this[_flags] = 'w';\n            return this[_open]();\n          } else throw er;\n        }\n      } else fd = fs.openSync(this[_path], this[_flags], this[_mode]);\n      this[_onopen](null, fd);\n    }\n  }, {\n    key: _close,\n    value: function value() {\n      if (this[_autoClose] && typeof this[_fd] === 'number') {\n        var fd = this[_fd];\n        this[_fd] = null;\n        fs.closeSync(fd);\n        this.emit('close');\n      }\n    }\n  }, {\n    key: _write,\n    value: function value(buf) {\n      // throw the original, but try to close if it fails\n      var threw = true;\n      try {\n        this[_onwrite](null, fs.writeSync(this[_fd], buf, 0, buf.length, this[_pos]));\n        threw = false;\n      } finally {\n        if (threw) try {\n          this[_close]();\n        } catch (_) {}\n      }\n    }\n  }]);\n  return WriteStreamSync;\n}(WriteStream);\nexports.ReadStream = ReadStream;\nexports.ReadStreamSync = ReadStreamSync;\nexports.WriteStream = WriteStream;\nexports.WriteStreamSync = WriteStreamSync;","map":null,"metadata":{},"sourceType":"script"}