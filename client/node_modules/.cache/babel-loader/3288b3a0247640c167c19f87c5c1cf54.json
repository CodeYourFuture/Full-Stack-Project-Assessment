{"ast":null,"code":"'use strict';\n\n// A readable tar stream creator\n// Technically, this is a transform stream that you write paths into,\n// and tar format comes out of.\n// The `add()` method is like `write()` but returns this,\n// and end() return `this` as well, so you can\n// do `new Pack(opt).add('files').add('dir').end().pipe(output)\n// You could also do something like:\n// streamOfPaths().pipe(new Pack()).pipe(new fs.WriteStream('out.tar'))\nvar _createClass = require(\"C:\\\\Users\\\\cuney\\\\OneDrive\\\\Belgeler\\\\GitHub\\\\Full-Stack-Project-Assessment\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\nvar _assertThisInitialized = require(\"C:\\\\Users\\\\cuney\\\\OneDrive\\\\Belgeler\\\\GitHub\\\\Full-Stack-Project-Assessment\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/assertThisInitialized\");\nvar _possibleConstructorReturn = require(\"C:\\\\Users\\\\cuney\\\\OneDrive\\\\Belgeler\\\\GitHub\\\\Full-Stack-Project-Assessment\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\nvar _inherits = require(\"C:\\\\Users\\\\cuney\\\\OneDrive\\\\Belgeler\\\\GitHub\\\\Full-Stack-Project-Assessment\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\nvar _get = require(\"C:\\\\Users\\\\cuney\\\\OneDrive\\\\Belgeler\\\\GitHub\\\\Full-Stack-Project-Assessment\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/get\");\nvar _getPrototypeOf = require(\"C:\\\\Users\\\\cuney\\\\OneDrive\\\\Belgeler\\\\GitHub\\\\Full-Stack-Project-Assessment\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\nvar _classCallCheck = require(\"C:\\\\Users\\\\cuney\\\\OneDrive\\\\Belgeler\\\\GitHub\\\\Full-Stack-Project-Assessment\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\nvar PackJob = function PackJob(path, absolute) {\n  _classCallCheck(this, PackJob);\n  this.path = path || './';\n  this.absolute = absolute;\n  this.entry = null;\n  this.stat = null;\n  this.readdir = null;\n  this.pending = false;\n  this.ignore = false;\n  this.piped = false;\n};\nvar MiniPass = require('minipass');\nvar zlib = require('minizlib');\nvar ReadEntry = require('./read-entry.js');\nvar WriteEntry = require('./write-entry.js');\nvar WriteEntrySync = WriteEntry.Sync;\nvar WriteEntryTar = WriteEntry.Tar;\nvar Yallist = require('yallist');\nvar EOF = Buffer.alloc(1024);\nvar ONSTAT = Symbol('onStat');\nvar ENDED = Symbol('ended');\nvar QUEUE = Symbol('queue');\nvar CURRENT = Symbol('current');\nvar PROCESS = Symbol('process');\nvar PROCESSING = Symbol('processing');\nvar PROCESSJOB = Symbol('processJob');\nvar JOBS = Symbol('jobs');\nvar JOBDONE = Symbol('jobDone');\nvar ADDFSENTRY = Symbol('addFSEntry');\nvar ADDTARENTRY = Symbol('addTarEntry');\nvar STAT = Symbol('stat');\nvar READDIR = Symbol('readdir');\nvar ONREADDIR = Symbol('onreaddir');\nvar PIPE = Symbol('pipe');\nvar ENTRY = Symbol('entry');\nvar ENTRYOPT = Symbol('entryOpt');\nvar WRITEENTRYCLASS = Symbol('writeEntryClass');\nvar WRITE = Symbol('write');\nvar ONDRAIN = Symbol('ondrain');\nvar fs = require('fs');\nvar path = require('path');\nvar warner = require('./warn-mixin.js');\nvar normPath = require('./normalize-windows-path.js');\nvar Pack = warner( /*#__PURE__*/function (_MiniPass) {\n  _inherits(Pack, _MiniPass);\n  function Pack(opt) {\n    var _thisSuper, _thisSuper2, _this;\n    _classCallCheck(this, Pack);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Pack).call(this, opt));\n    opt = opt || Object.create(null);\n    _this.opt = opt;\n    _this.file = opt.file || '';\n    _this.cwd = opt.cwd || process.cwd();\n    _this.maxReadSize = opt.maxReadSize;\n    _this.preservePaths = !!opt.preservePaths;\n    _this.strict = !!opt.strict;\n    _this.noPax = !!opt.noPax;\n    _this.prefix = normPath(opt.prefix || '');\n    _this.linkCache = opt.linkCache || new Map();\n    _this.statCache = opt.statCache || new Map();\n    _this.readdirCache = opt.readdirCache || new Map();\n    _this[WRITEENTRYCLASS] = WriteEntry;\n    if (typeof opt.onwarn === 'function') {\n      _this.on('warn', opt.onwarn);\n    }\n    _this.portable = !!opt.portable;\n    _this.zip = null;\n    if (opt.gzip) {\n      if (typeof opt.gzip !== 'object') {\n        opt.gzip = {};\n      }\n      if (_this.portable) {\n        opt.gzip.portable = true;\n      }\n      _this.zip = new zlib.Gzip(opt.gzip);\n      _this.zip.on('data', function (chunk) {\n        return _get((_thisSuper = _assertThisInitialized(_this), _getPrototypeOf(Pack.prototype)), \"write\", _thisSuper).call(_thisSuper, chunk);\n      });\n      _this.zip.on('end', function (_) {\n        return _get((_thisSuper2 = _assertThisInitialized(_this), _getPrototypeOf(Pack.prototype)), \"end\", _thisSuper2).call(_thisSuper2);\n      });\n      _this.zip.on('drain', function (_) {\n        return _this[ONDRAIN]();\n      });\n      _this.on('resume', function (_) {\n        return _this.zip.resume();\n      });\n    } else {\n      _this.on('drain', _this[ONDRAIN]);\n    }\n    _this.noDirRecurse = !!opt.noDirRecurse;\n    _this.follow = !!opt.follow;\n    _this.noMtime = !!opt.noMtime;\n    _this.mtime = opt.mtime || null;\n    _this.filter = typeof opt.filter === 'function' ? opt.filter : function (_) {\n      return true;\n    };\n    _this[QUEUE] = new Yallist();\n    _this[JOBS] = 0;\n    _this.jobs = +opt.jobs || 4;\n    _this[PROCESSING] = false;\n    _this[ENDED] = false;\n    return _this;\n  }\n  _createClass(Pack, [{\n    key: WRITE,\n    value: function value(chunk) {\n      return _get(_getPrototypeOf(Pack.prototype), \"write\", this).call(this, chunk);\n    }\n  }, {\n    key: \"add\",\n    value: function add(path) {\n      this.write(path);\n      return this;\n    }\n  }, {\n    key: \"end\",\n    value: function end(path) {\n      if (path) {\n        this.write(path);\n      }\n      this[ENDED] = true;\n      this[PROCESS]();\n      return this;\n    }\n  }, {\n    key: \"write\",\n    value: function write(path) {\n      if (this[ENDED]) {\n        throw new Error('write after end');\n      }\n      if (path instanceof ReadEntry) {\n        this[ADDTARENTRY](path);\n      } else {\n        this[ADDFSENTRY](path);\n      }\n      return this.flowing;\n    }\n  }, {\n    key: ADDTARENTRY,\n    value: function value(p) {\n      var _this2 = this;\n      var absolute = normPath(path.resolve(this.cwd, p.path));\n      // in this case, we don't have to wait for the stat\n      if (!this.filter(p.path, p)) {\n        p.resume();\n      } else {\n        var job = new PackJob(p.path, absolute, false);\n        job.entry = new WriteEntryTar(p, this[ENTRYOPT](job));\n        job.entry.on('end', function (_) {\n          return _this2[JOBDONE](job);\n        });\n        this[JOBS] += 1;\n        this[QUEUE].push(job);\n      }\n      this[PROCESS]();\n    }\n  }, {\n    key: ADDFSENTRY,\n    value: function value(p) {\n      var absolute = normPath(path.resolve(this.cwd, p));\n      this[QUEUE].push(new PackJob(p, absolute));\n      this[PROCESS]();\n    }\n  }, {\n    key: STAT,\n    value: function value(job) {\n      var _this3 = this;\n      job.pending = true;\n      this[JOBS] += 1;\n      var stat = this.follow ? 'stat' : 'lstat';\n      fs[stat](job.absolute, function (er, stat) {\n        job.pending = false;\n        _this3[JOBS] -= 1;\n        if (er) {\n          _this3.emit('error', er);\n        } else {\n          _this3[ONSTAT](job, stat);\n        }\n      });\n    }\n  }, {\n    key: ONSTAT,\n    value: function value(job, stat) {\n      this.statCache.set(job.absolute, stat);\n      job.stat = stat;\n\n      // now we have the stat, we can filter it.\n      if (!this.filter(job.path, stat)) {\n        job.ignore = true;\n      }\n      this[PROCESS]();\n    }\n  }, {\n    key: READDIR,\n    value: function value(job) {\n      var _this4 = this;\n      job.pending = true;\n      this[JOBS] += 1;\n      fs.readdir(job.absolute, function (er, entries) {\n        job.pending = false;\n        _this4[JOBS] -= 1;\n        if (er) {\n          return _this4.emit('error', er);\n        }\n        _this4[ONREADDIR](job, entries);\n      });\n    }\n  }, {\n    key: ONREADDIR,\n    value: function value(job, entries) {\n      this.readdirCache.set(job.absolute, entries);\n      job.readdir = entries;\n      this[PROCESS]();\n    }\n  }, {\n    key: PROCESS,\n    value: function value() {\n      if (this[PROCESSING]) {\n        return;\n      }\n      this[PROCESSING] = true;\n      for (var w = this[QUEUE].head; w !== null && this[JOBS] < this.jobs; w = w.next) {\n        this[PROCESSJOB](w.value);\n        if (w.value.ignore) {\n          var p = w.next;\n          this[QUEUE].removeNode(w);\n          w.next = p;\n        }\n      }\n      this[PROCESSING] = false;\n      if (this[ENDED] && !this[QUEUE].length && this[JOBS] === 0) {\n        if (this.zip) {\n          this.zip.end(EOF);\n        } else {\n          _get(_getPrototypeOf(Pack.prototype), \"write\", this).call(this, EOF);\n          _get(_getPrototypeOf(Pack.prototype), \"end\", this).call(this);\n        }\n      }\n    }\n  }, {\n    key: JOBDONE,\n    value: function value(job) {\n      this[QUEUE].shift();\n      this[JOBS] -= 1;\n      this[PROCESS]();\n    }\n  }, {\n    key: PROCESSJOB,\n    value: function value(job) {\n      if (job.pending) {\n        return;\n      }\n      if (job.entry) {\n        if (job === this[CURRENT] && !job.piped) {\n          this[PIPE](job);\n        }\n        return;\n      }\n      if (!job.stat) {\n        if (this.statCache.has(job.absolute)) {\n          this[ONSTAT](job, this.statCache.get(job.absolute));\n        } else {\n          this[STAT](job);\n        }\n      }\n      if (!job.stat) {\n        return;\n      }\n\n      // filtered out!\n      if (job.ignore) {\n        return;\n      }\n      if (!this.noDirRecurse && job.stat.isDirectory() && !job.readdir) {\n        if (this.readdirCache.has(job.absolute)) {\n          this[ONREADDIR](job, this.readdirCache.get(job.absolute));\n        } else {\n          this[READDIR](job);\n        }\n        if (!job.readdir) {\n          return;\n        }\n      }\n\n      // we know it doesn't have an entry, because that got checked above\n      job.entry = this[ENTRY](job);\n      if (!job.entry) {\n        job.ignore = true;\n        return;\n      }\n      if (job === this[CURRENT] && !job.piped) {\n        this[PIPE](job);\n      }\n    }\n  }, {\n    key: ENTRYOPT,\n    value: function value(job) {\n      var _this5 = this;\n      return {\n        onwarn: function onwarn(code, msg, data) {\n          return _this5.warn(code, msg, data);\n        },\n        noPax: this.noPax,\n        cwd: this.cwd,\n        absolute: job.absolute,\n        preservePaths: this.preservePaths,\n        maxReadSize: this.maxReadSize,\n        strict: this.strict,\n        portable: this.portable,\n        linkCache: this.linkCache,\n        statCache: this.statCache,\n        noMtime: this.noMtime,\n        mtime: this.mtime,\n        prefix: this.prefix\n      };\n    }\n  }, {\n    key: ENTRY,\n    value: function value(job) {\n      var _this6 = this;\n      this[JOBS] += 1;\n      try {\n        return new this[WRITEENTRYCLASS](job.path, this[ENTRYOPT](job)).on('end', function () {\n          return _this6[JOBDONE](job);\n        }).on('error', function (er) {\n          return _this6.emit('error', er);\n        });\n      } catch (er) {\n        this.emit('error', er);\n      }\n    }\n  }, {\n    key: ONDRAIN,\n    value: function value() {\n      if (this[CURRENT] && this[CURRENT].entry) {\n        this[CURRENT].entry.resume();\n      }\n    } // like .pipe() but using super, because our write() is special\n  }, {\n    key: PIPE,\n    value: function value(job) {\n      var _this7 = this;\n      job.piped = true;\n      if (job.readdir) {\n        job.readdir.forEach(function (entry) {\n          var p = job.path;\n          var base = p === './' ? '' : p.replace(/\\/*$/, '/');\n          _this7[ADDFSENTRY](base + entry);\n        });\n      }\n      var source = job.entry;\n      var zip = this.zip;\n      if (zip) {\n        source.on('data', function (chunk) {\n          if (!zip.write(chunk)) {\n            source.pause();\n          }\n        });\n      } else {\n        source.on('data', function (chunk) {\n          if (!_get(_getPrototypeOf(Pack.prototype), \"write\", _this7).call(_this7, chunk)) {\n            source.pause();\n          }\n        });\n      }\n    }\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      if (this.zip) {\n        this.zip.pause();\n      }\n      return _get(_getPrototypeOf(Pack.prototype), \"pause\", this).call(this);\n    }\n  }, {\n    key: CURRENT,\n    get: function get() {\n      return this[QUEUE] && this[QUEUE].head && this[QUEUE].head.value;\n    }\n  }]);\n  return Pack;\n}(MiniPass));\nvar PackSync = /*#__PURE__*/function (_Pack) {\n  _inherits(PackSync, _Pack);\n  function PackSync(opt) {\n    var _this8;\n    _classCallCheck(this, PackSync);\n    _this8 = _possibleConstructorReturn(this, _getPrototypeOf(PackSync).call(this, opt));\n    _this8[WRITEENTRYCLASS] = WriteEntrySync;\n    return _this8;\n  }\n\n  // pause/resume are no-ops in sync streams.\n  _createClass(PackSync, [{\n    key: \"pause\",\n    value: function pause() {}\n  }, {\n    key: \"resume\",\n    value: function resume() {}\n  }, {\n    key: STAT,\n    value: function value(job) {\n      var stat = this.follow ? 'statSync' : 'lstatSync';\n      this[ONSTAT](job, fs[stat](job.absolute));\n    }\n  }, {\n    key: READDIR,\n    value: function value(job, stat) {\n      this[ONREADDIR](job, fs.readdirSync(job.absolute));\n    } // gotta get it all in this tick\n  }, {\n    key: PIPE,\n    value: function value(job) {\n      var _this9 = this;\n      var source = job.entry;\n      var zip = this.zip;\n      if (job.readdir) {\n        job.readdir.forEach(function (entry) {\n          var p = job.path;\n          var base = p === './' ? '' : p.replace(/\\/*$/, '/');\n          _this9[ADDFSENTRY](base + entry);\n        });\n      }\n      if (zip) {\n        source.on('data', function (chunk) {\n          zip.write(chunk);\n        });\n      } else {\n        source.on('data', function (chunk) {\n          _get(_getPrototypeOf(PackSync.prototype), WRITE, _this9).call(_this9, chunk);\n        });\n      }\n    }\n  }]);\n  return PackSync;\n}(Pack);\nPack.Sync = PackSync;\nmodule.exports = Pack;","map":null,"metadata":{},"sourceType":"script"}