{"ast":null,"code":"const sides = ['top', 'right', 'bottom', 'left'];\nconst alignments = ['start', 'end'];\nconst placements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + \"-\" + alignments[0], side + \"-\" + alignments[1]), []);\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\nconst floor = Math.floor;\n\nconst createCoords = v => ({\n  x: v,\n  y: v\n});\n\nconst oppositeSideMap = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nconst oppositeAlignmentMap = {\n  start: 'end',\n  end: 'start'\n};\n\nfunction clamp(start, value, end) {\n  return max(start, min(value, end));\n}\n\nfunction evaluate(value, param) {\n  return typeof value === 'function' ? value(param) : value;\n}\n\nfunction getSide(placement) {\n  return placement.split('-')[0];\n}\n\nfunction getAlignment(placement) {\n  return placement.split('-')[1];\n}\n\nfunction getOppositeAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\n\nfunction getAxisLength(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\n\nfunction getSideAxis(placement) {\n  return ['top', 'bottom'].includes(getSide(placement)) ? 'y' : 'x';\n}\n\nfunction getAlignmentAxis(placement) {\n  return getOppositeAxis(getSideAxis(placement));\n}\n\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n\n  const alignment = getAlignment(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const length = getAxisLength(alignmentAxis);\n  let mainAlignmentSide = alignmentAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n\n  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];\n}\n\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\n\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);\n}\n\nfunction getSideList(side, isStart, rtl) {\n  const lr = ['left', 'right'];\n  const rl = ['right', 'left'];\n  const tb = ['top', 'bottom'];\n  const bt = ['bottom', 'top'];\n\n  switch (side) {\n    case 'top':\n    case 'bottom':\n      if (rtl) return isStart ? rl : lr;\n      return isStart ? lr : rl;\n\n    case 'left':\n    case 'right':\n      return isStart ? tb : bt;\n\n    default:\n      return [];\n  }\n}\n\nfunction getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\n  const alignment = getAlignment(placement);\n  let list = getSideList(getSide(placement), direction === 'start', rtl);\n\n  if (alignment) {\n    list = list.map(side => side + \"-\" + alignment);\n\n    if (flipAlignment) {\n      list = list.concat(list.map(getOppositeAlignmentPlacement));\n    }\n  }\n\n  return list;\n}\n\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);\n}\n\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\n\nfunction getPaddingObject(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\n\nfunction rectToClientRect(rect) {\n  return { ...rect,\n    top: rect.y,\n    left: rect.x,\n    right: rect.x + rect.width,\n    bottom: rect.y + rect.height\n  };\n}\n\nexport { alignments, clamp, createCoords, evaluate, expandPaddingObject, floor, getAlignment, getAlignmentAxis, getAlignmentSides, getAxisLength, getExpandedPlacements, getOppositeAlignmentPlacement, getOppositeAxis, getOppositeAxisPlacements, getOppositePlacement, getPaddingObject, getSide, getSideAxis, max, min, placements, rectToClientRect, round, sides };","map":{"version":3,"sources":["C:/Users/User/OneDrive/Documents/CYF/Full-Stack-Project-Assessment/client/node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs"],"names":["sides","alignments","placements","reduce","acc","side","concat","min","Math","max","round","floor","createCoords","v","x","y","oppositeSideMap","left","right","bottom","top","oppositeAlignmentMap","start","end","clamp","value","evaluate","param","getSide","placement","split","getAlignment","getOppositeAxis","axis","getAxisLength","getSideAxis","includes","getAlignmentAxis","getAlignmentSides","rects","rtl","alignment","alignmentAxis","length","mainAlignmentSide","reference","floating","getOppositePlacement","getExpandedPlacements","oppositePlacement","getOppositeAlignmentPlacement","replace","getSideList","isStart","lr","rl","tb","bt","getOppositeAxisPlacements","flipAlignment","direction","list","map","expandPaddingObject","padding","getPaddingObject","rectToClientRect","rect","width","height"],"mappings":"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","sourcesContent":["const sides = ['top', 'right', 'bottom', 'left'];\r\nconst alignments = ['start', 'end'];\r\nconst placements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + \"-\" + alignments[0], side + \"-\" + alignments[1]), []);\r\nconst min = Math.min;\r\nconst max = Math.max;\r\nconst round = Math.round;\r\nconst floor = Math.floor;\r\nconst createCoords = v => ({\r\n  x: v,\r\n  y: v\r\n});\r\nconst oppositeSideMap = {\r\n  left: 'right',\r\n  right: 'left',\r\n  bottom: 'top',\r\n  top: 'bottom'\r\n};\r\nconst oppositeAlignmentMap = {\r\n  start: 'end',\r\n  end: 'start'\r\n};\r\nfunction clamp(start, value, end) {\r\n  return max(start, min(value, end));\r\n}\r\nfunction evaluate(value, param) {\r\n  return typeof value === 'function' ? value(param) : value;\r\n}\r\nfunction getSide(placement) {\r\n  return placement.split('-')[0];\r\n}\r\nfunction getAlignment(placement) {\r\n  return placement.split('-')[1];\r\n}\r\nfunction getOppositeAxis(axis) {\r\n  return axis === 'x' ? 'y' : 'x';\r\n}\r\nfunction getAxisLength(axis) {\r\n  return axis === 'y' ? 'height' : 'width';\r\n}\r\nfunction getSideAxis(placement) {\r\n  return ['top', 'bottom'].includes(getSide(placement)) ? 'y' : 'x';\r\n}\r\nfunction getAlignmentAxis(placement) {\r\n  return getOppositeAxis(getSideAxis(placement));\r\n}\r\nfunction getAlignmentSides(placement, rects, rtl) {\r\n  if (rtl === void 0) {\r\n    rtl = false;\r\n  }\r\n  const alignment = getAlignment(placement);\r\n  const alignmentAxis = getAlignmentAxis(placement);\r\n  const length = getAxisLength(alignmentAxis);\r\n  let mainAlignmentSide = alignmentAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\r\n  if (rects.reference[length] > rects.floating[length]) {\r\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\r\n  }\r\n  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];\r\n}\r\nfunction getExpandedPlacements(placement) {\r\n  const oppositePlacement = getOppositePlacement(placement);\r\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\r\n}\r\nfunction getOppositeAlignmentPlacement(placement) {\r\n  return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);\r\n}\r\nfunction getSideList(side, isStart, rtl) {\r\n  const lr = ['left', 'right'];\r\n  const rl = ['right', 'left'];\r\n  const tb = ['top', 'bottom'];\r\n  const bt = ['bottom', 'top'];\r\n  switch (side) {\r\n    case 'top':\r\n    case 'bottom':\r\n      if (rtl) return isStart ? rl : lr;\r\n      return isStart ? lr : rl;\r\n    case 'left':\r\n    case 'right':\r\n      return isStart ? tb : bt;\r\n    default:\r\n      return [];\r\n  }\r\n}\r\nfunction getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\r\n  const alignment = getAlignment(placement);\r\n  let list = getSideList(getSide(placement), direction === 'start', rtl);\r\n  if (alignment) {\r\n    list = list.map(side => side + \"-\" + alignment);\r\n    if (flipAlignment) {\r\n      list = list.concat(list.map(getOppositeAlignmentPlacement));\r\n    }\r\n  }\r\n  return list;\r\n}\r\nfunction getOppositePlacement(placement) {\r\n  return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);\r\n}\r\nfunction expandPaddingObject(padding) {\r\n  return {\r\n    top: 0,\r\n    right: 0,\r\n    bottom: 0,\r\n    left: 0,\r\n    ...padding\r\n  };\r\n}\r\nfunction getPaddingObject(padding) {\r\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\r\n    top: padding,\r\n    right: padding,\r\n    bottom: padding,\r\n    left: padding\r\n  };\r\n}\r\nfunction rectToClientRect(rect) {\r\n  return {\r\n    ...rect,\r\n    top: rect.y,\r\n    left: rect.x,\r\n    right: rect.x + rect.width,\r\n    bottom: rect.y + rect.height\r\n  };\r\n}\r\n\r\nexport { alignments, clamp, createCoords, evaluate, expandPaddingObject, floor, getAlignment, getAlignmentAxis, getAlignmentSides, getAxisLength, getExpandedPlacements, getOppositeAlignmentPlacement, getOppositeAxis, getOppositeAxisPlacements, getOppositePlacement, getPaddingObject, getSide, getSideAxis, max, min, placements, rectToClientRect, round, sides };\r\n"]},"metadata":{},"sourceType":"module"}