{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nexport function isPlainObject(item) {\n  return item !== null && typeof item === 'object' && item.constructor === Object;\n}\n\nfunction deepClone(source) {\n  if (!isPlainObject(source)) {\n    return source;\n  }\n\n  const output = {};\n  Object.keys(source).forEach(key => {\n    output[key] = deepClone(source[key]);\n  });\n  return output;\n}\n\nexport default function deepmerge(target, source) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n    clone: true\n  };\n  const output = options.clone ? _extends({}, target) : target;\n\n  if (isPlainObject(target) && isPlainObject(source)) {\n    Object.keys(source).forEach(key => {\n      // Avoid prototype pollution\n      if (key === '__proto__') {\n        return;\n      }\n\n      if (isPlainObject(source[key]) && key in target && isPlainObject(target[key])) {\n        // Since `output` is a clone of `target` and we have narrowed `target` in this block we can cast to the same type.\n        output[key] = deepmerge(target[key], source[key], options);\n      } else if (options.clone) {\n        output[key] = isPlainObject(source[key]) ? deepClone(source[key]) : source[key];\n      } else {\n        output[key] = source[key];\n      }\n    });\n  }\n\n  return output;\n}","map":{"version":3,"sources":["C:/Users/User/OneDrive/Documents/CYF/Full-Stack-Project-Assessment/client/node_modules/@mui/utils/esm/deepmerge.js"],"names":["_extends","isPlainObject","item","constructor","Object","deepClone","source","output","keys","forEach","key","deepmerge","target","options","clone"],"mappings":"AAAA,OAAOA,QAAP,MAAqB,oCAArB;AACA,OAAO,SAASC,aAAT,CAAuBC,IAAvB,EAA6B;AAClC,SAAOA,IAAI,KAAK,IAAT,IAAiB,OAAOA,IAAP,KAAgB,QAAjC,IAA6CA,IAAI,CAACC,WAAL,KAAqBC,MAAzE;AACD;;AACD,SAASC,SAAT,CAAmBC,MAAnB,EAA2B;AACzB,MAAI,CAACL,aAAa,CAACK,MAAD,CAAlB,EAA4B;AAC1B,WAAOA,MAAP;AACD;;AACD,QAAMC,MAAM,GAAG,EAAf;AACAH,EAAAA,MAAM,CAACI,IAAP,CAAYF,MAAZ,EAAoBG,OAApB,CAA4BC,GAAG,IAAI;AACjCH,IAAAA,MAAM,CAACG,GAAD,CAAN,GAAcL,SAAS,CAACC,MAAM,CAACI,GAAD,CAAP,CAAvB;AACD,GAFD;AAGA,SAAOH,MAAP;AACD;;AACD,eAAe,SAASI,SAAT,CAAmBC,MAAnB,EAA2BN,MAA3B,EAEZ;AAAA,MAF+CO,OAE/C,uEAFyD;AAC1DC,IAAAA,KAAK,EAAE;AADmD,GAEzD;AACD,QAAMP,MAAM,GAAGM,OAAO,CAACC,KAAR,GAAgBd,QAAQ,CAAC,EAAD,EAAKY,MAAL,CAAxB,GAAuCA,MAAtD;;AACA,MAAIX,aAAa,CAACW,MAAD,CAAb,IAAyBX,aAAa,CAACK,MAAD,CAA1C,EAAoD;AAClDF,IAAAA,MAAM,CAACI,IAAP,CAAYF,MAAZ,EAAoBG,OAApB,CAA4BC,GAAG,IAAI;AACjC;AACA,UAAIA,GAAG,KAAK,WAAZ,EAAyB;AACvB;AACD;;AACD,UAAIT,aAAa,CAACK,MAAM,CAACI,GAAD,CAAP,CAAb,IAA8BA,GAAG,IAAIE,MAArC,IAA+CX,aAAa,CAACW,MAAM,CAACF,GAAD,CAAP,CAAhE,EAA+E;AAC7E;AACAH,QAAAA,MAAM,CAACG,GAAD,CAAN,GAAcC,SAAS,CAACC,MAAM,CAACF,GAAD,CAAP,EAAcJ,MAAM,CAACI,GAAD,CAApB,EAA2BG,OAA3B,CAAvB;AACD,OAHD,MAGO,IAAIA,OAAO,CAACC,KAAZ,EAAmB;AACxBP,QAAAA,MAAM,CAACG,GAAD,CAAN,GAAcT,aAAa,CAACK,MAAM,CAACI,GAAD,CAAP,CAAb,GAA6BL,SAAS,CAACC,MAAM,CAACI,GAAD,CAAP,CAAtC,GAAsDJ,MAAM,CAACI,GAAD,CAA1E;AACD,OAFM,MAEA;AACLH,QAAAA,MAAM,CAACG,GAAD,CAAN,GAAcJ,MAAM,CAACI,GAAD,CAApB;AACD;AACF,KAbD;AAcD;;AACD,SAAOH,MAAP;AACD","sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\r\nexport function isPlainObject(item) {\r\n  return item !== null && typeof item === 'object' && item.constructor === Object;\r\n}\r\nfunction deepClone(source) {\r\n  if (!isPlainObject(source)) {\r\n    return source;\r\n  }\r\n  const output = {};\r\n  Object.keys(source).forEach(key => {\r\n    output[key] = deepClone(source[key]);\r\n  });\r\n  return output;\r\n}\r\nexport default function deepmerge(target, source, options = {\r\n  clone: true\r\n}) {\r\n  const output = options.clone ? _extends({}, target) : target;\r\n  if (isPlainObject(target) && isPlainObject(source)) {\r\n    Object.keys(source).forEach(key => {\r\n      // Avoid prototype pollution\r\n      if (key === '__proto__') {\r\n        return;\r\n      }\r\n      if (isPlainObject(source[key]) && key in target && isPlainObject(target[key])) {\r\n        // Since `output` is a clone of `target` and we have narrowed `target` in this block we can cast to the same type.\r\n        output[key] = deepmerge(target[key], source[key], options);\r\n      } else if (options.clone) {\r\n        output[key] = isPlainObject(source[key]) ? deepClone(source[key]) : source[key];\r\n      } else {\r\n        output[key] = source[key];\r\n      }\r\n    });\r\n  }\r\n  return output;\r\n}"]},"metadata":{},"sourceType":"module"}