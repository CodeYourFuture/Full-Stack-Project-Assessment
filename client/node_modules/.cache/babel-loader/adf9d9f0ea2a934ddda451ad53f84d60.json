{"ast":null,"code":"var _toConsumableArray = require(\"C:\\\\Users\\\\cuney\\\\OneDrive\\\\Belgeler\\\\GitHub\\\\Full-Stack-Project-Assessment\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/toConsumableArray\");\n// A path exclusive reservation system\n// reserve([list, of, paths], fn)\n// When the fn is first in line for all its paths, it\n// is called with a cb that clears the reservation.\n//\n// Used by async unpack to avoid clobbering paths in use,\n// while still allowing maximal safe parallelization.\n\nvar assert = require('assert');\nvar normalize = require('./normalize-unicode.js');\nvar stripSlashes = require('./strip-trailing-slashes.js');\nvar _require = require('path'),\n  join = _require.join;\nvar platform = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform;\nvar isWindows = platform === 'win32';\nmodule.exports = function () {\n  // path => [function or Set]\n  // A Set object means a directory reservation\n  // A fn is a direct reservation on that path\n  var queues = new Map();\n\n  // fn => {paths:[path,...], dirs:[path, ...]}\n  var reservations = new Map();\n\n  // return a set of parent dirs for a given path\n  // '/a/b/c/d' -> ['/', '/a', '/a/b', '/a/b/c', '/a/b/c/d']\n  var getDirs = function getDirs(path) {\n    var dirs = path.split('/').slice(0, -1).reduce(function (set, path) {\n      if (set.length) {\n        path = join(set[set.length - 1], path);\n      }\n      set.push(path || '/');\n      return set;\n    }, []);\n    return dirs;\n  };\n\n  // functions currently running\n  var running = new Set();\n\n  // return the queues for each path the function cares about\n  // fn => {paths, dirs}\n  var getQueues = function getQueues(fn) {\n    var res = reservations.get(fn);\n    /* istanbul ignore if - unpossible */\n    if (!res) {\n      throw new Error('function does not have any path reservations');\n    }\n    return {\n      paths: res.paths.map(function (path) {\n        return queues.get(path);\n      }),\n      dirs: _toConsumableArray(res.dirs).map(function (path) {\n        return queues.get(path);\n      })\n    };\n  };\n\n  // check if fn is first in line for all its paths, and is\n  // included in the first set for all its dir queues\n  var check = function check(fn) {\n    var _getQueues = getQueues(fn),\n      paths = _getQueues.paths,\n      dirs = _getQueues.dirs;\n    return paths.every(function (q) {\n      return q[0] === fn;\n    }) && dirs.every(function (q) {\n      return q[0] instanceof Set && q[0].has(fn);\n    });\n  };\n\n  // run the function if it's first in line and not already running\n  var run = function run(fn) {\n    if (running.has(fn) || !check(fn)) {\n      return false;\n    }\n    running.add(fn);\n    fn(function () {\n      return clear(fn);\n    });\n    return true;\n  };\n  var clear = function clear(fn) {\n    if (!running.has(fn)) {\n      return false;\n    }\n    var _reservations$get = reservations.get(fn),\n      paths = _reservations$get.paths,\n      dirs = _reservations$get.dirs;\n    var next = new Set();\n    paths.forEach(function (path) {\n      var q = queues.get(path);\n      assert.equal(q[0], fn);\n      if (q.length === 1) {\n        queues.delete(path);\n      } else {\n        q.shift();\n        if (typeof q[0] === 'function') {\n          next.add(q[0]);\n        } else {\n          q[0].forEach(function (fn) {\n            return next.add(fn);\n          });\n        }\n      }\n    });\n    dirs.forEach(function (dir) {\n      var q = queues.get(dir);\n      assert(q[0] instanceof Set);\n      if (q[0].size === 1 && q.length === 1) {\n        queues.delete(dir);\n      } else if (q[0].size === 1) {\n        q.shift();\n\n        // must be a function or else the Set would've been reused\n        next.add(q[0]);\n      } else {\n        q[0].delete(fn);\n      }\n    });\n    running.delete(fn);\n    next.forEach(function (fn) {\n      return run(fn);\n    });\n    return true;\n  };\n  var reserve = function reserve(paths, fn) {\n    // collide on matches across case and unicode normalization\n    // On windows, thanks to the magic of 8.3 shortnames, it is fundamentally\n    // impossible to determine whether two paths refer to the same thing on\n    // disk, without asking the kernel for a shortname.\n    // So, we just pretend that every path matches every other path here,\n    // effectively removing all parallelization on windows.\n    paths = isWindows ? ['win32 parallelization disabled'] : paths.map(function (p) {\n      // don't need normPath, because we skip this entirely for windows\n      return normalize(stripSlashes(join(p))).toLowerCase();\n    });\n    var dirs = new Set(paths.map(function (path) {\n      return getDirs(path);\n    }).reduce(function (a, b) {\n      return a.concat(b);\n    }));\n    reservations.set(fn, {\n      dirs: dirs,\n      paths: paths\n    });\n    paths.forEach(function (path) {\n      var q = queues.get(path);\n      if (!q) {\n        queues.set(path, [fn]);\n      } else {\n        q.push(fn);\n      }\n    });\n    dirs.forEach(function (dir) {\n      var q = queues.get(dir);\n      if (!q) {\n        queues.set(dir, [new Set([fn])]);\n      } else if (q[q.length - 1] instanceof Set) {\n        q[q.length - 1].add(fn);\n      } else {\n        q.push(new Set([fn]));\n      }\n    });\n    return run(fn);\n  };\n  return {\n    check: check,\n    reserve: reserve\n  };\n};","map":null,"metadata":{},"sourceType":"script"}