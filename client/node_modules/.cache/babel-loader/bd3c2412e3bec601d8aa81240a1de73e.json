{"ast":null,"code":"'use strict';\n\nvar fs = require('fs');\nvar path = require('path');\n\n/* istanbul ignore next */\nvar LCHOWN = fs.lchown ? 'lchown' : 'chown';\n/* istanbul ignore next */\nvar LCHOWNSYNC = fs.lchownSync ? 'lchownSync' : 'chownSync';\n\n/* istanbul ignore next */\nvar needEISDIRHandled = fs.lchown && !process.version.match(/v1[1-9]+\\./) && !process.version.match(/v10\\.[6-9]/);\nvar lchownSync = function lchownSync(path, uid, gid) {\n  try {\n    return fs[LCHOWNSYNC](path, uid, gid);\n  } catch (er) {\n    if (er.code !== 'ENOENT') throw er;\n  }\n};\n\n/* istanbul ignore next */\nvar chownSync = function chownSync(path, uid, gid) {\n  try {\n    return fs.chownSync(path, uid, gid);\n  } catch (er) {\n    if (er.code !== 'ENOENT') throw er;\n  }\n};\n\n/* istanbul ignore next */\nvar handleEISDIR = needEISDIRHandled ? function (path, uid, gid, cb) {\n  return function (er) {\n    // Node prior to v10 had a very questionable implementation of\n    // fs.lchown, which would always try to call fs.open on a directory\n    // Fall back to fs.chown in those cases.\n    if (!er || er.code !== 'EISDIR') cb(er);else fs.chown(path, uid, gid, cb);\n  };\n} : function (_, __, ___, cb) {\n  return cb;\n};\n\n/* istanbul ignore next */\nvar handleEISDirSync = needEISDIRHandled ? function (path, uid, gid) {\n  try {\n    return lchownSync(path, uid, gid);\n  } catch (er) {\n    if (er.code !== 'EISDIR') throw er;\n    chownSync(path, uid, gid);\n  }\n} : function (path, uid, gid) {\n  return lchownSync(path, uid, gid);\n};\n\n// fs.readdir could only accept an options object as of node v6\nvar nodeVersion = process.version;\nvar readdir = function readdir(path, options, cb) {\n  return fs.readdir(path, options, cb);\n};\nvar readdirSync = function readdirSync(path, options) {\n  return fs.readdirSync(path, options);\n};\n/* istanbul ignore next */\nif (/^v4\\./.test(nodeVersion)) readdir = function readdir(path, options, cb) {\n  return fs.readdir(path, cb);\n};\nvar chown = function chown(cpath, uid, gid, cb) {\n  fs[LCHOWN](cpath, uid, gid, handleEISDIR(cpath, uid, gid, function (er) {\n    // Skip ENOENT error\n    cb(er && er.code !== 'ENOENT' ? er : null);\n  }));\n};\nvar chownrKid = function chownrKid(p, child, uid, gid, cb) {\n  if (typeof child === 'string') return fs.lstat(path.resolve(p, child), function (er, stats) {\n    // Skip ENOENT error\n    if (er) return cb(er.code !== 'ENOENT' ? er : null);\n    stats.name = child;\n    chownrKid(p, stats, uid, gid, cb);\n  });\n  if (child.isDirectory()) {\n    chownr(path.resolve(p, child.name), uid, gid, function (er) {\n      if (er) return cb(er);\n      var cpath = path.resolve(p, child.name);\n      chown(cpath, uid, gid, cb);\n    });\n  } else {\n    var cpath = path.resolve(p, child.name);\n    chown(cpath, uid, gid, cb);\n  }\n};\nvar chownr = function chownr(p, uid, gid, cb) {\n  readdir(p, {\n    withFileTypes: true\n  }, function (er, children) {\n    // any error other than ENOTDIR or ENOTSUP means it's not readable,\n    // or doesn't exist.  give up.\n    if (er) {\n      if (er.code === 'ENOENT') return cb();else if (er.code !== 'ENOTDIR' && er.code !== 'ENOTSUP') return cb(er);\n    }\n    if (er || !children.length) return chown(p, uid, gid, cb);\n    var len = children.length;\n    var errState = null;\n    var then = function then(er) {\n      if (errState) return;\n      if (er) return cb(errState = er);\n      if (--len === 0) return chown(p, uid, gid, cb);\n    };\n    children.forEach(function (child) {\n      return chownrKid(p, child, uid, gid, then);\n    });\n  });\n};\nvar chownrKidSync = function chownrKidSync(p, child, uid, gid) {\n  if (typeof child === 'string') {\n    try {\n      var stats = fs.lstatSync(path.resolve(p, child));\n      stats.name = child;\n      child = stats;\n    } catch (er) {\n      if (er.code === 'ENOENT') return;else throw er;\n    }\n  }\n  if (child.isDirectory()) chownrSync(path.resolve(p, child.name), uid, gid);\n  handleEISDirSync(path.resolve(p, child.name), uid, gid);\n};\nvar chownrSync = function chownrSync(p, uid, gid) {\n  var children;\n  try {\n    children = readdirSync(p, {\n      withFileTypes: true\n    });\n  } catch (er) {\n    if (er.code === 'ENOENT') return;else if (er.code === 'ENOTDIR' || er.code === 'ENOTSUP') return handleEISDirSync(p, uid, gid);else throw er;\n  }\n  if (children && children.length) children.forEach(function (child) {\n    return chownrKidSync(p, child, uid, gid);\n  });\n  return handleEISDirSync(p, uid, gid);\n};\nmodule.exports = chownr;\nchownr.sync = chownrSync;","map":null,"metadata":{},"sourceType":"script"}