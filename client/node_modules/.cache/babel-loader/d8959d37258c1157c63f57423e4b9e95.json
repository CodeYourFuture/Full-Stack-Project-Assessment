{"ast":null,"code":"/*!\n * vary\n * Copyright(c) 2014-2017 Douglas Christopher Wilson\n * MIT Licensed\n */\n'use strict';\n/**\n * Module exports.\n */\n\nmodule.exports = vary;\nmodule.exports.append = append;\n/**\n * RegExp to match field-name in RFC 7230 sec 3.2\n *\n * field-name    = token\n * token         = 1*tchar\n * tchar         = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" / \"*\"\n *               / \"+\" / \"-\" / \".\" / \"^\" / \"_\" / \"`\" / \"|\" / \"~\"\n *               / DIGIT / ALPHA\n *               ; any VCHAR, except delimiters\n */\n\nvar FIELD_NAME_REGEXP = /^[!#$%&'*+\\-.^_`|~0-9A-Za-z]+$/;\n/**\n * Append a field to a vary header.\n *\n * @param {String} header\n * @param {String|Array} field\n * @return {String}\n * @public\n */\n\nfunction append(header, field) {\n  if (typeof header !== 'string') {\n    throw new TypeError('header argument is required');\n  }\n\n  if (!field) {\n    throw new TypeError('field argument is required');\n  } // get fields array\n\n\n  var fields = !Array.isArray(field) ? parse(String(field)) : field; // assert on invalid field names\n\n  for (var j = 0; j < fields.length; j++) {\n    if (!FIELD_NAME_REGEXP.test(fields[j])) {\n      throw new TypeError('field argument contains an invalid header name');\n    }\n  } // existing, unspecified vary\n\n\n  if (header === '*') {\n    return header;\n  } // enumerate current values\n\n\n  var val = header;\n  var vals = parse(header.toLowerCase()); // unspecified vary\n\n  if (fields.indexOf('*') !== -1 || vals.indexOf('*') !== -1) {\n    return '*';\n  }\n\n  for (var i = 0; i < fields.length; i++) {\n    var fld = fields[i].toLowerCase(); // append value (case-preserving)\n\n    if (vals.indexOf(fld) === -1) {\n      vals.push(fld);\n      val = val ? val + ', ' + fields[i] : fields[i];\n    }\n  }\n\n  return val;\n}\n/**\n * Parse a vary header into an array.\n *\n * @param {String} header\n * @return {Array}\n * @private\n */\n\n\nfunction parse(header) {\n  var end = 0;\n  var list = [];\n  var start = 0; // gather tokens\n\n  for (var i = 0, len = header.length; i < len; i++) {\n    switch (header.charCodeAt(i)) {\n      case 0x20:\n        /*   */\n        if (start === end) {\n          start = end = i + 1;\n        }\n\n        break;\n\n      case 0x2c:\n        /* , */\n        list.push(header.substring(start, end));\n        start = end = i + 1;\n        break;\n\n      default:\n        end = i + 1;\n        break;\n    }\n  } // final token\n\n\n  list.push(header.substring(start, end));\n  return list;\n}\n/**\n * Mark that a request is varied on a header field.\n *\n * @param {Object} res\n * @param {String|Array} field\n * @public\n */\n\n\nfunction vary(res, field) {\n  if (!res || !res.getHeader || !res.setHeader) {\n    // quack quack\n    throw new TypeError('res argument is required');\n  } // get existing header\n\n\n  var val = res.getHeader('Vary') || '';\n  var header = Array.isArray(val) ? val.join(', ') : String(val); // set new header\n\n  if (val = append(header, field)) {\n    res.setHeader('Vary', val);\n  }\n}","map":{"version":3,"sources":["/Users/mickeyhaile/Documents/GitHub/Full-Stack-Project-Assessment/client/node_modules/vary/index.js"],"names":["module","exports","vary","append","FIELD_NAME_REGEXP","header","field","TypeError","fields","Array","isArray","parse","String","j","length","test","val","vals","toLowerCase","indexOf","i","fld","push","end","list","start","len","charCodeAt","substring","res","getHeader","setHeader","join"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;;AAEAA,MAAM,CAACC,OAAP,GAAiBC,IAAjB;AACAF,MAAM,CAACC,OAAP,CAAeE,MAAf,GAAwBA,MAAxB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAIC,iBAAiB,GAAG,gCAAxB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASD,MAAT,CAAiBE,MAAjB,EAAyBC,KAAzB,EAAgC;AAC9B,MAAI,OAAOD,MAAP,KAAkB,QAAtB,EAAgC;AAC9B,UAAM,IAAIE,SAAJ,CAAc,6BAAd,CAAN;AACD;;AAED,MAAI,CAACD,KAAL,EAAY;AACV,UAAM,IAAIC,SAAJ,CAAc,4BAAd,CAAN;AACD,GAP6B,CAS9B;;;AACA,MAAIC,MAAM,GAAG,CAACC,KAAK,CAACC,OAAN,CAAcJ,KAAd,CAAD,GACTK,KAAK,CAACC,MAAM,CAACN,KAAD,CAAP,CADI,GAETA,KAFJ,CAV8B,CAc9B;;AACA,OAAK,IAAIO,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,MAAM,CAACM,MAA3B,EAAmCD,CAAC,EAApC,EAAwC;AACtC,QAAI,CAACT,iBAAiB,CAACW,IAAlB,CAAuBP,MAAM,CAACK,CAAD,CAA7B,CAAL,EAAwC;AACtC,YAAM,IAAIN,SAAJ,CAAc,gDAAd,CAAN;AACD;AACF,GAnB6B,CAqB9B;;;AACA,MAAIF,MAAM,KAAK,GAAf,EAAoB;AAClB,WAAOA,MAAP;AACD,GAxB6B,CA0B9B;;;AACA,MAAIW,GAAG,GAAGX,MAAV;AACA,MAAIY,IAAI,GAAGN,KAAK,CAACN,MAAM,CAACa,WAAP,EAAD,CAAhB,CA5B8B,CA8B9B;;AACA,MAAIV,MAAM,CAACW,OAAP,CAAe,GAAf,MAAwB,CAAC,CAAzB,IAA8BF,IAAI,CAACE,OAAL,CAAa,GAAb,MAAsB,CAAC,CAAzD,EAA4D;AAC1D,WAAO,GAAP;AACD;;AAED,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGZ,MAAM,CAACM,MAA3B,EAAmCM,CAAC,EAApC,EAAwC;AACtC,QAAIC,GAAG,GAAGb,MAAM,CAACY,CAAD,CAAN,CAAUF,WAAV,EAAV,CADsC,CAGtC;;AACA,QAAID,IAAI,CAACE,OAAL,CAAaE,GAAb,MAAsB,CAAC,CAA3B,EAA8B;AAC5BJ,MAAAA,IAAI,CAACK,IAAL,CAAUD,GAAV;AACAL,MAAAA,GAAG,GAAGA,GAAG,GACLA,GAAG,GAAG,IAAN,GAAaR,MAAM,CAACY,CAAD,CADd,GAELZ,MAAM,CAACY,CAAD,CAFV;AAGD;AACF;;AAED,SAAOJ,GAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,SAASL,KAAT,CAAgBN,MAAhB,EAAwB;AACtB,MAAIkB,GAAG,GAAG,CAAV;AACA,MAAIC,IAAI,GAAG,EAAX;AACA,MAAIC,KAAK,GAAG,CAAZ,CAHsB,CAKtB;;AACA,OAAK,IAAIL,CAAC,GAAG,CAAR,EAAWM,GAAG,GAAGrB,MAAM,CAACS,MAA7B,EAAqCM,CAAC,GAAGM,GAAzC,EAA8CN,CAAC,EAA/C,EAAmD;AACjD,YAAQf,MAAM,CAACsB,UAAP,CAAkBP,CAAlB,CAAR;AACE,WAAK,IAAL;AAAW;AACT,YAAIK,KAAK,KAAKF,GAAd,EAAmB;AACjBE,UAAAA,KAAK,GAAGF,GAAG,GAAGH,CAAC,GAAG,CAAlB;AACD;;AACD;;AACF,WAAK,IAAL;AAAW;AACTI,QAAAA,IAAI,CAACF,IAAL,CAAUjB,MAAM,CAACuB,SAAP,CAAiBH,KAAjB,EAAwBF,GAAxB,CAAV;AACAE,QAAAA,KAAK,GAAGF,GAAG,GAAGH,CAAC,GAAG,CAAlB;AACA;;AACF;AACEG,QAAAA,GAAG,GAAGH,CAAC,GAAG,CAAV;AACA;AAZJ;AAcD,GArBqB,CAuBtB;;;AACAI,EAAAA,IAAI,CAACF,IAAL,CAAUjB,MAAM,CAACuB,SAAP,CAAiBH,KAAjB,EAAwBF,GAAxB,CAAV;AAEA,SAAOC,IAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,SAAStB,IAAT,CAAe2B,GAAf,EAAoBvB,KAApB,EAA2B;AACzB,MAAI,CAACuB,GAAD,IAAQ,CAACA,GAAG,CAACC,SAAb,IAA0B,CAACD,GAAG,CAACE,SAAnC,EAA8C;AAC5C;AACA,UAAM,IAAIxB,SAAJ,CAAc,0BAAd,CAAN;AACD,GAJwB,CAMzB;;;AACA,MAAIS,GAAG,GAAGa,GAAG,CAACC,SAAJ,CAAc,MAAd,KAAyB,EAAnC;AACA,MAAIzB,MAAM,GAAGI,KAAK,CAACC,OAAN,CAAcM,GAAd,IACTA,GAAG,CAACgB,IAAJ,CAAS,IAAT,CADS,GAETpB,MAAM,CAACI,GAAD,CAFV,CARyB,CAYzB;;AACA,MAAKA,GAAG,GAAGb,MAAM,CAACE,MAAD,EAASC,KAAT,CAAjB,EAAmC;AACjCuB,IAAAA,GAAG,CAACE,SAAJ,CAAc,MAAd,EAAsBf,GAAtB;AACD;AACF","sourcesContent":["/*!\n * vary\n * Copyright(c) 2014-2017 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module exports.\n */\n\nmodule.exports = vary\nmodule.exports.append = append\n\n/**\n * RegExp to match field-name in RFC 7230 sec 3.2\n *\n * field-name    = token\n * token         = 1*tchar\n * tchar         = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" / \"*\"\n *               / \"+\" / \"-\" / \".\" / \"^\" / \"_\" / \"`\" / \"|\" / \"~\"\n *               / DIGIT / ALPHA\n *               ; any VCHAR, except delimiters\n */\n\nvar FIELD_NAME_REGEXP = /^[!#$%&'*+\\-.^_`|~0-9A-Za-z]+$/\n\n/**\n * Append a field to a vary header.\n *\n * @param {String} header\n * @param {String|Array} field\n * @return {String}\n * @public\n */\n\nfunction append (header, field) {\n  if (typeof header !== 'string') {\n    throw new TypeError('header argument is required')\n  }\n\n  if (!field) {\n    throw new TypeError('field argument is required')\n  }\n\n  // get fields array\n  var fields = !Array.isArray(field)\n    ? parse(String(field))\n    : field\n\n  // assert on invalid field names\n  for (var j = 0; j < fields.length; j++) {\n    if (!FIELD_NAME_REGEXP.test(fields[j])) {\n      throw new TypeError('field argument contains an invalid header name')\n    }\n  }\n\n  // existing, unspecified vary\n  if (header === '*') {\n    return header\n  }\n\n  // enumerate current values\n  var val = header\n  var vals = parse(header.toLowerCase())\n\n  // unspecified vary\n  if (fields.indexOf('*') !== -1 || vals.indexOf('*') !== -1) {\n    return '*'\n  }\n\n  for (var i = 0; i < fields.length; i++) {\n    var fld = fields[i].toLowerCase()\n\n    // append value (case-preserving)\n    if (vals.indexOf(fld) === -1) {\n      vals.push(fld)\n      val = val\n        ? val + ', ' + fields[i]\n        : fields[i]\n    }\n  }\n\n  return val\n}\n\n/**\n * Parse a vary header into an array.\n *\n * @param {String} header\n * @return {Array}\n * @private\n */\n\nfunction parse (header) {\n  var end = 0\n  var list = []\n  var start = 0\n\n  // gather tokens\n  for (var i = 0, len = header.length; i < len; i++) {\n    switch (header.charCodeAt(i)) {\n      case 0x20: /*   */\n        if (start === end) {\n          start = end = i + 1\n        }\n        break\n      case 0x2c: /* , */\n        list.push(header.substring(start, end))\n        start = end = i + 1\n        break\n      default:\n        end = i + 1\n        break\n    }\n  }\n\n  // final token\n  list.push(header.substring(start, end))\n\n  return list\n}\n\n/**\n * Mark that a request is varied on a header field.\n *\n * @param {Object} res\n * @param {String|Array} field\n * @public\n */\n\nfunction vary (res, field) {\n  if (!res || !res.getHeader || !res.setHeader) {\n    // quack quack\n    throw new TypeError('res argument is required')\n  }\n\n  // get existing header\n  var val = res.getHeader('Vary') || ''\n  var header = Array.isArray(val)\n    ? val.join(', ')\n    : String(val)\n\n  // set new header\n  if ((val = append(header, field))) {\n    res.setHeader('Vary', val)\n  }\n}\n"]},"metadata":{},"sourceType":"script"}