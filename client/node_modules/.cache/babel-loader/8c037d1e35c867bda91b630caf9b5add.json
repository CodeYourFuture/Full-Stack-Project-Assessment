{"ast":null,"code":"'use strict';\n\nvar _defineProperty = require(\"C:\\\\Users\\\\cuney\\\\OneDrive\\\\Belgeler\\\\GitHub\\\\Full-Stack-Project-Assessment\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/defineProperty\");\nvar _get = require(\"C:\\\\Users\\\\cuney\\\\OneDrive\\\\Belgeler\\\\GitHub\\\\Full-Stack-Project-Assessment\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/get\");\nvar _classCallCheck = require(\"C:\\\\Users\\\\cuney\\\\OneDrive\\\\Belgeler\\\\GitHub\\\\Full-Stack-Project-Assessment\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\nvar _createClass = require(\"C:\\\\Users\\\\cuney\\\\OneDrive\\\\Belgeler\\\\GitHub\\\\Full-Stack-Project-Assessment\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\nvar _possibleConstructorReturn = require(\"C:\\\\Users\\\\cuney\\\\OneDrive\\\\Belgeler\\\\GitHub\\\\Full-Stack-Project-Assessment\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\nvar _getPrototypeOf = require(\"C:\\\\Users\\\\cuney\\\\OneDrive\\\\Belgeler\\\\GitHub\\\\Full-Stack-Project-Assessment\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\nvar _inherits = require(\"C:\\\\Users\\\\cuney\\\\OneDrive\\\\Belgeler\\\\GitHub\\\\Full-Stack-Project-Assessment\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\nvar _assertThisInitialized = require(\"C:\\\\Users\\\\cuney\\\\OneDrive\\\\Belgeler\\\\GitHub\\\\Full-Stack-Project-Assessment\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/assertThisInitialized\");\nvar _wrapNativeSuper = require(\"C:\\\\Users\\\\cuney\\\\OneDrive\\\\Belgeler\\\\GitHub\\\\Full-Stack-Project-Assessment\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/wrapNativeSuper\");\nvar assert = require('assert');\nvar Buffer = require('buffer').Buffer;\nvar realZlib = require('zlib');\nvar constants = exports.constants = require('./constants.js');\nvar Minipass = require('minipass');\nvar OriginalBufferConcat = Buffer.concat;\nvar _superWrite = Symbol('_superWrite');\nvar ZlibError = /*#__PURE__*/function (_Error) {\n  _inherits(ZlibError, _Error);\n  function ZlibError(err) {\n    var _this;\n    _classCallCheck(this, ZlibError);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ZlibError).call(this, 'zlib: ' + err.message));\n    _this.code = err.code;\n    _this.errno = err.errno;\n    /* istanbul ignore if */\n    if (!_this.code) _this.code = 'ZLIB_ERROR';\n    _this.message = 'zlib: ' + err.message;\n    Error.captureStackTrace(_assertThisInitialized(_assertThisInitialized(_this)), _this.constructor);\n    return _this;\n  }\n  _createClass(ZlibError, [{\n    key: \"name\",\n    get: function get() {\n      return 'ZlibError';\n    }\n  }]);\n  return ZlibError;\n}(_wrapNativeSuper(Error)); // the Zlib class they all inherit from\n// This thing manages the queue of requests, and returns\n// true or false if there is anything in the queue when\n// you call the .write() method.\nvar _opts = Symbol('opts');\nvar _flushFlag = Symbol('flushFlag');\nvar _finishFlushFlag = Symbol('finishFlushFlag');\nvar _fullFlushFlag = Symbol('fullFlushFlag');\nvar _handle = Symbol('handle');\nvar _onError = Symbol('onError');\nvar _sawError = Symbol('sawError');\nvar _level = Symbol('level');\nvar _strategy = Symbol('strategy');\nvar _ended = Symbol('ended');\nvar _defaultFullFlush = Symbol('_defaultFullFlush');\nvar ZlibBase = /*#__PURE__*/function (_Minipass) {\n  _inherits(ZlibBase, _Minipass);\n  function ZlibBase(opts, mode) {\n    var _this2;\n    _classCallCheck(this, ZlibBase);\n    if (!opts || typeof opts !== 'object') throw new TypeError('invalid options for ZlibBase constructor');\n    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(ZlibBase).call(this, opts));\n    _this2[_sawError] = false;\n    _this2[_ended] = false;\n    _this2[_opts] = opts;\n    _this2[_flushFlag] = opts.flush;\n    _this2[_finishFlushFlag] = opts.finishFlush;\n    // this will throw if any options are invalid for the class selected\n    try {\n      _this2[_handle] = new realZlib[mode](opts);\n    } catch (er) {\n      // make sure that all errors get decorated properly\n      throw new ZlibError(er);\n    }\n    _this2[_onError] = function (err) {\n      // no sense raising multiple errors, since we abort on the first one.\n      if (_this2[_sawError]) return;\n      _this2[_sawError] = true;\n\n      // there is no way to cleanly recover.\n      // continuing only obscures problems.\n      _this2.close();\n      _this2.emit('error', err);\n    };\n    _this2[_handle].on('error', function (er) {\n      return _this2[_onError](new ZlibError(er));\n    });\n    _this2.once('end', function () {\n      return _this2.close;\n    });\n    return _this2;\n  }\n  _createClass(ZlibBase, [{\n    key: \"close\",\n    value: function close() {\n      if (this[_handle]) {\n        this[_handle].close();\n        this[_handle] = null;\n        this.emit('close');\n      }\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      if (!this[_sawError]) {\n        assert(this[_handle], 'zlib binding closed');\n        return this[_handle].reset();\n      }\n    }\n  }, {\n    key: \"flush\",\n    value: function flush(flushFlag) {\n      if (this.ended) return;\n      if (typeof flushFlag !== 'number') flushFlag = this[_fullFlushFlag];\n      this.write(Object.assign(Buffer.alloc(0), _defineProperty({}, _flushFlag, flushFlag)));\n    }\n  }, {\n    key: \"end\",\n    value: function end(chunk, encoding, cb) {\n      if (chunk) this.write(chunk, encoding);\n      this.flush(this[_finishFlushFlag]);\n      this[_ended] = true;\n      return _get(_getPrototypeOf(ZlibBase.prototype), \"end\", this).call(this, null, null, cb);\n    }\n  }, {\n    key: \"write\",\n    value: function write(chunk, encoding, cb) {\n      var _this3 = this;\n      // process the chunk using the sync process\n      // then super.write() all the outputted chunks\n      if (typeof encoding === 'function') cb = encoding, encoding = 'utf8';\n      if (typeof chunk === 'string') chunk = Buffer.from(chunk, encoding);\n      if (this[_sawError]) return;\n      assert(this[_handle], 'zlib binding closed');\n\n      // _processChunk tries to .close() the native handle after it's done, so we\n      // intercept that by temporarily making it a no-op.\n      var nativeHandle = this[_handle]._handle;\n      var originalNativeClose = nativeHandle.close;\n      nativeHandle.close = function () {};\n      var originalClose = this[_handle].close;\n      this[_handle].close = function () {};\n      // It also calls `Buffer.concat()` at the end, which may be convenient\n      // for some, but which we are not interested in as it slows us down.\n      Buffer.concat = function (args) {\n        return args;\n      };\n      var result;\n      try {\n        var flushFlag = typeof chunk[_flushFlag] === 'number' ? chunk[_flushFlag] : this[_flushFlag];\n        result = this[_handle]._processChunk(chunk, flushFlag);\n        // if we don't throw, reset it back how it was\n        Buffer.concat = OriginalBufferConcat;\n      } catch (err) {\n        // or if we do, put Buffer.concat() back before we emit error\n        // Error events call into user code, which may call Buffer.concat()\n        Buffer.concat = OriginalBufferConcat;\n        this[_onError](new ZlibError(err));\n      } finally {\n        if (this[_handle]) {\n          // Core zlib resets `_handle` to null after attempting to close the\n          // native handle. Our no-op handler prevented actual closure, but we\n          // need to restore the `._handle` property.\n          this[_handle]._handle = nativeHandle;\n          nativeHandle.close = originalNativeClose;\n          this[_handle].close = originalClose;\n          // `_processChunk()` adds an 'error' listener. If we don't remove it\n          // after each call, these handlers start piling up.\n          this[_handle].removeAllListeners('error');\n          // make sure OUR error listener is still attached tho\n        }\n      }\n\n      if (this[_handle]) this[_handle].on('error', function (er) {\n        return _this3[_onError](new ZlibError(er));\n      });\n      var writeReturn;\n      if (result) {\n        if (Array.isArray(result) && result.length > 0) {\n          // The first buffer is always `handle._outBuffer`, which would be\n          // re-used for later invocations; so, we always have to copy that one.\n          writeReturn = this[_superWrite](Buffer.from(result[0]));\n          for (var i = 1; i < result.length; i++) {\n            writeReturn = this[_superWrite](result[i]);\n          }\n        } else {\n          writeReturn = this[_superWrite](Buffer.from(result));\n        }\n      }\n      if (cb) cb();\n      return writeReturn;\n    }\n  }, {\n    key: _superWrite,\n    value: function value(data) {\n      return _get(_getPrototypeOf(ZlibBase.prototype), \"write\", this).call(this, data);\n    }\n  }, {\n    key: \"ended\",\n    get: function get() {\n      return this[_ended];\n    }\n  }]);\n  return ZlibBase;\n}(Minipass);\nvar Zlib = /*#__PURE__*/function (_ZlibBase) {\n  _inherits(Zlib, _ZlibBase);\n  function Zlib(opts, mode) {\n    var _this4;\n    _classCallCheck(this, Zlib);\n    opts = opts || {};\n    opts.flush = opts.flush || constants.Z_NO_FLUSH;\n    opts.finishFlush = opts.finishFlush || constants.Z_FINISH;\n    _this4 = _possibleConstructorReturn(this, _getPrototypeOf(Zlib).call(this, opts, mode));\n    _this4[_fullFlushFlag] = constants.Z_FULL_FLUSH;\n    _this4[_level] = opts.level;\n    _this4[_strategy] = opts.strategy;\n    return _this4;\n  }\n  _createClass(Zlib, [{\n    key: \"params\",\n    value: function params(level, strategy) {\n      var _this5 = this;\n      if (this[_sawError]) return;\n      if (!this[_handle]) throw new Error('cannot switch params when binding is closed');\n\n      // no way to test this without also not supporting params at all\n      /* istanbul ignore if */\n      if (!this[_handle].params) throw new Error('not supported in this implementation');\n      if (this[_level] !== level || this[_strategy] !== strategy) {\n        this.flush(constants.Z_SYNC_FLUSH);\n        assert(this[_handle], 'zlib binding closed');\n        // .params() calls .flush(), but the latter is always async in the\n        // core zlib. We override .flush() temporarily to intercept that and\n        // flush synchronously.\n        var origFlush = this[_handle].flush;\n        this[_handle].flush = function (flushFlag, cb) {\n          _this5.flush(flushFlag);\n          cb();\n        };\n        try {\n          this[_handle].params(level, strategy);\n        } finally {\n          this[_handle].flush = origFlush;\n        }\n        /* istanbul ignore else */\n        if (this[_handle]) {\n          this[_level] = level;\n          this[_strategy] = strategy;\n        }\n      }\n    }\n  }]);\n  return Zlib;\n}(ZlibBase); // minimal 2-byte header\nvar Deflate = /*#__PURE__*/function (_Zlib) {\n  _inherits(Deflate, _Zlib);\n  function Deflate(opts) {\n    _classCallCheck(this, Deflate);\n    return _possibleConstructorReturn(this, _getPrototypeOf(Deflate).call(this, opts, 'Deflate'));\n  }\n  return Deflate;\n}(Zlib);\nvar Inflate = /*#__PURE__*/function (_Zlib2) {\n  _inherits(Inflate, _Zlib2);\n  function Inflate(opts) {\n    _classCallCheck(this, Inflate);\n    return _possibleConstructorReturn(this, _getPrototypeOf(Inflate).call(this, opts, 'Inflate'));\n  }\n  return Inflate;\n}(Zlib); // gzip - bigger header, same deflate compression\nvar _portable = Symbol('_portable');\nvar Gzip = /*#__PURE__*/function (_Zlib3) {\n  _inherits(Gzip, _Zlib3);\n  function Gzip(opts) {\n    var _this6;\n    _classCallCheck(this, Gzip);\n    _this6 = _possibleConstructorReturn(this, _getPrototypeOf(Gzip).call(this, opts, 'Gzip'));\n    _this6[_portable] = opts && !!opts.portable;\n    return _this6;\n  }\n  _createClass(Gzip, [{\n    key: _superWrite,\n    value: function value(data) {\n      if (!this[_portable]) return _get(_getPrototypeOf(Gzip.prototype), _superWrite, this).call(this, data);\n\n      // we'll always get the header emitted in one first chunk\n      // overwrite the OS indicator byte with 0xFF\n      this[_portable] = false;\n      data[9] = 255;\n      return _get(_getPrototypeOf(Gzip.prototype), _superWrite, this).call(this, data);\n    }\n  }]);\n  return Gzip;\n}(Zlib);\nvar Gunzip = /*#__PURE__*/function (_Zlib4) {\n  _inherits(Gunzip, _Zlib4);\n  function Gunzip(opts) {\n    _classCallCheck(this, Gunzip);\n    return _possibleConstructorReturn(this, _getPrototypeOf(Gunzip).call(this, opts, 'Gunzip'));\n  }\n  return Gunzip;\n}(Zlib); // raw - no header\nvar DeflateRaw = /*#__PURE__*/function (_Zlib5) {\n  _inherits(DeflateRaw, _Zlib5);\n  function DeflateRaw(opts) {\n    _classCallCheck(this, DeflateRaw);\n    return _possibleConstructorReturn(this, _getPrototypeOf(DeflateRaw).call(this, opts, 'DeflateRaw'));\n  }\n  return DeflateRaw;\n}(Zlib);\nvar InflateRaw = /*#__PURE__*/function (_Zlib6) {\n  _inherits(InflateRaw, _Zlib6);\n  function InflateRaw(opts) {\n    _classCallCheck(this, InflateRaw);\n    return _possibleConstructorReturn(this, _getPrototypeOf(InflateRaw).call(this, opts, 'InflateRaw'));\n  }\n  return InflateRaw;\n}(Zlib); // auto-detect header.\nvar Unzip = /*#__PURE__*/function (_Zlib7) {\n  _inherits(Unzip, _Zlib7);\n  function Unzip(opts) {\n    _classCallCheck(this, Unzip);\n    return _possibleConstructorReturn(this, _getPrototypeOf(Unzip).call(this, opts, 'Unzip'));\n  }\n  return Unzip;\n}(Zlib);\nvar Brotli = /*#__PURE__*/function (_ZlibBase2) {\n  _inherits(Brotli, _ZlibBase2);\n  function Brotli(opts, mode) {\n    var _this7;\n    _classCallCheck(this, Brotli);\n    opts = opts || {};\n    opts.flush = opts.flush || constants.BROTLI_OPERATION_PROCESS;\n    opts.finishFlush = opts.finishFlush || constants.BROTLI_OPERATION_FINISH;\n    _this7 = _possibleConstructorReturn(this, _getPrototypeOf(Brotli).call(this, opts, mode));\n    _this7[_fullFlushFlag] = constants.BROTLI_OPERATION_FLUSH;\n    return _this7;\n  }\n  return Brotli;\n}(ZlibBase);\nvar BrotliCompress = /*#__PURE__*/function (_Brotli) {\n  _inherits(BrotliCompress, _Brotli);\n  function BrotliCompress(opts) {\n    _classCallCheck(this, BrotliCompress);\n    return _possibleConstructorReturn(this, _getPrototypeOf(BrotliCompress).call(this, opts, 'BrotliCompress'));\n  }\n  return BrotliCompress;\n}(Brotli);\nvar BrotliDecompress = /*#__PURE__*/function (_Brotli2) {\n  _inherits(BrotliDecompress, _Brotli2);\n  function BrotliDecompress(opts) {\n    _classCallCheck(this, BrotliDecompress);\n    return _possibleConstructorReturn(this, _getPrototypeOf(BrotliDecompress).call(this, opts, 'BrotliDecompress'));\n  }\n  return BrotliDecompress;\n}(Brotli);\nexports.Deflate = Deflate;\nexports.Inflate = Inflate;\nexports.Gzip = Gzip;\nexports.Gunzip = Gunzip;\nexports.DeflateRaw = DeflateRaw;\nexports.InflateRaw = InflateRaw;\nexports.Unzip = Unzip;\n/* istanbul ignore else */\nif (typeof realZlib.BrotliCompress === 'function') {\n  exports.BrotliCompress = BrotliCompress;\n  exports.BrotliDecompress = BrotliDecompress;\n} else {\n  exports.BrotliCompress = exports.BrotliDecompress = /*#__PURE__*/function () {\n    function _class() {\n      _classCallCheck(this, _class);\n      throw new Error('Brotli is not supported in this version of Node.js');\n    }\n    return _class;\n  }();\n}","map":null,"metadata":{},"sourceType":"script"}