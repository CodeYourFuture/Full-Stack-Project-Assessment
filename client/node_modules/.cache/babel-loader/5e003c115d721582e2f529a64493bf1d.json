{"ast":null,"code":"'use strict';\n\nvar Buffer = require('buffer').Buffer;\nvar Transform = require('stream').Transform;\nvar binding = require('./binding');\nvar util = require('util');\nvar assert = require('assert').ok;\nvar kMaxLength = require('buffer').kMaxLength;\nvar kRangeErrorMessage = 'Cannot create final Buffer. It would be larger ' + 'than 0x' + kMaxLength.toString(16) + ' bytes';\n\n// zlib doesn't provide these, so kludge them in following the same\n// const naming scheme zlib uses.\nbinding.Z_MIN_WINDOWBITS = 8;\nbinding.Z_MAX_WINDOWBITS = 15;\nbinding.Z_DEFAULT_WINDOWBITS = 15;\n\n// fewer than 64 bytes per chunk is stupid.\n// technically it could work with as few as 8, but even 64 bytes\n// is absurdly low.  Usually a MB or more is best.\nbinding.Z_MIN_CHUNK = 64;\nbinding.Z_MAX_CHUNK = Infinity;\nbinding.Z_DEFAULT_CHUNK = 16 * 1024;\nbinding.Z_MIN_MEMLEVEL = 1;\nbinding.Z_MAX_MEMLEVEL = 9;\nbinding.Z_DEFAULT_MEMLEVEL = 8;\nbinding.Z_MIN_LEVEL = -1;\nbinding.Z_MAX_LEVEL = 9;\nbinding.Z_DEFAULT_LEVEL = binding.Z_DEFAULT_COMPRESSION;\n\n// expose all the zlib constants\nvar bkeys = Object.keys(binding);\nfor (var bk = 0; bk < bkeys.length; bk++) {\n  var bkey = bkeys[bk];\n  if (bkey.match(/^Z/)) {\n    Object.defineProperty(exports, bkey, {\n      enumerable: true,\n      value: binding[bkey],\n      writable: false\n    });\n  }\n}\n\n// translation table for return codes.\nvar codes = {\n  Z_OK: binding.Z_OK,\n  Z_STREAM_END: binding.Z_STREAM_END,\n  Z_NEED_DICT: binding.Z_NEED_DICT,\n  Z_ERRNO: binding.Z_ERRNO,\n  Z_STREAM_ERROR: binding.Z_STREAM_ERROR,\n  Z_DATA_ERROR: binding.Z_DATA_ERROR,\n  Z_MEM_ERROR: binding.Z_MEM_ERROR,\n  Z_BUF_ERROR: binding.Z_BUF_ERROR,\n  Z_VERSION_ERROR: binding.Z_VERSION_ERROR\n};\nvar ckeys = Object.keys(codes);\nfor (var ck = 0; ck < ckeys.length; ck++) {\n  var ckey = ckeys[ck];\n  codes[codes[ckey]] = ckey;\n}\nObject.defineProperty(exports, 'codes', {\n  enumerable: true,\n  value: Object.freeze(codes),\n  writable: false\n});\nexports.Deflate = Deflate;\nexports.Inflate = Inflate;\nexports.Gzip = Gzip;\nexports.Gunzip = Gunzip;\nexports.DeflateRaw = DeflateRaw;\nexports.InflateRaw = InflateRaw;\nexports.Unzip = Unzip;\nexports.createDeflate = function (o) {\n  return new Deflate(o);\n};\nexports.createInflate = function (o) {\n  return new Inflate(o);\n};\nexports.createDeflateRaw = function (o) {\n  return new DeflateRaw(o);\n};\nexports.createInflateRaw = function (o) {\n  return new InflateRaw(o);\n};\nexports.createGzip = function (o) {\n  return new Gzip(o);\n};\nexports.createGunzip = function (o) {\n  return new Gunzip(o);\n};\nexports.createUnzip = function (o) {\n  return new Unzip(o);\n};\n\n// Convenience methods.\n// compress/decompress a string or buffer in one step.\nexports.deflate = function (buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  return zlibBuffer(new Deflate(opts), buffer, callback);\n};\nexports.deflateSync = function (buffer, opts) {\n  return zlibBufferSync(new Deflate(opts), buffer);\n};\nexports.gzip = function (buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  return zlibBuffer(new Gzip(opts), buffer, callback);\n};\nexports.gzipSync = function (buffer, opts) {\n  return zlibBufferSync(new Gzip(opts), buffer);\n};\nexports.deflateRaw = function (buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  return zlibBuffer(new DeflateRaw(opts), buffer, callback);\n};\nexports.deflateRawSync = function (buffer, opts) {\n  return zlibBufferSync(new DeflateRaw(opts), buffer);\n};\nexports.unzip = function (buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  return zlibBuffer(new Unzip(opts), buffer, callback);\n};\nexports.unzipSync = function (buffer, opts) {\n  return zlibBufferSync(new Unzip(opts), buffer);\n};\nexports.inflate = function (buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  return zlibBuffer(new Inflate(opts), buffer, callback);\n};\nexports.inflateSync = function (buffer, opts) {\n  return zlibBufferSync(new Inflate(opts), buffer);\n};\nexports.gunzip = function (buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  return zlibBuffer(new Gunzip(opts), buffer, callback);\n};\nexports.gunzipSync = function (buffer, opts) {\n  return zlibBufferSync(new Gunzip(opts), buffer);\n};\nexports.inflateRaw = function (buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  return zlibBuffer(new InflateRaw(opts), buffer, callback);\n};\nexports.inflateRawSync = function (buffer, opts) {\n  return zlibBufferSync(new InflateRaw(opts), buffer);\n};\nfunction zlibBuffer(engine, buffer, callback) {\n  var buffers = [];\n  var nread = 0;\n  engine.on('error', onError);\n  engine.on('end', onEnd);\n  engine.end(buffer);\n  flow();\n  function flow() {\n    var chunk;\n    while (null !== (chunk = engine.read())) {\n      buffers.push(chunk);\n      nread += chunk.length;\n    }\n    engine.once('readable', flow);\n  }\n  function onError(err) {\n    engine.removeListener('end', onEnd);\n    engine.removeListener('readable', flow);\n    callback(err);\n  }\n  function onEnd() {\n    var buf;\n    var err = null;\n    if (nread >= kMaxLength) {\n      err = new RangeError(kRangeErrorMessage);\n    } else {\n      buf = Buffer.concat(buffers, nread);\n    }\n    buffers = [];\n    engine.close();\n    callback(err, buf);\n  }\n}\nfunction zlibBufferSync(engine, buffer) {\n  if (typeof buffer === 'string') buffer = Buffer.from(buffer);\n  if (!Buffer.isBuffer(buffer)) throw new TypeError('Not a string or buffer');\n  var flushFlag = engine._finishFlushFlag;\n  return engine._processChunk(buffer, flushFlag);\n}\n\n// generic zlib\n// minimal 2-byte header\nfunction Deflate(opts) {\n  if (!(this instanceof Deflate)) return new Deflate(opts);\n  Zlib.call(this, opts, binding.DEFLATE);\n}\nfunction Inflate(opts) {\n  if (!(this instanceof Inflate)) return new Inflate(opts);\n  Zlib.call(this, opts, binding.INFLATE);\n}\n\n// gzip - bigger header, same deflate compression\nfunction Gzip(opts) {\n  if (!(this instanceof Gzip)) return new Gzip(opts);\n  Zlib.call(this, opts, binding.GZIP);\n}\nfunction Gunzip(opts) {\n  if (!(this instanceof Gunzip)) return new Gunzip(opts);\n  Zlib.call(this, opts, binding.GUNZIP);\n}\n\n// raw - no header\nfunction DeflateRaw(opts) {\n  if (!(this instanceof DeflateRaw)) return new DeflateRaw(opts);\n  Zlib.call(this, opts, binding.DEFLATERAW);\n}\nfunction InflateRaw(opts) {\n  if (!(this instanceof InflateRaw)) return new InflateRaw(opts);\n  Zlib.call(this, opts, binding.INFLATERAW);\n}\n\n// auto-detect header.\nfunction Unzip(opts) {\n  if (!(this instanceof Unzip)) return new Unzip(opts);\n  Zlib.call(this, opts, binding.UNZIP);\n}\nfunction isValidFlushFlag(flag) {\n  return flag === binding.Z_NO_FLUSH || flag === binding.Z_PARTIAL_FLUSH || flag === binding.Z_SYNC_FLUSH || flag === binding.Z_FULL_FLUSH || flag === binding.Z_FINISH || flag === binding.Z_BLOCK;\n}\n\n// the Zlib class they all inherit from\n// This thing manages the queue of requests, and returns\n// true or false if there is anything in the queue when\n// you call the .write() method.\n\nfunction Zlib(opts, mode) {\n  var _this = this;\n  this._opts = opts = opts || {};\n  this._chunkSize = opts.chunkSize || exports.Z_DEFAULT_CHUNK;\n  Transform.call(this, opts);\n  if (opts.flush && !isValidFlushFlag(opts.flush)) {\n    throw new Error('Invalid flush flag: ' + opts.flush);\n  }\n  if (opts.finishFlush && !isValidFlushFlag(opts.finishFlush)) {\n    throw new Error('Invalid flush flag: ' + opts.finishFlush);\n  }\n  this._flushFlag = opts.flush || binding.Z_NO_FLUSH;\n  this._finishFlushFlag = typeof opts.finishFlush !== 'undefined' ? opts.finishFlush : binding.Z_FINISH;\n  if (opts.chunkSize) {\n    if (opts.chunkSize < exports.Z_MIN_CHUNK || opts.chunkSize > exports.Z_MAX_CHUNK) {\n      throw new Error('Invalid chunk size: ' + opts.chunkSize);\n    }\n  }\n  if (opts.windowBits) {\n    if (opts.windowBits < exports.Z_MIN_WINDOWBITS || opts.windowBits > exports.Z_MAX_WINDOWBITS) {\n      throw new Error('Invalid windowBits: ' + opts.windowBits);\n    }\n  }\n  if (opts.level) {\n    if (opts.level < exports.Z_MIN_LEVEL || opts.level > exports.Z_MAX_LEVEL) {\n      throw new Error('Invalid compression level: ' + opts.level);\n    }\n  }\n  if (opts.memLevel) {\n    if (opts.memLevel < exports.Z_MIN_MEMLEVEL || opts.memLevel > exports.Z_MAX_MEMLEVEL) {\n      throw new Error('Invalid memLevel: ' + opts.memLevel);\n    }\n  }\n  if (opts.strategy) {\n    if (opts.strategy != exports.Z_FILTERED && opts.strategy != exports.Z_HUFFMAN_ONLY && opts.strategy != exports.Z_RLE && opts.strategy != exports.Z_FIXED && opts.strategy != exports.Z_DEFAULT_STRATEGY) {\n      throw new Error('Invalid strategy: ' + opts.strategy);\n    }\n  }\n  if (opts.dictionary) {\n    if (!Buffer.isBuffer(opts.dictionary)) {\n      throw new Error('Invalid dictionary: it should be a Buffer instance');\n    }\n  }\n  this._handle = new binding.Zlib(mode);\n  var self = this;\n  this._hadError = false;\n  this._handle.onerror = function (message, errno) {\n    // there is no way to cleanly recover.\n    // continuing only obscures problems.\n    _close(self);\n    self._hadError = true;\n    var error = new Error(message);\n    error.errno = errno;\n    error.code = exports.codes[errno];\n    self.emit('error', error);\n  };\n  var level = exports.Z_DEFAULT_COMPRESSION;\n  if (typeof opts.level === 'number') level = opts.level;\n  var strategy = exports.Z_DEFAULT_STRATEGY;\n  if (typeof opts.strategy === 'number') strategy = opts.strategy;\n  this._handle.init(opts.windowBits || exports.Z_DEFAULT_WINDOWBITS, level, opts.memLevel || exports.Z_DEFAULT_MEMLEVEL, strategy, opts.dictionary);\n  this._buffer = Buffer.allocUnsafe(this._chunkSize);\n  this._offset = 0;\n  this._level = level;\n  this._strategy = strategy;\n  this.once('end', this.close);\n  Object.defineProperty(this, '_closed', {\n    get: function () {\n      return !_this._handle;\n    },\n    configurable: true,\n    enumerable: true\n  });\n}\nutil.inherits(Zlib, Transform);\nZlib.prototype.params = function (level, strategy, callback) {\n  if (level < exports.Z_MIN_LEVEL || level > exports.Z_MAX_LEVEL) {\n    throw new RangeError('Invalid compression level: ' + level);\n  }\n  if (strategy != exports.Z_FILTERED && strategy != exports.Z_HUFFMAN_ONLY && strategy != exports.Z_RLE && strategy != exports.Z_FIXED && strategy != exports.Z_DEFAULT_STRATEGY) {\n    throw new TypeError('Invalid strategy: ' + strategy);\n  }\n  if (this._level !== level || this._strategy !== strategy) {\n    var self = this;\n    this.flush(binding.Z_SYNC_FLUSH, function () {\n      assert(self._handle, 'zlib binding closed');\n      self._handle.params(level, strategy);\n      if (!self._hadError) {\n        self._level = level;\n        self._strategy = strategy;\n        if (callback) callback();\n      }\n    });\n  } else {\n    process.nextTick(callback);\n  }\n};\nZlib.prototype.reset = function () {\n  assert(this._handle, 'zlib binding closed');\n  return this._handle.reset();\n};\n\n// This is the _flush function called by the transform class,\n// internally, when the last chunk has been written.\nZlib.prototype._flush = function (callback) {\n  this._transform(Buffer.alloc(0), '', callback);\n};\nZlib.prototype.flush = function (kind, callback) {\n  var _this2 = this;\n  var ws = this._writableState;\n  if (typeof kind === 'function' || kind === undefined && !callback) {\n    callback = kind;\n    kind = binding.Z_FULL_FLUSH;\n  }\n  if (ws.ended) {\n    if (callback) process.nextTick(callback);\n  } else if (ws.ending) {\n    if (callback) this.once('end', callback);\n  } else if (ws.needDrain) {\n    if (callback) {\n      this.once('drain', function () {\n        return _this2.flush(kind, callback);\n      });\n    }\n  } else {\n    this._flushFlag = kind;\n    this.write(Buffer.alloc(0), '', callback);\n  }\n};\nZlib.prototype.close = function (callback) {\n  _close(this, callback);\n  process.nextTick(emitCloseNT, this);\n};\nfunction _close(engine, callback) {\n  if (callback) process.nextTick(callback);\n\n  // Caller may invoke .close after a zlib error (which will null _handle).\n  if (!engine._handle) return;\n  engine._handle.close();\n  engine._handle = null;\n}\nfunction emitCloseNT(self) {\n  self.emit('close');\n}\nZlib.prototype._transform = function (chunk, encoding, cb) {\n  var flushFlag;\n  var ws = this._writableState;\n  var ending = ws.ending || ws.ended;\n  var last = ending && (!chunk || ws.length === chunk.length);\n  if (chunk !== null && !Buffer.isBuffer(chunk)) return cb(new Error('invalid input'));\n  if (!this._handle) return cb(new Error('zlib binding closed'));\n\n  // If it's the last chunk, or a final flush, we use the Z_FINISH flush flag\n  // (or whatever flag was provided using opts.finishFlush).\n  // If it's explicitly flushing at some other time, then we use\n  // Z_FULL_FLUSH. Otherwise, use Z_NO_FLUSH for maximum compression\n  // goodness.\n  if (last) flushFlag = this._finishFlushFlag;else {\n    flushFlag = this._flushFlag;\n    // once we've flushed the last of the queue, stop flushing and\n    // go back to the normal behavior.\n    if (chunk.length >= ws.length) {\n      this._flushFlag = this._opts.flush || binding.Z_NO_FLUSH;\n    }\n  }\n  this._processChunk(chunk, flushFlag, cb);\n};\nZlib.prototype._processChunk = function (chunk, flushFlag, cb) {\n  var availInBefore = chunk && chunk.length;\n  var availOutBefore = this._chunkSize - this._offset;\n  var inOff = 0;\n  var self = this;\n  var async = typeof cb === 'function';\n  if (!async) {\n    var buffers = [];\n    var nread = 0;\n    var error;\n    this.on('error', function (er) {\n      error = er;\n    });\n    assert(this._handle, 'zlib binding closed');\n    do {\n      var res = this._handle.writeSync(flushFlag, chunk,\n      // in\n      inOff,\n      // in_off\n      availInBefore,\n      // in_len\n      this._buffer,\n      // out\n      this._offset,\n      //out_off\n      availOutBefore); // out_len\n    } while (!this._hadError && callback(res[0], res[1]));\n    if (this._hadError) {\n      throw error;\n    }\n    if (nread >= kMaxLength) {\n      _close(this);\n      throw new RangeError(kRangeErrorMessage);\n    }\n    var buf = Buffer.concat(buffers, nread);\n    _close(this);\n    return buf;\n  }\n  assert(this._handle, 'zlib binding closed');\n  var req = this._handle.write(flushFlag, chunk,\n  // in\n  inOff,\n  // in_off\n  availInBefore,\n  // in_len\n  this._buffer,\n  // out\n  this._offset,\n  //out_off\n  availOutBefore); // out_len\n\n  req.buffer = chunk;\n  req.callback = callback;\n  function callback(availInAfter, availOutAfter) {\n    // When the callback is used in an async write, the callback's\n    // context is the `req` object that was created. The req object\n    // is === this._handle, and that's why it's important to null\n    // out the values after they are done being used. `this._handle`\n    // can stay in memory longer than the callback and buffer are needed.\n    if (this) {\n      this.buffer = null;\n      this.callback = null;\n    }\n    if (self._hadError) return;\n    var have = availOutBefore - availOutAfter;\n    assert(have >= 0, 'have should not go down');\n    if (have > 0) {\n      var out = self._buffer.slice(self._offset, self._offset + have);\n      self._offset += have;\n      // serve some output to the consumer.\n      if (async) {\n        self.push(out);\n      } else {\n        buffers.push(out);\n        nread += out.length;\n      }\n    }\n\n    // exhausted the output buffer, or used all the input create a new one.\n    if (availOutAfter === 0 || self._offset >= self._chunkSize) {\n      availOutBefore = self._chunkSize;\n      self._offset = 0;\n      self._buffer = Buffer.allocUnsafe(self._chunkSize);\n    }\n    if (availOutAfter === 0) {\n      // Not actually done.  Need to reprocess.\n      // Also, update the availInBefore to the availInAfter value,\n      // so that if we have to hit it a third (fourth, etc.) time,\n      // it'll have the correct byte counts.\n      inOff += availInBefore - availInAfter;\n      availInBefore = availInAfter;\n      if (!async) return true;\n      var newReq = self._handle.write(flushFlag, chunk, inOff, availInBefore, self._buffer, self._offset, self._chunkSize);\n      newReq.callback = callback; // this same function\n      newReq.buffer = chunk;\n      return;\n    }\n    if (!async) return false;\n\n    // finished with the chunk.\n    cb();\n  }\n};\nutil.inherits(Deflate, Zlib);\nutil.inherits(Inflate, Zlib);\nutil.inherits(Gzip, Zlib);\nutil.inherits(Gunzip, Zlib);\nutil.inherits(DeflateRaw, Zlib);\nutil.inherits(InflateRaw, Zlib);\nutil.inherits(Unzip, Zlib);","map":{"version":3,"names":["Buffer","require","Transform","binding","util","assert","ok","kMaxLength","kRangeErrorMessage","toString","Z_MIN_WINDOWBITS","Z_MAX_WINDOWBITS","Z_DEFAULT_WINDOWBITS","Z_MIN_CHUNK","Z_MAX_CHUNK","Infinity","Z_DEFAULT_CHUNK","Z_MIN_MEMLEVEL","Z_MAX_MEMLEVEL","Z_DEFAULT_MEMLEVEL","Z_MIN_LEVEL","Z_MAX_LEVEL","Z_DEFAULT_LEVEL","Z_DEFAULT_COMPRESSION","bkeys","Object","keys","bk","length","bkey","match","defineProperty","exports","enumerable","value","writable","codes","Z_OK","Z_STREAM_END","Z_NEED_DICT","Z_ERRNO","Z_STREAM_ERROR","Z_DATA_ERROR","Z_MEM_ERROR","Z_BUF_ERROR","Z_VERSION_ERROR","ckeys","ck","ckey","freeze","Deflate","Inflate","Gzip","Gunzip","DeflateRaw","InflateRaw","Unzip","createDeflate","o","createInflate","createDeflateRaw","createInflateRaw","createGzip","createGunzip","createUnzip","deflate","buffer","opts","callback","zlibBuffer","deflateSync","zlibBufferSync","gzip","gzipSync","deflateRaw","deflateRawSync","unzip","unzipSync","inflate","inflateSync","gunzip","gunzipSync","inflateRaw","inflateRawSync","engine","buffers","nread","on","onError","onEnd","end","flow","chunk","read","push","once","err","removeListener","buf","RangeError","concat","close","from","isBuffer","TypeError","flushFlag","_finishFlushFlag","_processChunk","Zlib","call","DEFLATE","INFLATE","GZIP","GUNZIP","DEFLATERAW","INFLATERAW","UNZIP","isValidFlushFlag","flag","Z_NO_FLUSH","Z_PARTIAL_FLUSH","Z_SYNC_FLUSH","Z_FULL_FLUSH","Z_FINISH","Z_BLOCK","mode","_this","_opts","_chunkSize","chunkSize","flush","Error","finishFlush","_flushFlag","windowBits","level","memLevel","strategy","Z_FILTERED","Z_HUFFMAN_ONLY","Z_RLE","Z_FIXED","Z_DEFAULT_STRATEGY","dictionary","_handle","self","_hadError","onerror","message","errno","_close","error","code","emit","init","_buffer","allocUnsafe","_offset","_level","_strategy","get","configurable","inherits","prototype","params","process","nextTick","reset","_flush","_transform","alloc","kind","_this2","ws","_writableState","undefined","ended","ending","needDrain","write","emitCloseNT","encoding","cb","last","availInBefore","availOutBefore","inOff","async","er","res","writeSync","req","availInAfter","availOutAfter","have","out","slice","newReq"],"sources":["/Users/admin/Desktop/Newsletter-Signup/Full-Stack-Project-Assessment/client/node_modules/browserify-zlib/lib/index.js"],"sourcesContent":["'use strict';\n\nvar Buffer = require('buffer').Buffer;\nvar Transform = require('stream').Transform;\nvar binding = require('./binding');\nvar util = require('util');\nvar assert = require('assert').ok;\nvar kMaxLength = require('buffer').kMaxLength;\nvar kRangeErrorMessage = 'Cannot create final Buffer. It would be larger ' + 'than 0x' + kMaxLength.toString(16) + ' bytes';\n\n// zlib doesn't provide these, so kludge them in following the same\n// const naming scheme zlib uses.\nbinding.Z_MIN_WINDOWBITS = 8;\nbinding.Z_MAX_WINDOWBITS = 15;\nbinding.Z_DEFAULT_WINDOWBITS = 15;\n\n// fewer than 64 bytes per chunk is stupid.\n// technically it could work with as few as 8, but even 64 bytes\n// is absurdly low.  Usually a MB or more is best.\nbinding.Z_MIN_CHUNK = 64;\nbinding.Z_MAX_CHUNK = Infinity;\nbinding.Z_DEFAULT_CHUNK = 16 * 1024;\n\nbinding.Z_MIN_MEMLEVEL = 1;\nbinding.Z_MAX_MEMLEVEL = 9;\nbinding.Z_DEFAULT_MEMLEVEL = 8;\n\nbinding.Z_MIN_LEVEL = -1;\nbinding.Z_MAX_LEVEL = 9;\nbinding.Z_DEFAULT_LEVEL = binding.Z_DEFAULT_COMPRESSION;\n\n// expose all the zlib constants\nvar bkeys = Object.keys(binding);\nfor (var bk = 0; bk < bkeys.length; bk++) {\n  var bkey = bkeys[bk];\n  if (bkey.match(/^Z/)) {\n    Object.defineProperty(exports, bkey, {\n      enumerable: true, value: binding[bkey], writable: false\n    });\n  }\n}\n\n// translation table for return codes.\nvar codes = {\n  Z_OK: binding.Z_OK,\n  Z_STREAM_END: binding.Z_STREAM_END,\n  Z_NEED_DICT: binding.Z_NEED_DICT,\n  Z_ERRNO: binding.Z_ERRNO,\n  Z_STREAM_ERROR: binding.Z_STREAM_ERROR,\n  Z_DATA_ERROR: binding.Z_DATA_ERROR,\n  Z_MEM_ERROR: binding.Z_MEM_ERROR,\n  Z_BUF_ERROR: binding.Z_BUF_ERROR,\n  Z_VERSION_ERROR: binding.Z_VERSION_ERROR\n};\n\nvar ckeys = Object.keys(codes);\nfor (var ck = 0; ck < ckeys.length; ck++) {\n  var ckey = ckeys[ck];\n  codes[codes[ckey]] = ckey;\n}\n\nObject.defineProperty(exports, 'codes', {\n  enumerable: true, value: Object.freeze(codes), writable: false\n});\n\nexports.Deflate = Deflate;\nexports.Inflate = Inflate;\nexports.Gzip = Gzip;\nexports.Gunzip = Gunzip;\nexports.DeflateRaw = DeflateRaw;\nexports.InflateRaw = InflateRaw;\nexports.Unzip = Unzip;\n\nexports.createDeflate = function (o) {\n  return new Deflate(o);\n};\n\nexports.createInflate = function (o) {\n  return new Inflate(o);\n};\n\nexports.createDeflateRaw = function (o) {\n  return new DeflateRaw(o);\n};\n\nexports.createInflateRaw = function (o) {\n  return new InflateRaw(o);\n};\n\nexports.createGzip = function (o) {\n  return new Gzip(o);\n};\n\nexports.createGunzip = function (o) {\n  return new Gunzip(o);\n};\n\nexports.createUnzip = function (o) {\n  return new Unzip(o);\n};\n\n// Convenience methods.\n// compress/decompress a string or buffer in one step.\nexports.deflate = function (buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  return zlibBuffer(new Deflate(opts), buffer, callback);\n};\n\nexports.deflateSync = function (buffer, opts) {\n  return zlibBufferSync(new Deflate(opts), buffer);\n};\n\nexports.gzip = function (buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  return zlibBuffer(new Gzip(opts), buffer, callback);\n};\n\nexports.gzipSync = function (buffer, opts) {\n  return zlibBufferSync(new Gzip(opts), buffer);\n};\n\nexports.deflateRaw = function (buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  return zlibBuffer(new DeflateRaw(opts), buffer, callback);\n};\n\nexports.deflateRawSync = function (buffer, opts) {\n  return zlibBufferSync(new DeflateRaw(opts), buffer);\n};\n\nexports.unzip = function (buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  return zlibBuffer(new Unzip(opts), buffer, callback);\n};\n\nexports.unzipSync = function (buffer, opts) {\n  return zlibBufferSync(new Unzip(opts), buffer);\n};\n\nexports.inflate = function (buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  return zlibBuffer(new Inflate(opts), buffer, callback);\n};\n\nexports.inflateSync = function (buffer, opts) {\n  return zlibBufferSync(new Inflate(opts), buffer);\n};\n\nexports.gunzip = function (buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  return zlibBuffer(new Gunzip(opts), buffer, callback);\n};\n\nexports.gunzipSync = function (buffer, opts) {\n  return zlibBufferSync(new Gunzip(opts), buffer);\n};\n\nexports.inflateRaw = function (buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  return zlibBuffer(new InflateRaw(opts), buffer, callback);\n};\n\nexports.inflateRawSync = function (buffer, opts) {\n  return zlibBufferSync(new InflateRaw(opts), buffer);\n};\n\nfunction zlibBuffer(engine, buffer, callback) {\n  var buffers = [];\n  var nread = 0;\n\n  engine.on('error', onError);\n  engine.on('end', onEnd);\n\n  engine.end(buffer);\n  flow();\n\n  function flow() {\n    var chunk;\n    while (null !== (chunk = engine.read())) {\n      buffers.push(chunk);\n      nread += chunk.length;\n    }\n    engine.once('readable', flow);\n  }\n\n  function onError(err) {\n    engine.removeListener('end', onEnd);\n    engine.removeListener('readable', flow);\n    callback(err);\n  }\n\n  function onEnd() {\n    var buf;\n    var err = null;\n\n    if (nread >= kMaxLength) {\n      err = new RangeError(kRangeErrorMessage);\n    } else {\n      buf = Buffer.concat(buffers, nread);\n    }\n\n    buffers = [];\n    engine.close();\n    callback(err, buf);\n  }\n}\n\nfunction zlibBufferSync(engine, buffer) {\n  if (typeof buffer === 'string') buffer = Buffer.from(buffer);\n\n  if (!Buffer.isBuffer(buffer)) throw new TypeError('Not a string or buffer');\n\n  var flushFlag = engine._finishFlushFlag;\n\n  return engine._processChunk(buffer, flushFlag);\n}\n\n// generic zlib\n// minimal 2-byte header\nfunction Deflate(opts) {\n  if (!(this instanceof Deflate)) return new Deflate(opts);\n  Zlib.call(this, opts, binding.DEFLATE);\n}\n\nfunction Inflate(opts) {\n  if (!(this instanceof Inflate)) return new Inflate(opts);\n  Zlib.call(this, opts, binding.INFLATE);\n}\n\n// gzip - bigger header, same deflate compression\nfunction Gzip(opts) {\n  if (!(this instanceof Gzip)) return new Gzip(opts);\n  Zlib.call(this, opts, binding.GZIP);\n}\n\nfunction Gunzip(opts) {\n  if (!(this instanceof Gunzip)) return new Gunzip(opts);\n  Zlib.call(this, opts, binding.GUNZIP);\n}\n\n// raw - no header\nfunction DeflateRaw(opts) {\n  if (!(this instanceof DeflateRaw)) return new DeflateRaw(opts);\n  Zlib.call(this, opts, binding.DEFLATERAW);\n}\n\nfunction InflateRaw(opts) {\n  if (!(this instanceof InflateRaw)) return new InflateRaw(opts);\n  Zlib.call(this, opts, binding.INFLATERAW);\n}\n\n// auto-detect header.\nfunction Unzip(opts) {\n  if (!(this instanceof Unzip)) return new Unzip(opts);\n  Zlib.call(this, opts, binding.UNZIP);\n}\n\nfunction isValidFlushFlag(flag) {\n  return flag === binding.Z_NO_FLUSH || flag === binding.Z_PARTIAL_FLUSH || flag === binding.Z_SYNC_FLUSH || flag === binding.Z_FULL_FLUSH || flag === binding.Z_FINISH || flag === binding.Z_BLOCK;\n}\n\n// the Zlib class they all inherit from\n// This thing manages the queue of requests, and returns\n// true or false if there is anything in the queue when\n// you call the .write() method.\n\nfunction Zlib(opts, mode) {\n  var _this = this;\n\n  this._opts = opts = opts || {};\n  this._chunkSize = opts.chunkSize || exports.Z_DEFAULT_CHUNK;\n\n  Transform.call(this, opts);\n\n  if (opts.flush && !isValidFlushFlag(opts.flush)) {\n    throw new Error('Invalid flush flag: ' + opts.flush);\n  }\n  if (opts.finishFlush && !isValidFlushFlag(opts.finishFlush)) {\n    throw new Error('Invalid flush flag: ' + opts.finishFlush);\n  }\n\n  this._flushFlag = opts.flush || binding.Z_NO_FLUSH;\n  this._finishFlushFlag = typeof opts.finishFlush !== 'undefined' ? opts.finishFlush : binding.Z_FINISH;\n\n  if (opts.chunkSize) {\n    if (opts.chunkSize < exports.Z_MIN_CHUNK || opts.chunkSize > exports.Z_MAX_CHUNK) {\n      throw new Error('Invalid chunk size: ' + opts.chunkSize);\n    }\n  }\n\n  if (opts.windowBits) {\n    if (opts.windowBits < exports.Z_MIN_WINDOWBITS || opts.windowBits > exports.Z_MAX_WINDOWBITS) {\n      throw new Error('Invalid windowBits: ' + opts.windowBits);\n    }\n  }\n\n  if (opts.level) {\n    if (opts.level < exports.Z_MIN_LEVEL || opts.level > exports.Z_MAX_LEVEL) {\n      throw new Error('Invalid compression level: ' + opts.level);\n    }\n  }\n\n  if (opts.memLevel) {\n    if (opts.memLevel < exports.Z_MIN_MEMLEVEL || opts.memLevel > exports.Z_MAX_MEMLEVEL) {\n      throw new Error('Invalid memLevel: ' + opts.memLevel);\n    }\n  }\n\n  if (opts.strategy) {\n    if (opts.strategy != exports.Z_FILTERED && opts.strategy != exports.Z_HUFFMAN_ONLY && opts.strategy != exports.Z_RLE && opts.strategy != exports.Z_FIXED && opts.strategy != exports.Z_DEFAULT_STRATEGY) {\n      throw new Error('Invalid strategy: ' + opts.strategy);\n    }\n  }\n\n  if (opts.dictionary) {\n    if (!Buffer.isBuffer(opts.dictionary)) {\n      throw new Error('Invalid dictionary: it should be a Buffer instance');\n    }\n  }\n\n  this._handle = new binding.Zlib(mode);\n\n  var self = this;\n  this._hadError = false;\n  this._handle.onerror = function (message, errno) {\n    // there is no way to cleanly recover.\n    // continuing only obscures problems.\n    _close(self);\n    self._hadError = true;\n\n    var error = new Error(message);\n    error.errno = errno;\n    error.code = exports.codes[errno];\n    self.emit('error', error);\n  };\n\n  var level = exports.Z_DEFAULT_COMPRESSION;\n  if (typeof opts.level === 'number') level = opts.level;\n\n  var strategy = exports.Z_DEFAULT_STRATEGY;\n  if (typeof opts.strategy === 'number') strategy = opts.strategy;\n\n  this._handle.init(opts.windowBits || exports.Z_DEFAULT_WINDOWBITS, level, opts.memLevel || exports.Z_DEFAULT_MEMLEVEL, strategy, opts.dictionary);\n\n  this._buffer = Buffer.allocUnsafe(this._chunkSize);\n  this._offset = 0;\n  this._level = level;\n  this._strategy = strategy;\n\n  this.once('end', this.close);\n\n  Object.defineProperty(this, '_closed', {\n    get: function () {\n      return !_this._handle;\n    },\n    configurable: true,\n    enumerable: true\n  });\n}\n\nutil.inherits(Zlib, Transform);\n\nZlib.prototype.params = function (level, strategy, callback) {\n  if (level < exports.Z_MIN_LEVEL || level > exports.Z_MAX_LEVEL) {\n    throw new RangeError('Invalid compression level: ' + level);\n  }\n  if (strategy != exports.Z_FILTERED && strategy != exports.Z_HUFFMAN_ONLY && strategy != exports.Z_RLE && strategy != exports.Z_FIXED && strategy != exports.Z_DEFAULT_STRATEGY) {\n    throw new TypeError('Invalid strategy: ' + strategy);\n  }\n\n  if (this._level !== level || this._strategy !== strategy) {\n    var self = this;\n    this.flush(binding.Z_SYNC_FLUSH, function () {\n      assert(self._handle, 'zlib binding closed');\n      self._handle.params(level, strategy);\n      if (!self._hadError) {\n        self._level = level;\n        self._strategy = strategy;\n        if (callback) callback();\n      }\n    });\n  } else {\n    process.nextTick(callback);\n  }\n};\n\nZlib.prototype.reset = function () {\n  assert(this._handle, 'zlib binding closed');\n  return this._handle.reset();\n};\n\n// This is the _flush function called by the transform class,\n// internally, when the last chunk has been written.\nZlib.prototype._flush = function (callback) {\n  this._transform(Buffer.alloc(0), '', callback);\n};\n\nZlib.prototype.flush = function (kind, callback) {\n  var _this2 = this;\n\n  var ws = this._writableState;\n\n  if (typeof kind === 'function' || kind === undefined && !callback) {\n    callback = kind;\n    kind = binding.Z_FULL_FLUSH;\n  }\n\n  if (ws.ended) {\n    if (callback) process.nextTick(callback);\n  } else if (ws.ending) {\n    if (callback) this.once('end', callback);\n  } else if (ws.needDrain) {\n    if (callback) {\n      this.once('drain', function () {\n        return _this2.flush(kind, callback);\n      });\n    }\n  } else {\n    this._flushFlag = kind;\n    this.write(Buffer.alloc(0), '', callback);\n  }\n};\n\nZlib.prototype.close = function (callback) {\n  _close(this, callback);\n  process.nextTick(emitCloseNT, this);\n};\n\nfunction _close(engine, callback) {\n  if (callback) process.nextTick(callback);\n\n  // Caller may invoke .close after a zlib error (which will null _handle).\n  if (!engine._handle) return;\n\n  engine._handle.close();\n  engine._handle = null;\n}\n\nfunction emitCloseNT(self) {\n  self.emit('close');\n}\n\nZlib.prototype._transform = function (chunk, encoding, cb) {\n  var flushFlag;\n  var ws = this._writableState;\n  var ending = ws.ending || ws.ended;\n  var last = ending && (!chunk || ws.length === chunk.length);\n\n  if (chunk !== null && !Buffer.isBuffer(chunk)) return cb(new Error('invalid input'));\n\n  if (!this._handle) return cb(new Error('zlib binding closed'));\n\n  // If it's the last chunk, or a final flush, we use the Z_FINISH flush flag\n  // (or whatever flag was provided using opts.finishFlush).\n  // If it's explicitly flushing at some other time, then we use\n  // Z_FULL_FLUSH. Otherwise, use Z_NO_FLUSH for maximum compression\n  // goodness.\n  if (last) flushFlag = this._finishFlushFlag;else {\n    flushFlag = this._flushFlag;\n    // once we've flushed the last of the queue, stop flushing and\n    // go back to the normal behavior.\n    if (chunk.length >= ws.length) {\n      this._flushFlag = this._opts.flush || binding.Z_NO_FLUSH;\n    }\n  }\n\n  this._processChunk(chunk, flushFlag, cb);\n};\n\nZlib.prototype._processChunk = function (chunk, flushFlag, cb) {\n  var availInBefore = chunk && chunk.length;\n  var availOutBefore = this._chunkSize - this._offset;\n  var inOff = 0;\n\n  var self = this;\n\n  var async = typeof cb === 'function';\n\n  if (!async) {\n    var buffers = [];\n    var nread = 0;\n\n    var error;\n    this.on('error', function (er) {\n      error = er;\n    });\n\n    assert(this._handle, 'zlib binding closed');\n    do {\n      var res = this._handle.writeSync(flushFlag, chunk, // in\n      inOff, // in_off\n      availInBefore, // in_len\n      this._buffer, // out\n      this._offset, //out_off\n      availOutBefore); // out_len\n    } while (!this._hadError && callback(res[0], res[1]));\n\n    if (this._hadError) {\n      throw error;\n    }\n\n    if (nread >= kMaxLength) {\n      _close(this);\n      throw new RangeError(kRangeErrorMessage);\n    }\n\n    var buf = Buffer.concat(buffers, nread);\n    _close(this);\n\n    return buf;\n  }\n\n  assert(this._handle, 'zlib binding closed');\n  var req = this._handle.write(flushFlag, chunk, // in\n  inOff, // in_off\n  availInBefore, // in_len\n  this._buffer, // out\n  this._offset, //out_off\n  availOutBefore); // out_len\n\n  req.buffer = chunk;\n  req.callback = callback;\n\n  function callback(availInAfter, availOutAfter) {\n    // When the callback is used in an async write, the callback's\n    // context is the `req` object that was created. The req object\n    // is === this._handle, and that's why it's important to null\n    // out the values after they are done being used. `this._handle`\n    // can stay in memory longer than the callback and buffer are needed.\n    if (this) {\n      this.buffer = null;\n      this.callback = null;\n    }\n\n    if (self._hadError) return;\n\n    var have = availOutBefore - availOutAfter;\n    assert(have >= 0, 'have should not go down');\n\n    if (have > 0) {\n      var out = self._buffer.slice(self._offset, self._offset + have);\n      self._offset += have;\n      // serve some output to the consumer.\n      if (async) {\n        self.push(out);\n      } else {\n        buffers.push(out);\n        nread += out.length;\n      }\n    }\n\n    // exhausted the output buffer, or used all the input create a new one.\n    if (availOutAfter === 0 || self._offset >= self._chunkSize) {\n      availOutBefore = self._chunkSize;\n      self._offset = 0;\n      self._buffer = Buffer.allocUnsafe(self._chunkSize);\n    }\n\n    if (availOutAfter === 0) {\n      // Not actually done.  Need to reprocess.\n      // Also, update the availInBefore to the availInAfter value,\n      // so that if we have to hit it a third (fourth, etc.) time,\n      // it'll have the correct byte counts.\n      inOff += availInBefore - availInAfter;\n      availInBefore = availInAfter;\n\n      if (!async) return true;\n\n      var newReq = self._handle.write(flushFlag, chunk, inOff, availInBefore, self._buffer, self._offset, self._chunkSize);\n      newReq.callback = callback; // this same function\n      newReq.buffer = chunk;\n      return;\n    }\n\n    if (!async) return false;\n\n    // finished with the chunk.\n    cb();\n  }\n};\n\nutil.inherits(Deflate, Zlib);\nutil.inherits(Inflate, Zlib);\nutil.inherits(Gzip, Zlib);\nutil.inherits(Gunzip, Zlib);\nutil.inherits(DeflateRaw, Zlib);\nutil.inherits(InflateRaw, Zlib);\nutil.inherits(Unzip, Zlib);"],"mappings":"AAAA,YAAY;;AAEZ,IAAIA,MAAM,GAAGC,OAAO,CAAC,QAAQ,CAAC,CAACD,MAAM;AACrC,IAAIE,SAAS,GAAGD,OAAO,CAAC,QAAQ,CAAC,CAACC,SAAS;AAC3C,IAAIC,OAAO,GAAGF,OAAO,CAAC,WAAW,CAAC;AAClC,IAAIG,IAAI,GAAGH,OAAO,CAAC,MAAM,CAAC;AAC1B,IAAII,MAAM,GAAGJ,OAAO,CAAC,QAAQ,CAAC,CAACK,EAAE;AACjC,IAAIC,UAAU,GAAGN,OAAO,CAAC,QAAQ,CAAC,CAACM,UAAU;AAC7C,IAAIC,kBAAkB,GAAG,iDAAiD,GAAG,SAAS,GAAGD,UAAU,CAACE,QAAQ,CAAC,EAAE,CAAC,GAAG,QAAQ;;AAE3H;AACA;AACAN,OAAO,CAACO,gBAAgB,GAAG,CAAC;AAC5BP,OAAO,CAACQ,gBAAgB,GAAG,EAAE;AAC7BR,OAAO,CAACS,oBAAoB,GAAG,EAAE;;AAEjC;AACA;AACA;AACAT,OAAO,CAACU,WAAW,GAAG,EAAE;AACxBV,OAAO,CAACW,WAAW,GAAGC,QAAQ;AAC9BZ,OAAO,CAACa,eAAe,GAAG,EAAE,GAAG,IAAI;AAEnCb,OAAO,CAACc,cAAc,GAAG,CAAC;AAC1Bd,OAAO,CAACe,cAAc,GAAG,CAAC;AAC1Bf,OAAO,CAACgB,kBAAkB,GAAG,CAAC;AAE9BhB,OAAO,CAACiB,WAAW,GAAG,CAAC,CAAC;AACxBjB,OAAO,CAACkB,WAAW,GAAG,CAAC;AACvBlB,OAAO,CAACmB,eAAe,GAAGnB,OAAO,CAACoB,qBAAqB;;AAEvD;AACA,IAAIC,KAAK,GAAGC,MAAM,CAACC,IAAI,CAACvB,OAAO,CAAC;AAChC,KAAK,IAAIwB,EAAE,GAAG,CAAC,EAAEA,EAAE,GAAGH,KAAK,CAACI,MAAM,EAAED,EAAE,EAAE,EAAE;EACxC,IAAIE,IAAI,GAAGL,KAAK,CAACG,EAAE,CAAC;EACpB,IAAIE,IAAI,CAACC,KAAK,CAAC,IAAI,CAAC,EAAE;IACpBL,MAAM,CAACM,cAAc,CAACC,OAAO,EAAEH,IAAI,EAAE;MACnCI,UAAU,EAAE,IAAI;MAAEC,KAAK,EAAE/B,OAAO,CAAC0B,IAAI,CAAC;MAAEM,QAAQ,EAAE;IACpD,CAAC,CAAC;EACJ;AACF;;AAEA;AACA,IAAIC,KAAK,GAAG;EACVC,IAAI,EAAElC,OAAO,CAACkC,IAAI;EAClBC,YAAY,EAAEnC,OAAO,CAACmC,YAAY;EAClCC,WAAW,EAAEpC,OAAO,CAACoC,WAAW;EAChCC,OAAO,EAAErC,OAAO,CAACqC,OAAO;EACxBC,cAAc,EAAEtC,OAAO,CAACsC,cAAc;EACtCC,YAAY,EAAEvC,OAAO,CAACuC,YAAY;EAClCC,WAAW,EAAExC,OAAO,CAACwC,WAAW;EAChCC,WAAW,EAAEzC,OAAO,CAACyC,WAAW;EAChCC,eAAe,EAAE1C,OAAO,CAAC0C;AAC3B,CAAC;AAED,IAAIC,KAAK,GAAGrB,MAAM,CAACC,IAAI,CAACU,KAAK,CAAC;AAC9B,KAAK,IAAIW,EAAE,GAAG,CAAC,EAAEA,EAAE,GAAGD,KAAK,CAAClB,MAAM,EAAEmB,EAAE,EAAE,EAAE;EACxC,IAAIC,IAAI,GAAGF,KAAK,CAACC,EAAE,CAAC;EACpBX,KAAK,CAACA,KAAK,CAACY,IAAI,CAAC,CAAC,GAAGA,IAAI;AAC3B;AAEAvB,MAAM,CAACM,cAAc,CAACC,OAAO,EAAE,OAAO,EAAE;EACtCC,UAAU,EAAE,IAAI;EAAEC,KAAK,EAAET,MAAM,CAACwB,MAAM,CAACb,KAAK,CAAC;EAAED,QAAQ,EAAE;AAC3D,CAAC,CAAC;AAEFH,OAAO,CAACkB,OAAO,GAAGA,OAAO;AACzBlB,OAAO,CAACmB,OAAO,GAAGA,OAAO;AACzBnB,OAAO,CAACoB,IAAI,GAAGA,IAAI;AACnBpB,OAAO,CAACqB,MAAM,GAAGA,MAAM;AACvBrB,OAAO,CAACsB,UAAU,GAAGA,UAAU;AAC/BtB,OAAO,CAACuB,UAAU,GAAGA,UAAU;AAC/BvB,OAAO,CAACwB,KAAK,GAAGA,KAAK;AAErBxB,OAAO,CAACyB,aAAa,GAAG,UAAUC,CAAC,EAAE;EACnC,OAAO,IAAIR,OAAO,CAACQ,CAAC,CAAC;AACvB,CAAC;AAED1B,OAAO,CAAC2B,aAAa,GAAG,UAAUD,CAAC,EAAE;EACnC,OAAO,IAAIP,OAAO,CAACO,CAAC,CAAC;AACvB,CAAC;AAED1B,OAAO,CAAC4B,gBAAgB,GAAG,UAAUF,CAAC,EAAE;EACtC,OAAO,IAAIJ,UAAU,CAACI,CAAC,CAAC;AAC1B,CAAC;AAED1B,OAAO,CAAC6B,gBAAgB,GAAG,UAAUH,CAAC,EAAE;EACtC,OAAO,IAAIH,UAAU,CAACG,CAAC,CAAC;AAC1B,CAAC;AAED1B,OAAO,CAAC8B,UAAU,GAAG,UAAUJ,CAAC,EAAE;EAChC,OAAO,IAAIN,IAAI,CAACM,CAAC,CAAC;AACpB,CAAC;AAED1B,OAAO,CAAC+B,YAAY,GAAG,UAAUL,CAAC,EAAE;EAClC,OAAO,IAAIL,MAAM,CAACK,CAAC,CAAC;AACtB,CAAC;AAED1B,OAAO,CAACgC,WAAW,GAAG,UAAUN,CAAC,EAAE;EACjC,OAAO,IAAIF,KAAK,CAACE,CAAC,CAAC;AACrB,CAAC;;AAED;AACA;AACA1B,OAAO,CAACiC,OAAO,GAAG,UAAUC,MAAM,EAAEC,IAAI,EAAEC,QAAQ,EAAE;EAClD,IAAI,OAAOD,IAAI,KAAK,UAAU,EAAE;IAC9BC,QAAQ,GAAGD,IAAI;IACfA,IAAI,GAAG,CAAC,CAAC;EACX;EACA,OAAOE,UAAU,CAAC,IAAInB,OAAO,CAACiB,IAAI,CAAC,EAAED,MAAM,EAAEE,QAAQ,CAAC;AACxD,CAAC;AAEDpC,OAAO,CAACsC,WAAW,GAAG,UAAUJ,MAAM,EAAEC,IAAI,EAAE;EAC5C,OAAOI,cAAc,CAAC,IAAIrB,OAAO,CAACiB,IAAI,CAAC,EAAED,MAAM,CAAC;AAClD,CAAC;AAEDlC,OAAO,CAACwC,IAAI,GAAG,UAAUN,MAAM,EAAEC,IAAI,EAAEC,QAAQ,EAAE;EAC/C,IAAI,OAAOD,IAAI,KAAK,UAAU,EAAE;IAC9BC,QAAQ,GAAGD,IAAI;IACfA,IAAI,GAAG,CAAC,CAAC;EACX;EACA,OAAOE,UAAU,CAAC,IAAIjB,IAAI,CAACe,IAAI,CAAC,EAAED,MAAM,EAAEE,QAAQ,CAAC;AACrD,CAAC;AAEDpC,OAAO,CAACyC,QAAQ,GAAG,UAAUP,MAAM,EAAEC,IAAI,EAAE;EACzC,OAAOI,cAAc,CAAC,IAAInB,IAAI,CAACe,IAAI,CAAC,EAAED,MAAM,CAAC;AAC/C,CAAC;AAEDlC,OAAO,CAAC0C,UAAU,GAAG,UAAUR,MAAM,EAAEC,IAAI,EAAEC,QAAQ,EAAE;EACrD,IAAI,OAAOD,IAAI,KAAK,UAAU,EAAE;IAC9BC,QAAQ,GAAGD,IAAI;IACfA,IAAI,GAAG,CAAC,CAAC;EACX;EACA,OAAOE,UAAU,CAAC,IAAIf,UAAU,CAACa,IAAI,CAAC,EAAED,MAAM,EAAEE,QAAQ,CAAC;AAC3D,CAAC;AAEDpC,OAAO,CAAC2C,cAAc,GAAG,UAAUT,MAAM,EAAEC,IAAI,EAAE;EAC/C,OAAOI,cAAc,CAAC,IAAIjB,UAAU,CAACa,IAAI,CAAC,EAAED,MAAM,CAAC;AACrD,CAAC;AAEDlC,OAAO,CAAC4C,KAAK,GAAG,UAAUV,MAAM,EAAEC,IAAI,EAAEC,QAAQ,EAAE;EAChD,IAAI,OAAOD,IAAI,KAAK,UAAU,EAAE;IAC9BC,QAAQ,GAAGD,IAAI;IACfA,IAAI,GAAG,CAAC,CAAC;EACX;EACA,OAAOE,UAAU,CAAC,IAAIb,KAAK,CAACW,IAAI,CAAC,EAAED,MAAM,EAAEE,QAAQ,CAAC;AACtD,CAAC;AAEDpC,OAAO,CAAC6C,SAAS,GAAG,UAAUX,MAAM,EAAEC,IAAI,EAAE;EAC1C,OAAOI,cAAc,CAAC,IAAIf,KAAK,CAACW,IAAI,CAAC,EAAED,MAAM,CAAC;AAChD,CAAC;AAEDlC,OAAO,CAAC8C,OAAO,GAAG,UAAUZ,MAAM,EAAEC,IAAI,EAAEC,QAAQ,EAAE;EAClD,IAAI,OAAOD,IAAI,KAAK,UAAU,EAAE;IAC9BC,QAAQ,GAAGD,IAAI;IACfA,IAAI,GAAG,CAAC,CAAC;EACX;EACA,OAAOE,UAAU,CAAC,IAAIlB,OAAO,CAACgB,IAAI,CAAC,EAAED,MAAM,EAAEE,QAAQ,CAAC;AACxD,CAAC;AAEDpC,OAAO,CAAC+C,WAAW,GAAG,UAAUb,MAAM,EAAEC,IAAI,EAAE;EAC5C,OAAOI,cAAc,CAAC,IAAIpB,OAAO,CAACgB,IAAI,CAAC,EAAED,MAAM,CAAC;AAClD,CAAC;AAEDlC,OAAO,CAACgD,MAAM,GAAG,UAAUd,MAAM,EAAEC,IAAI,EAAEC,QAAQ,EAAE;EACjD,IAAI,OAAOD,IAAI,KAAK,UAAU,EAAE;IAC9BC,QAAQ,GAAGD,IAAI;IACfA,IAAI,GAAG,CAAC,CAAC;EACX;EACA,OAAOE,UAAU,CAAC,IAAIhB,MAAM,CAACc,IAAI,CAAC,EAAED,MAAM,EAAEE,QAAQ,CAAC;AACvD,CAAC;AAEDpC,OAAO,CAACiD,UAAU,GAAG,UAAUf,MAAM,EAAEC,IAAI,EAAE;EAC3C,OAAOI,cAAc,CAAC,IAAIlB,MAAM,CAACc,IAAI,CAAC,EAAED,MAAM,CAAC;AACjD,CAAC;AAEDlC,OAAO,CAACkD,UAAU,GAAG,UAAUhB,MAAM,EAAEC,IAAI,EAAEC,QAAQ,EAAE;EACrD,IAAI,OAAOD,IAAI,KAAK,UAAU,EAAE;IAC9BC,QAAQ,GAAGD,IAAI;IACfA,IAAI,GAAG,CAAC,CAAC;EACX;EACA,OAAOE,UAAU,CAAC,IAAId,UAAU,CAACY,IAAI,CAAC,EAAED,MAAM,EAAEE,QAAQ,CAAC;AAC3D,CAAC;AAEDpC,OAAO,CAACmD,cAAc,GAAG,UAAUjB,MAAM,EAAEC,IAAI,EAAE;EAC/C,OAAOI,cAAc,CAAC,IAAIhB,UAAU,CAACY,IAAI,CAAC,EAAED,MAAM,CAAC;AACrD,CAAC;AAED,SAASG,UAAUA,CAACe,MAAM,EAAElB,MAAM,EAAEE,QAAQ,EAAE;EAC5C,IAAIiB,OAAO,GAAG,EAAE;EAChB,IAAIC,KAAK,GAAG,CAAC;EAEbF,MAAM,CAACG,EAAE,CAAC,OAAO,EAAEC,OAAO,CAAC;EAC3BJ,MAAM,CAACG,EAAE,CAAC,KAAK,EAAEE,KAAK,CAAC;EAEvBL,MAAM,CAACM,GAAG,CAACxB,MAAM,CAAC;EAClByB,IAAI,EAAE;EAEN,SAASA,IAAIA,CAAA,EAAG;IACd,IAAIC,KAAK;IACT,OAAO,IAAI,MAAMA,KAAK,GAAGR,MAAM,CAACS,IAAI,EAAE,CAAC,EAAE;MACvCR,OAAO,CAACS,IAAI,CAACF,KAAK,CAAC;MACnBN,KAAK,IAAIM,KAAK,CAAChE,MAAM;IACvB;IACAwD,MAAM,CAACW,IAAI,CAAC,UAAU,EAAEJ,IAAI,CAAC;EAC/B;EAEA,SAASH,OAAOA,CAACQ,GAAG,EAAE;IACpBZ,MAAM,CAACa,cAAc,CAAC,KAAK,EAAER,KAAK,CAAC;IACnCL,MAAM,CAACa,cAAc,CAAC,UAAU,EAAEN,IAAI,CAAC;IACvCvB,QAAQ,CAAC4B,GAAG,CAAC;EACf;EAEA,SAASP,KAAKA,CAAA,EAAG;IACf,IAAIS,GAAG;IACP,IAAIF,GAAG,GAAG,IAAI;IAEd,IAAIV,KAAK,IAAI/E,UAAU,EAAE;MACvByF,GAAG,GAAG,IAAIG,UAAU,CAAC3F,kBAAkB,CAAC;IAC1C,CAAC,MAAM;MACL0F,GAAG,GAAGlG,MAAM,CAACoG,MAAM,CAACf,OAAO,EAAEC,KAAK,CAAC;IACrC;IAEAD,OAAO,GAAG,EAAE;IACZD,MAAM,CAACiB,KAAK,EAAE;IACdjC,QAAQ,CAAC4B,GAAG,EAAEE,GAAG,CAAC;EACpB;AACF;AAEA,SAAS3B,cAAcA,CAACa,MAAM,EAAElB,MAAM,EAAE;EACtC,IAAI,OAAOA,MAAM,KAAK,QAAQ,EAAEA,MAAM,GAAGlE,MAAM,CAACsG,IAAI,CAACpC,MAAM,CAAC;EAE5D,IAAI,CAAClE,MAAM,CAACuG,QAAQ,CAACrC,MAAM,CAAC,EAAE,MAAM,IAAIsC,SAAS,CAAC,wBAAwB,CAAC;EAE3E,IAAIC,SAAS,GAAGrB,MAAM,CAACsB,gBAAgB;EAEvC,OAAOtB,MAAM,CAACuB,aAAa,CAACzC,MAAM,EAAEuC,SAAS,CAAC;AAChD;;AAEA;AACA;AACA,SAASvD,OAAOA,CAACiB,IAAI,EAAE;EACrB,IAAI,EAAE,IAAI,YAAYjB,OAAO,CAAC,EAAE,OAAO,IAAIA,OAAO,CAACiB,IAAI,CAAC;EACxDyC,IAAI,CAACC,IAAI,CAAC,IAAI,EAAE1C,IAAI,EAAEhE,OAAO,CAAC2G,OAAO,CAAC;AACxC;AAEA,SAAS3D,OAAOA,CAACgB,IAAI,EAAE;EACrB,IAAI,EAAE,IAAI,YAAYhB,OAAO,CAAC,EAAE,OAAO,IAAIA,OAAO,CAACgB,IAAI,CAAC;EACxDyC,IAAI,CAACC,IAAI,CAAC,IAAI,EAAE1C,IAAI,EAAEhE,OAAO,CAAC4G,OAAO,CAAC;AACxC;;AAEA;AACA,SAAS3D,IAAIA,CAACe,IAAI,EAAE;EAClB,IAAI,EAAE,IAAI,YAAYf,IAAI,CAAC,EAAE,OAAO,IAAIA,IAAI,CAACe,IAAI,CAAC;EAClDyC,IAAI,CAACC,IAAI,CAAC,IAAI,EAAE1C,IAAI,EAAEhE,OAAO,CAAC6G,IAAI,CAAC;AACrC;AAEA,SAAS3D,MAAMA,CAACc,IAAI,EAAE;EACpB,IAAI,EAAE,IAAI,YAAYd,MAAM,CAAC,EAAE,OAAO,IAAIA,MAAM,CAACc,IAAI,CAAC;EACtDyC,IAAI,CAACC,IAAI,CAAC,IAAI,EAAE1C,IAAI,EAAEhE,OAAO,CAAC8G,MAAM,CAAC;AACvC;;AAEA;AACA,SAAS3D,UAAUA,CAACa,IAAI,EAAE;EACxB,IAAI,EAAE,IAAI,YAAYb,UAAU,CAAC,EAAE,OAAO,IAAIA,UAAU,CAACa,IAAI,CAAC;EAC9DyC,IAAI,CAACC,IAAI,CAAC,IAAI,EAAE1C,IAAI,EAAEhE,OAAO,CAAC+G,UAAU,CAAC;AAC3C;AAEA,SAAS3D,UAAUA,CAACY,IAAI,EAAE;EACxB,IAAI,EAAE,IAAI,YAAYZ,UAAU,CAAC,EAAE,OAAO,IAAIA,UAAU,CAACY,IAAI,CAAC;EAC9DyC,IAAI,CAACC,IAAI,CAAC,IAAI,EAAE1C,IAAI,EAAEhE,OAAO,CAACgH,UAAU,CAAC;AAC3C;;AAEA;AACA,SAAS3D,KAAKA,CAACW,IAAI,EAAE;EACnB,IAAI,EAAE,IAAI,YAAYX,KAAK,CAAC,EAAE,OAAO,IAAIA,KAAK,CAACW,IAAI,CAAC;EACpDyC,IAAI,CAACC,IAAI,CAAC,IAAI,EAAE1C,IAAI,EAAEhE,OAAO,CAACiH,KAAK,CAAC;AACtC;AAEA,SAASC,gBAAgBA,CAACC,IAAI,EAAE;EAC9B,OAAOA,IAAI,KAAKnH,OAAO,CAACoH,UAAU,IAAID,IAAI,KAAKnH,OAAO,CAACqH,eAAe,IAAIF,IAAI,KAAKnH,OAAO,CAACsH,YAAY,IAAIH,IAAI,KAAKnH,OAAO,CAACuH,YAAY,IAAIJ,IAAI,KAAKnH,OAAO,CAACwH,QAAQ,IAAIL,IAAI,KAAKnH,OAAO,CAACyH,OAAO;AACnM;;AAEA;AACA;AACA;AACA;;AAEA,SAAShB,IAAIA,CAACzC,IAAI,EAAE0D,IAAI,EAAE;EACxB,IAAIC,KAAK,GAAG,IAAI;EAEhB,IAAI,CAACC,KAAK,GAAG5D,IAAI,GAAGA,IAAI,IAAI,CAAC,CAAC;EAC9B,IAAI,CAAC6D,UAAU,GAAG7D,IAAI,CAAC8D,SAAS,IAAIjG,OAAO,CAAChB,eAAe;EAE3Dd,SAAS,CAAC2G,IAAI,CAAC,IAAI,EAAE1C,IAAI,CAAC;EAE1B,IAAIA,IAAI,CAAC+D,KAAK,IAAI,CAACb,gBAAgB,CAAClD,IAAI,CAAC+D,KAAK,CAAC,EAAE;IAC/C,MAAM,IAAIC,KAAK,CAAC,sBAAsB,GAAGhE,IAAI,CAAC+D,KAAK,CAAC;EACtD;EACA,IAAI/D,IAAI,CAACiE,WAAW,IAAI,CAACf,gBAAgB,CAAClD,IAAI,CAACiE,WAAW,CAAC,EAAE;IAC3D,MAAM,IAAID,KAAK,CAAC,sBAAsB,GAAGhE,IAAI,CAACiE,WAAW,CAAC;EAC5D;EAEA,IAAI,CAACC,UAAU,GAAGlE,IAAI,CAAC+D,KAAK,IAAI/H,OAAO,CAACoH,UAAU;EAClD,IAAI,CAACb,gBAAgB,GAAG,OAAOvC,IAAI,CAACiE,WAAW,KAAK,WAAW,GAAGjE,IAAI,CAACiE,WAAW,GAAGjI,OAAO,CAACwH,QAAQ;EAErG,IAAIxD,IAAI,CAAC8D,SAAS,EAAE;IAClB,IAAI9D,IAAI,CAAC8D,SAAS,GAAGjG,OAAO,CAACnB,WAAW,IAAIsD,IAAI,CAAC8D,SAAS,GAAGjG,OAAO,CAAClB,WAAW,EAAE;MAChF,MAAM,IAAIqH,KAAK,CAAC,sBAAsB,GAAGhE,IAAI,CAAC8D,SAAS,CAAC;IAC1D;EACF;EAEA,IAAI9D,IAAI,CAACmE,UAAU,EAAE;IACnB,IAAInE,IAAI,CAACmE,UAAU,GAAGtG,OAAO,CAACtB,gBAAgB,IAAIyD,IAAI,CAACmE,UAAU,GAAGtG,OAAO,CAACrB,gBAAgB,EAAE;MAC5F,MAAM,IAAIwH,KAAK,CAAC,sBAAsB,GAAGhE,IAAI,CAACmE,UAAU,CAAC;IAC3D;EACF;EAEA,IAAInE,IAAI,CAACoE,KAAK,EAAE;IACd,IAAIpE,IAAI,CAACoE,KAAK,GAAGvG,OAAO,CAACZ,WAAW,IAAI+C,IAAI,CAACoE,KAAK,GAAGvG,OAAO,CAACX,WAAW,EAAE;MACxE,MAAM,IAAI8G,KAAK,CAAC,6BAA6B,GAAGhE,IAAI,CAACoE,KAAK,CAAC;IAC7D;EACF;EAEA,IAAIpE,IAAI,CAACqE,QAAQ,EAAE;IACjB,IAAIrE,IAAI,CAACqE,QAAQ,GAAGxG,OAAO,CAACf,cAAc,IAAIkD,IAAI,CAACqE,QAAQ,GAAGxG,OAAO,CAACd,cAAc,EAAE;MACpF,MAAM,IAAIiH,KAAK,CAAC,oBAAoB,GAAGhE,IAAI,CAACqE,QAAQ,CAAC;IACvD;EACF;EAEA,IAAIrE,IAAI,CAACsE,QAAQ,EAAE;IACjB,IAAItE,IAAI,CAACsE,QAAQ,IAAIzG,OAAO,CAAC0G,UAAU,IAAIvE,IAAI,CAACsE,QAAQ,IAAIzG,OAAO,CAAC2G,cAAc,IAAIxE,IAAI,CAACsE,QAAQ,IAAIzG,OAAO,CAAC4G,KAAK,IAAIzE,IAAI,CAACsE,QAAQ,IAAIzG,OAAO,CAAC6G,OAAO,IAAI1E,IAAI,CAACsE,QAAQ,IAAIzG,OAAO,CAAC8G,kBAAkB,EAAE;MACvM,MAAM,IAAIX,KAAK,CAAC,oBAAoB,GAAGhE,IAAI,CAACsE,QAAQ,CAAC;IACvD;EACF;EAEA,IAAItE,IAAI,CAAC4E,UAAU,EAAE;IACnB,IAAI,CAAC/I,MAAM,CAACuG,QAAQ,CAACpC,IAAI,CAAC4E,UAAU,CAAC,EAAE;MACrC,MAAM,IAAIZ,KAAK,CAAC,oDAAoD,CAAC;IACvE;EACF;EAEA,IAAI,CAACa,OAAO,GAAG,IAAI7I,OAAO,CAACyG,IAAI,CAACiB,IAAI,CAAC;EAErC,IAAIoB,IAAI,GAAG,IAAI;EACf,IAAI,CAACC,SAAS,GAAG,KAAK;EACtB,IAAI,CAACF,OAAO,CAACG,OAAO,GAAG,UAAUC,OAAO,EAAEC,KAAK,EAAE;IAC/C;IACA;IACAC,MAAM,CAACL,IAAI,CAAC;IACZA,IAAI,CAACC,SAAS,GAAG,IAAI;IAErB,IAAIK,KAAK,GAAG,IAAIpB,KAAK,CAACiB,OAAO,CAAC;IAC9BG,KAAK,CAACF,KAAK,GAAGA,KAAK;IACnBE,KAAK,CAACC,IAAI,GAAGxH,OAAO,CAACI,KAAK,CAACiH,KAAK,CAAC;IACjCJ,IAAI,CAACQ,IAAI,CAAC,OAAO,EAAEF,KAAK,CAAC;EAC3B,CAAC;EAED,IAAIhB,KAAK,GAAGvG,OAAO,CAACT,qBAAqB;EACzC,IAAI,OAAO4C,IAAI,CAACoE,KAAK,KAAK,QAAQ,EAAEA,KAAK,GAAGpE,IAAI,CAACoE,KAAK;EAEtD,IAAIE,QAAQ,GAAGzG,OAAO,CAAC8G,kBAAkB;EACzC,IAAI,OAAO3E,IAAI,CAACsE,QAAQ,KAAK,QAAQ,EAAEA,QAAQ,GAAGtE,IAAI,CAACsE,QAAQ;EAE/D,IAAI,CAACO,OAAO,CAACU,IAAI,CAACvF,IAAI,CAACmE,UAAU,IAAItG,OAAO,CAACpB,oBAAoB,EAAE2H,KAAK,EAAEpE,IAAI,CAACqE,QAAQ,IAAIxG,OAAO,CAACb,kBAAkB,EAAEsH,QAAQ,EAAEtE,IAAI,CAAC4E,UAAU,CAAC;EAEjJ,IAAI,CAACY,OAAO,GAAG3J,MAAM,CAAC4J,WAAW,CAAC,IAAI,CAAC5B,UAAU,CAAC;EAClD,IAAI,CAAC6B,OAAO,GAAG,CAAC;EAChB,IAAI,CAACC,MAAM,GAAGvB,KAAK;EACnB,IAAI,CAACwB,SAAS,GAAGtB,QAAQ;EAEzB,IAAI,CAAC1C,IAAI,CAAC,KAAK,EAAE,IAAI,CAACM,KAAK,CAAC;EAE5B5E,MAAM,CAACM,cAAc,CAAC,IAAI,EAAE,SAAS,EAAE;IACrCiI,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,CAAClC,KAAK,CAACkB,OAAO;IACvB,CAAC;IACDiB,YAAY,EAAE,IAAI;IAClBhI,UAAU,EAAE;EACd,CAAC,CAAC;AACJ;AAEA7B,IAAI,CAAC8J,QAAQ,CAACtD,IAAI,EAAE1G,SAAS,CAAC;AAE9B0G,IAAI,CAACuD,SAAS,CAACC,MAAM,GAAG,UAAU7B,KAAK,EAAEE,QAAQ,EAAErE,QAAQ,EAAE;EAC3D,IAAImE,KAAK,GAAGvG,OAAO,CAACZ,WAAW,IAAImH,KAAK,GAAGvG,OAAO,CAACX,WAAW,EAAE;IAC9D,MAAM,IAAI8E,UAAU,CAAC,6BAA6B,GAAGoC,KAAK,CAAC;EAC7D;EACA,IAAIE,QAAQ,IAAIzG,OAAO,CAAC0G,UAAU,IAAID,QAAQ,IAAIzG,OAAO,CAAC2G,cAAc,IAAIF,QAAQ,IAAIzG,OAAO,CAAC4G,KAAK,IAAIH,QAAQ,IAAIzG,OAAO,CAAC6G,OAAO,IAAIJ,QAAQ,IAAIzG,OAAO,CAAC8G,kBAAkB,EAAE;IAC9K,MAAM,IAAItC,SAAS,CAAC,oBAAoB,GAAGiC,QAAQ,CAAC;EACtD;EAEA,IAAI,IAAI,CAACqB,MAAM,KAAKvB,KAAK,IAAI,IAAI,CAACwB,SAAS,KAAKtB,QAAQ,EAAE;IACxD,IAAIQ,IAAI,GAAG,IAAI;IACf,IAAI,CAACf,KAAK,CAAC/H,OAAO,CAACsH,YAAY,EAAE,YAAY;MAC3CpH,MAAM,CAAC4I,IAAI,CAACD,OAAO,EAAE,qBAAqB,CAAC;MAC3CC,IAAI,CAACD,OAAO,CAACoB,MAAM,CAAC7B,KAAK,EAAEE,QAAQ,CAAC;MACpC,IAAI,CAACQ,IAAI,CAACC,SAAS,EAAE;QACnBD,IAAI,CAACa,MAAM,GAAGvB,KAAK;QACnBU,IAAI,CAACc,SAAS,GAAGtB,QAAQ;QACzB,IAAIrE,QAAQ,EAAEA,QAAQ,EAAE;MAC1B;IACF,CAAC,CAAC;EACJ,CAAC,MAAM;IACLiG,OAAO,CAACC,QAAQ,CAAClG,QAAQ,CAAC;EAC5B;AACF,CAAC;AAEDwC,IAAI,CAACuD,SAAS,CAACI,KAAK,GAAG,YAAY;EACjClK,MAAM,CAAC,IAAI,CAAC2I,OAAO,EAAE,qBAAqB,CAAC;EAC3C,OAAO,IAAI,CAACA,OAAO,CAACuB,KAAK,EAAE;AAC7B,CAAC;;AAED;AACA;AACA3D,IAAI,CAACuD,SAAS,CAACK,MAAM,GAAG,UAAUpG,QAAQ,EAAE;EAC1C,IAAI,CAACqG,UAAU,CAACzK,MAAM,CAAC0K,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,EAAEtG,QAAQ,CAAC;AAChD,CAAC;AAEDwC,IAAI,CAACuD,SAAS,CAACjC,KAAK,GAAG,UAAUyC,IAAI,EAAEvG,QAAQ,EAAE;EAC/C,IAAIwG,MAAM,GAAG,IAAI;EAEjB,IAAIC,EAAE,GAAG,IAAI,CAACC,cAAc;EAE5B,IAAI,OAAOH,IAAI,KAAK,UAAU,IAAIA,IAAI,KAAKI,SAAS,IAAI,CAAC3G,QAAQ,EAAE;IACjEA,QAAQ,GAAGuG,IAAI;IACfA,IAAI,GAAGxK,OAAO,CAACuH,YAAY;EAC7B;EAEA,IAAImD,EAAE,CAACG,KAAK,EAAE;IACZ,IAAI5G,QAAQ,EAAEiG,OAAO,CAACC,QAAQ,CAAClG,QAAQ,CAAC;EAC1C,CAAC,MAAM,IAAIyG,EAAE,CAACI,MAAM,EAAE;IACpB,IAAI7G,QAAQ,EAAE,IAAI,CAAC2B,IAAI,CAAC,KAAK,EAAE3B,QAAQ,CAAC;EAC1C,CAAC,MAAM,IAAIyG,EAAE,CAACK,SAAS,EAAE;IACvB,IAAI9G,QAAQ,EAAE;MACZ,IAAI,CAAC2B,IAAI,CAAC,OAAO,EAAE,YAAY;QAC7B,OAAO6E,MAAM,CAAC1C,KAAK,CAACyC,IAAI,EAAEvG,QAAQ,CAAC;MACrC,CAAC,CAAC;IACJ;EACF,CAAC,MAAM;IACL,IAAI,CAACiE,UAAU,GAAGsC,IAAI;IACtB,IAAI,CAACQ,KAAK,CAACnL,MAAM,CAAC0K,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,EAAEtG,QAAQ,CAAC;EAC3C;AACF,CAAC;AAEDwC,IAAI,CAACuD,SAAS,CAAC9D,KAAK,GAAG,UAAUjC,QAAQ,EAAE;EACzCkF,MAAM,CAAC,IAAI,EAAElF,QAAQ,CAAC;EACtBiG,OAAO,CAACC,QAAQ,CAACc,WAAW,EAAE,IAAI,CAAC;AACrC,CAAC;AAED,SAAS9B,MAAMA,CAAClE,MAAM,EAAEhB,QAAQ,EAAE;EAChC,IAAIA,QAAQ,EAAEiG,OAAO,CAACC,QAAQ,CAAClG,QAAQ,CAAC;;EAExC;EACA,IAAI,CAACgB,MAAM,CAAC4D,OAAO,EAAE;EAErB5D,MAAM,CAAC4D,OAAO,CAAC3C,KAAK,EAAE;EACtBjB,MAAM,CAAC4D,OAAO,GAAG,IAAI;AACvB;AAEA,SAASoC,WAAWA,CAACnC,IAAI,EAAE;EACzBA,IAAI,CAACQ,IAAI,CAAC,OAAO,CAAC;AACpB;AAEA7C,IAAI,CAACuD,SAAS,CAACM,UAAU,GAAG,UAAU7E,KAAK,EAAEyF,QAAQ,EAAEC,EAAE,EAAE;EACzD,IAAI7E,SAAS;EACb,IAAIoE,EAAE,GAAG,IAAI,CAACC,cAAc;EAC5B,IAAIG,MAAM,GAAGJ,EAAE,CAACI,MAAM,IAAIJ,EAAE,CAACG,KAAK;EAClC,IAAIO,IAAI,GAAGN,MAAM,KAAK,CAACrF,KAAK,IAAIiF,EAAE,CAACjJ,MAAM,KAAKgE,KAAK,CAAChE,MAAM,CAAC;EAE3D,IAAIgE,KAAK,KAAK,IAAI,IAAI,CAAC5F,MAAM,CAACuG,QAAQ,CAACX,KAAK,CAAC,EAAE,OAAO0F,EAAE,CAAC,IAAInD,KAAK,CAAC,eAAe,CAAC,CAAC;EAEpF,IAAI,CAAC,IAAI,CAACa,OAAO,EAAE,OAAOsC,EAAE,CAAC,IAAInD,KAAK,CAAC,qBAAqB,CAAC,CAAC;;EAE9D;EACA;EACA;EACA;EACA;EACA,IAAIoD,IAAI,EAAE9E,SAAS,GAAG,IAAI,CAACC,gBAAgB,CAAC,KAAK;IAC/CD,SAAS,GAAG,IAAI,CAAC4B,UAAU;IAC3B;IACA;IACA,IAAIzC,KAAK,CAAChE,MAAM,IAAIiJ,EAAE,CAACjJ,MAAM,EAAE;MAC7B,IAAI,CAACyG,UAAU,GAAG,IAAI,CAACN,KAAK,CAACG,KAAK,IAAI/H,OAAO,CAACoH,UAAU;IAC1D;EACF;EAEA,IAAI,CAACZ,aAAa,CAACf,KAAK,EAAEa,SAAS,EAAE6E,EAAE,CAAC;AAC1C,CAAC;AAED1E,IAAI,CAACuD,SAAS,CAACxD,aAAa,GAAG,UAAUf,KAAK,EAAEa,SAAS,EAAE6E,EAAE,EAAE;EAC7D,IAAIE,aAAa,GAAG5F,KAAK,IAAIA,KAAK,CAAChE,MAAM;EACzC,IAAI6J,cAAc,GAAG,IAAI,CAACzD,UAAU,GAAG,IAAI,CAAC6B,OAAO;EACnD,IAAI6B,KAAK,GAAG,CAAC;EAEb,IAAIzC,IAAI,GAAG,IAAI;EAEf,IAAI0C,KAAK,GAAG,OAAOL,EAAE,KAAK,UAAU;EAEpC,IAAI,CAACK,KAAK,EAAE;IACV,IAAItG,OAAO,GAAG,EAAE;IAChB,IAAIC,KAAK,GAAG,CAAC;IAEb,IAAIiE,KAAK;IACT,IAAI,CAAChE,EAAE,CAAC,OAAO,EAAE,UAAUqG,EAAE,EAAE;MAC7BrC,KAAK,GAAGqC,EAAE;IACZ,CAAC,CAAC;IAEFvL,MAAM,CAAC,IAAI,CAAC2I,OAAO,EAAE,qBAAqB,CAAC;IAC3C,GAAG;MACD,IAAI6C,GAAG,GAAG,IAAI,CAAC7C,OAAO,CAAC8C,SAAS,CAACrF,SAAS,EAAEb,KAAK;MAAE;MACnD8F,KAAK;MAAE;MACPF,aAAa;MAAE;MACf,IAAI,CAAC7B,OAAO;MAAE;MACd,IAAI,CAACE,OAAO;MAAE;MACd4B,cAAc,CAAC,CAAC,CAAC;IACnB,CAAC,QAAQ,CAAC,IAAI,CAACvC,SAAS,IAAI9E,QAAQ,CAACyH,GAAG,CAAC,CAAC,CAAC,EAAEA,GAAG,CAAC,CAAC,CAAC,CAAC;IAEpD,IAAI,IAAI,CAAC3C,SAAS,EAAE;MAClB,MAAMK,KAAK;IACb;IAEA,IAAIjE,KAAK,IAAI/E,UAAU,EAAE;MACvB+I,MAAM,CAAC,IAAI,CAAC;MACZ,MAAM,IAAInD,UAAU,CAAC3F,kBAAkB,CAAC;IAC1C;IAEA,IAAI0F,GAAG,GAAGlG,MAAM,CAACoG,MAAM,CAACf,OAAO,EAAEC,KAAK,CAAC;IACvCgE,MAAM,CAAC,IAAI,CAAC;IAEZ,OAAOpD,GAAG;EACZ;EAEA7F,MAAM,CAAC,IAAI,CAAC2I,OAAO,EAAE,qBAAqB,CAAC;EAC3C,IAAI+C,GAAG,GAAG,IAAI,CAAC/C,OAAO,CAACmC,KAAK,CAAC1E,SAAS,EAAEb,KAAK;EAAE;EAC/C8F,KAAK;EAAE;EACPF,aAAa;EAAE;EACf,IAAI,CAAC7B,OAAO;EAAE;EACd,IAAI,CAACE,OAAO;EAAE;EACd4B,cAAc,CAAC,CAAC,CAAC;;EAEjBM,GAAG,CAAC7H,MAAM,GAAG0B,KAAK;EAClBmG,GAAG,CAAC3H,QAAQ,GAAGA,QAAQ;EAEvB,SAASA,QAAQA,CAAC4H,YAAY,EAAEC,aAAa,EAAE;IAC7C;IACA;IACA;IACA;IACA;IACA,IAAI,IAAI,EAAE;MACR,IAAI,CAAC/H,MAAM,GAAG,IAAI;MAClB,IAAI,CAACE,QAAQ,GAAG,IAAI;IACtB;IAEA,IAAI6E,IAAI,CAACC,SAAS,EAAE;IAEpB,IAAIgD,IAAI,GAAGT,cAAc,GAAGQ,aAAa;IACzC5L,MAAM,CAAC6L,IAAI,IAAI,CAAC,EAAE,yBAAyB,CAAC;IAE5C,IAAIA,IAAI,GAAG,CAAC,EAAE;MACZ,IAAIC,GAAG,GAAGlD,IAAI,CAACU,OAAO,CAACyC,KAAK,CAACnD,IAAI,CAACY,OAAO,EAAEZ,IAAI,CAACY,OAAO,GAAGqC,IAAI,CAAC;MAC/DjD,IAAI,CAACY,OAAO,IAAIqC,IAAI;MACpB;MACA,IAAIP,KAAK,EAAE;QACT1C,IAAI,CAACnD,IAAI,CAACqG,GAAG,CAAC;MAChB,CAAC,MAAM;QACL9G,OAAO,CAACS,IAAI,CAACqG,GAAG,CAAC;QACjB7G,KAAK,IAAI6G,GAAG,CAACvK,MAAM;MACrB;IACF;;IAEA;IACA,IAAIqK,aAAa,KAAK,CAAC,IAAIhD,IAAI,CAACY,OAAO,IAAIZ,IAAI,CAACjB,UAAU,EAAE;MAC1DyD,cAAc,GAAGxC,IAAI,CAACjB,UAAU;MAChCiB,IAAI,CAACY,OAAO,GAAG,CAAC;MAChBZ,IAAI,CAACU,OAAO,GAAG3J,MAAM,CAAC4J,WAAW,CAACX,IAAI,CAACjB,UAAU,CAAC;IACpD;IAEA,IAAIiE,aAAa,KAAK,CAAC,EAAE;MACvB;MACA;MACA;MACA;MACAP,KAAK,IAAIF,aAAa,GAAGQ,YAAY;MACrCR,aAAa,GAAGQ,YAAY;MAE5B,IAAI,CAACL,KAAK,EAAE,OAAO,IAAI;MAEvB,IAAIU,MAAM,GAAGpD,IAAI,CAACD,OAAO,CAACmC,KAAK,CAAC1E,SAAS,EAAEb,KAAK,EAAE8F,KAAK,EAAEF,aAAa,EAAEvC,IAAI,CAACU,OAAO,EAAEV,IAAI,CAACY,OAAO,EAAEZ,IAAI,CAACjB,UAAU,CAAC;MACpHqE,MAAM,CAACjI,QAAQ,GAAGA,QAAQ,CAAC,CAAC;MAC5BiI,MAAM,CAACnI,MAAM,GAAG0B,KAAK;MACrB;IACF;IAEA,IAAI,CAAC+F,KAAK,EAAE,OAAO,KAAK;;IAExB;IACAL,EAAE,EAAE;EACN;AACF,CAAC;AAEDlL,IAAI,CAAC8J,QAAQ,CAAChH,OAAO,EAAE0D,IAAI,CAAC;AAC5BxG,IAAI,CAAC8J,QAAQ,CAAC/G,OAAO,EAAEyD,IAAI,CAAC;AAC5BxG,IAAI,CAAC8J,QAAQ,CAAC9G,IAAI,EAAEwD,IAAI,CAAC;AACzBxG,IAAI,CAAC8J,QAAQ,CAAC7G,MAAM,EAAEuD,IAAI,CAAC;AAC3BxG,IAAI,CAAC8J,QAAQ,CAAC5G,UAAU,EAAEsD,IAAI,CAAC;AAC/BxG,IAAI,CAAC8J,QAAQ,CAAC3G,UAAU,EAAEqD,IAAI,CAAC;AAC/BxG,IAAI,CAAC8J,QAAQ,CAAC1G,KAAK,EAAEoD,IAAI,CAAC"},"metadata":{},"sourceType":"script"}