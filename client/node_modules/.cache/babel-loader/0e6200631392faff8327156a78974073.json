{"ast":null,"code":"import _classCallCheck from \"/home/coder/Documents/CYF1/Full-Stack-Project-Assessment/client/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/coder/Documents/CYF1/Full-Stack-Project-Assessment/client/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _toConsumableArray from \"/home/coder/Documents/CYF1/Full-Stack-Project-Assessment/client/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport { unstable_ownerWindow as ownerWindow, unstable_ownerDocument as ownerDocument, unstable_getScrollbarSize as getScrollbarSize } from '@mui/utils'; // Is a vertical scrollbar displayed?\n\nfunction isOverflowing(container) {\n  var doc = ownerDocument(container);\n\n  if (doc.body === container) {\n    return ownerWindow(container).innerWidth > doc.documentElement.clientWidth;\n  }\n\n  return container.scrollHeight > container.clientHeight;\n}\n\nexport function ariaHidden(element, show) {\n  if (show) {\n    element.setAttribute('aria-hidden', 'true');\n  } else {\n    element.removeAttribute('aria-hidden');\n  }\n}\n\nfunction getPaddingRight(element) {\n  return parseInt(ownerWindow(element).getComputedStyle(element).paddingRight, 10) || 0;\n}\n\nfunction isAriaHiddenForbiddenOnElement(element) {\n  // The forbidden HTML tags are the ones from ARIA specification that\n  // can be children of body and can't have aria-hidden attribute.\n  // cf. https://www.w3.org/TR/html-aria/#docconformance\n  var forbiddenTagNames = ['TEMPLATE', 'SCRIPT', 'STYLE', 'LINK', 'MAP', 'META', 'NOSCRIPT', 'PICTURE', 'COL', 'COLGROUP', 'PARAM', 'SLOT', 'SOURCE', 'TRACK'];\n  var isForbiddenTagName = forbiddenTagNames.indexOf(element.tagName) !== -1;\n  var isInputHidden = element.tagName === 'INPUT' && element.getAttribute('type') === 'hidden';\n  return isForbiddenTagName || isInputHidden;\n}\n\nfunction ariaHiddenSiblings(container, mountElement, currentElement, elementsToExclude, show) {\n  var blacklist = [mountElement, currentElement].concat(_toConsumableArray(elementsToExclude));\n  [].forEach.call(container.children, function (element) {\n    var isNotExcludedElement = blacklist.indexOf(element) === -1;\n    var isNotForbiddenElement = !isAriaHiddenForbiddenOnElement(element);\n\n    if (isNotExcludedElement && isNotForbiddenElement) {\n      ariaHidden(element, show);\n    }\n  });\n}\n\nfunction findIndexOf(items, callback) {\n  var idx = -1;\n  items.some(function (item, index) {\n    if (callback(item)) {\n      idx = index;\n      return true;\n    }\n\n    return false;\n  });\n  return idx;\n}\n\nfunction handleContainer(containerInfo, props) {\n  var restoreStyle = [];\n  var container = containerInfo.container;\n\n  if (!props.disableScrollLock) {\n    if (isOverflowing(container)) {\n      // Compute the size before applying overflow hidden to avoid any scroll jumps.\n      var scrollbarSize = getScrollbarSize(ownerDocument(container));\n      restoreStyle.push({\n        value: container.style.paddingRight,\n        property: 'padding-right',\n        el: container\n      }); // Use computed style, here to get the real padding to add our scrollbar width.\n\n      container.style.paddingRight = \"\".concat(getPaddingRight(container) + scrollbarSize, \"px\"); // .mui-fixed is a global helper.\n\n      var fixedElements = ownerDocument(container).querySelectorAll('.mui-fixed');\n      [].forEach.call(fixedElements, function (element) {\n        restoreStyle.push({\n          value: element.style.paddingRight,\n          property: 'padding-right',\n          el: element\n        });\n        element.style.paddingRight = \"\".concat(getPaddingRight(element) + scrollbarSize, \"px\");\n      });\n    }\n\n    var scrollContainer;\n\n    if (container.parentNode instanceof DocumentFragment) {\n      scrollContainer = ownerDocument(container).body;\n    } else {\n      // Support html overflow-y: auto for scroll stability between pages\n      // https://css-tricks.com/snippets/css/force-vertical-scrollbar/\n      var parent = container.parentElement;\n      var containerWindow = ownerWindow(container);\n      scrollContainer = (parent == null ? void 0 : parent.nodeName) === 'HTML' && containerWindow.getComputedStyle(parent).overflowY === 'scroll' ? parent : container;\n    } // Block the scroll even if no scrollbar is visible to account for mobile keyboard\n    // screensize shrink.\n\n\n    restoreStyle.push({\n      value: scrollContainer.style.overflow,\n      property: 'overflow',\n      el: scrollContainer\n    }, {\n      value: scrollContainer.style.overflowX,\n      property: 'overflow-x',\n      el: scrollContainer\n    }, {\n      value: scrollContainer.style.overflowY,\n      property: 'overflow-y',\n      el: scrollContainer\n    });\n    scrollContainer.style.overflow = 'hidden';\n  }\n\n  var restore = function restore() {\n    restoreStyle.forEach(function (_ref) {\n      var value = _ref.value,\n          el = _ref.el,\n          property = _ref.property;\n\n      if (value) {\n        el.style.setProperty(property, value);\n      } else {\n        el.style.removeProperty(property);\n      }\n    });\n  };\n\n  return restore;\n}\n\nfunction getHiddenSiblings(container) {\n  var hiddenSiblings = [];\n  [].forEach.call(container.children, function (element) {\n    if (element.getAttribute('aria-hidden') === 'true') {\n      hiddenSiblings.push(element);\n    }\n  });\n  return hiddenSiblings;\n}\n/**\n * @ignore - do not document.\n *\n * Proper state management for containers and the modals in those containers.\n * Simplified, but inspired by react-overlay's ModalManager class.\n * Used by the Modal to ensure proper styling of containers.\n */\n\n\nexport var ModalManager = /*#__PURE__*/function () {\n  function ModalManager() {\n    _classCallCheck(this, ModalManager);\n\n    this.containers = void 0;\n    this.modals = void 0;\n    this.modals = [];\n    this.containers = [];\n  }\n\n  _createClass(ModalManager, [{\n    key: \"add\",\n    value: function add(modal, container) {\n      var modalIndex = this.modals.indexOf(modal);\n\n      if (modalIndex !== -1) {\n        return modalIndex;\n      }\n\n      modalIndex = this.modals.length;\n      this.modals.push(modal); // If the modal we are adding is already in the DOM.\n\n      if (modal.modalRef) {\n        ariaHidden(modal.modalRef, false);\n      }\n\n      var hiddenSiblings = getHiddenSiblings(container);\n      ariaHiddenSiblings(container, modal.mount, modal.modalRef, hiddenSiblings, true);\n      var containerIndex = findIndexOf(this.containers, function (item) {\n        return item.container === container;\n      });\n\n      if (containerIndex !== -1) {\n        this.containers[containerIndex].modals.push(modal);\n        return modalIndex;\n      }\n\n      this.containers.push({\n        modals: [modal],\n        container: container,\n        restore: null,\n        hiddenSiblings: hiddenSiblings\n      });\n      return modalIndex;\n    }\n  }, {\n    key: \"mount\",\n    value: function mount(modal, props) {\n      var containerIndex = findIndexOf(this.containers, function (item) {\n        return item.modals.indexOf(modal) !== -1;\n      });\n      var containerInfo = this.containers[containerIndex];\n\n      if (!containerInfo.restore) {\n        containerInfo.restore = handleContainer(containerInfo, props);\n      }\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(modal) {\n      var ariaHiddenState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var modalIndex = this.modals.indexOf(modal);\n\n      if (modalIndex === -1) {\n        return modalIndex;\n      }\n\n      var containerIndex = findIndexOf(this.containers, function (item) {\n        return item.modals.indexOf(modal) !== -1;\n      });\n      var containerInfo = this.containers[containerIndex];\n      containerInfo.modals.splice(containerInfo.modals.indexOf(modal), 1);\n      this.modals.splice(modalIndex, 1); // If that was the last modal in a container, clean up the container.\n\n      if (containerInfo.modals.length === 0) {\n        // The modal might be closed before it had the chance to be mounted in the DOM.\n        if (containerInfo.restore) {\n          containerInfo.restore();\n        }\n\n        if (modal.modalRef) {\n          // In case the modal wasn't in the DOM yet.\n          ariaHidden(modal.modalRef, ariaHiddenState);\n        }\n\n        ariaHiddenSiblings(containerInfo.container, modal.mount, modal.modalRef, containerInfo.hiddenSiblings, false);\n        this.containers.splice(containerIndex, 1);\n      } else {\n        // Otherwise make sure the next top modal is visible to a screen reader.\n        var nextTop = containerInfo.modals[containerInfo.modals.length - 1]; // as soon as a modal is adding its modalRef is undefined. it can't set\n        // aria-hidden because the dom element doesn't exist either\n        // when modal was unmounted before modalRef gets null\n\n        if (nextTop.modalRef) {\n          ariaHidden(nextTop.modalRef, false);\n        }\n      }\n\n      return modalIndex;\n    }\n  }, {\n    key: \"isTopModal\",\n    value: function isTopModal(modal) {\n      return this.modals.length > 0 && this.modals[this.modals.length - 1] === modal;\n    }\n  }]);\n\n  return ModalManager;\n}();","map":{"version":3,"sources":["/home/coder/Documents/CYF1/Full-Stack-Project-Assessment/client/node_modules/@mui/base/unstable_useModal/ModalManager.js"],"names":["unstable_ownerWindow","ownerWindow","unstable_ownerDocument","ownerDocument","unstable_getScrollbarSize","getScrollbarSize","isOverflowing","container","doc","body","innerWidth","documentElement","clientWidth","scrollHeight","clientHeight","ariaHidden","element","show","setAttribute","removeAttribute","getPaddingRight","parseInt","getComputedStyle","paddingRight","isAriaHiddenForbiddenOnElement","forbiddenTagNames","isForbiddenTagName","indexOf","tagName","isInputHidden","getAttribute","ariaHiddenSiblings","mountElement","currentElement","elementsToExclude","blacklist","forEach","call","children","isNotExcludedElement","isNotForbiddenElement","findIndexOf","items","callback","idx","some","item","index","handleContainer","containerInfo","props","restoreStyle","disableScrollLock","scrollbarSize","push","value","style","property","el","fixedElements","querySelectorAll","scrollContainer","parentNode","DocumentFragment","parent","parentElement","containerWindow","nodeName","overflowY","overflow","overflowX","restore","setProperty","removeProperty","getHiddenSiblings","hiddenSiblings","ModalManager","containers","modals","modal","modalIndex","length","modalRef","mount","containerIndex","ariaHiddenState","splice","nextTop"],"mappings":";;;AAAA,SAASA,oBAAoB,IAAIC,WAAjC,EAA8CC,sBAAsB,IAAIC,aAAxE,EAAuFC,yBAAyB,IAAIC,gBAApH,QAA4I,YAA5I,C,CACA;;AACA,SAASC,aAAT,CAAuBC,SAAvB,EAAkC;AAChC,MAAMC,GAAG,GAAGL,aAAa,CAACI,SAAD,CAAzB;;AACA,MAAIC,GAAG,CAACC,IAAJ,KAAaF,SAAjB,EAA4B;AAC1B,WAAON,WAAW,CAACM,SAAD,CAAX,CAAuBG,UAAvB,GAAoCF,GAAG,CAACG,eAAJ,CAAoBC,WAA/D;AACD;;AACD,SAAOL,SAAS,CAACM,YAAV,GAAyBN,SAAS,CAACO,YAA1C;AACD;;AACD,OAAO,SAASC,UAAT,CAAoBC,OAApB,EAA6BC,IAA7B,EAAmC;AACxC,MAAIA,IAAJ,EAAU;AACRD,IAAAA,OAAO,CAACE,YAAR,CAAqB,aAArB,EAAoC,MAApC;AACD,GAFD,MAEO;AACLF,IAAAA,OAAO,CAACG,eAAR,CAAwB,aAAxB;AACD;AACF;;AACD,SAASC,eAAT,CAAyBJ,OAAzB,EAAkC;AAChC,SAAOK,QAAQ,CAACpB,WAAW,CAACe,OAAD,CAAX,CAAqBM,gBAArB,CAAsCN,OAAtC,EAA+CO,YAAhD,EAA8D,EAA9D,CAAR,IAA6E,CAApF;AACD;;AACD,SAASC,8BAAT,CAAwCR,OAAxC,EAAiD;AAC/C;AACA;AACA;AACA,MAAMS,iBAAiB,GAAG,CAAC,UAAD,EAAa,QAAb,EAAuB,OAAvB,EAAgC,MAAhC,EAAwC,KAAxC,EAA+C,MAA/C,EAAuD,UAAvD,EAAmE,SAAnE,EAA8E,KAA9E,EAAqF,UAArF,EAAiG,OAAjG,EAA0G,MAA1G,EAAkH,QAAlH,EAA4H,OAA5H,CAA1B;AACA,MAAMC,kBAAkB,GAAGD,iBAAiB,CAACE,OAAlB,CAA0BX,OAAO,CAACY,OAAlC,MAA+C,CAAC,CAA3E;AACA,MAAMC,aAAa,GAAGb,OAAO,CAACY,OAAR,KAAoB,OAApB,IAA+BZ,OAAO,CAACc,YAAR,CAAqB,MAArB,MAAiC,QAAtF;AACA,SAAOJ,kBAAkB,IAAIG,aAA7B;AACD;;AACD,SAASE,kBAAT,CAA4BxB,SAA5B,EAAuCyB,YAAvC,EAAqDC,cAArD,EAAqEC,iBAArE,EAAwFjB,IAAxF,EAA8F;AAC5F,MAAMkB,SAAS,IAAIH,YAAJ,EAAkBC,cAAlB,4BAAqCC,iBAArC,EAAf;AACA,KAAGE,OAAH,CAAWC,IAAX,CAAgB9B,SAAS,CAAC+B,QAA1B,EAAoC,UAAAtB,OAAO,EAAI;AAC7C,QAAMuB,oBAAoB,GAAGJ,SAAS,CAACR,OAAV,CAAkBX,OAAlB,MAA+B,CAAC,CAA7D;AACA,QAAMwB,qBAAqB,GAAG,CAAChB,8BAA8B,CAACR,OAAD,CAA7D;;AACA,QAAIuB,oBAAoB,IAAIC,qBAA5B,EAAmD;AACjDzB,MAAAA,UAAU,CAACC,OAAD,EAAUC,IAAV,CAAV;AACD;AACF,GAND;AAOD;;AACD,SAASwB,WAAT,CAAqBC,KAArB,EAA4BC,QAA5B,EAAsC;AACpC,MAAIC,GAAG,GAAG,CAAC,CAAX;AACAF,EAAAA,KAAK,CAACG,IAAN,CAAW,UAACC,IAAD,EAAOC,KAAP,EAAiB;AAC1B,QAAIJ,QAAQ,CAACG,IAAD,CAAZ,EAAoB;AAClBF,MAAAA,GAAG,GAAGG,KAAN;AACA,aAAO,IAAP;AACD;;AACD,WAAO,KAAP;AACD,GAND;AAOA,SAAOH,GAAP;AACD;;AACD,SAASI,eAAT,CAAyBC,aAAzB,EAAwCC,KAAxC,EAA+C;AAC7C,MAAMC,YAAY,GAAG,EAArB;AACA,MAAM5C,SAAS,GAAG0C,aAAa,CAAC1C,SAAhC;;AACA,MAAI,CAAC2C,KAAK,CAACE,iBAAX,EAA8B;AAC5B,QAAI9C,aAAa,CAACC,SAAD,CAAjB,EAA8B;AAC5B;AACA,UAAM8C,aAAa,GAAGhD,gBAAgB,CAACF,aAAa,CAACI,SAAD,CAAd,CAAtC;AACA4C,MAAAA,YAAY,CAACG,IAAb,CAAkB;AAChBC,QAAAA,KAAK,EAAEhD,SAAS,CAACiD,KAAV,CAAgBjC,YADP;AAEhBkC,QAAAA,QAAQ,EAAE,eAFM;AAGhBC,QAAAA,EAAE,EAAEnD;AAHY,OAAlB,EAH4B,CAQ5B;;AACAA,MAAAA,SAAS,CAACiD,KAAV,CAAgBjC,YAAhB,aAAkCH,eAAe,CAACb,SAAD,CAAf,GAA6B8C,aAA/D,QAT4B,CAW5B;;AACA,UAAMM,aAAa,GAAGxD,aAAa,CAACI,SAAD,CAAb,CAAyBqD,gBAAzB,CAA0C,YAA1C,CAAtB;AACA,SAAGxB,OAAH,CAAWC,IAAX,CAAgBsB,aAAhB,EAA+B,UAAA3C,OAAO,EAAI;AACxCmC,QAAAA,YAAY,CAACG,IAAb,CAAkB;AAChBC,UAAAA,KAAK,EAAEvC,OAAO,CAACwC,KAAR,CAAcjC,YADL;AAEhBkC,UAAAA,QAAQ,EAAE,eAFM;AAGhBC,UAAAA,EAAE,EAAE1C;AAHY,SAAlB;AAKAA,QAAAA,OAAO,CAACwC,KAAR,CAAcjC,YAAd,aAAgCH,eAAe,CAACJ,OAAD,CAAf,GAA2BqC,aAA3D;AACD,OAPD;AAQD;;AACD,QAAIQ,eAAJ;;AACA,QAAItD,SAAS,CAACuD,UAAV,YAAgCC,gBAApC,EAAsD;AACpDF,MAAAA,eAAe,GAAG1D,aAAa,CAACI,SAAD,CAAb,CAAyBE,IAA3C;AACD,KAFD,MAEO;AACL;AACA;AACA,UAAMuD,MAAM,GAAGzD,SAAS,CAAC0D,aAAzB;AACA,UAAMC,eAAe,GAAGjE,WAAW,CAACM,SAAD,CAAnC;AACAsD,MAAAA,eAAe,GAAG,CAACG,MAAM,IAAI,IAAV,GAAiB,KAAK,CAAtB,GAA0BA,MAAM,CAACG,QAAlC,MAAgD,MAAhD,IAA0DD,eAAe,CAAC5C,gBAAhB,CAAiC0C,MAAjC,EAAyCI,SAAzC,KAAuD,QAAjH,GAA4HJ,MAA5H,GAAqIzD,SAAvJ;AACD,KAhC2B,CAkC5B;AACA;;;AACA4C,IAAAA,YAAY,CAACG,IAAb,CAAkB;AAChBC,MAAAA,KAAK,EAAEM,eAAe,CAACL,KAAhB,CAAsBa,QADb;AAEhBZ,MAAAA,QAAQ,EAAE,UAFM;AAGhBC,MAAAA,EAAE,EAAEG;AAHY,KAAlB,EAIG;AACDN,MAAAA,KAAK,EAAEM,eAAe,CAACL,KAAhB,CAAsBc,SAD5B;AAEDb,MAAAA,QAAQ,EAAE,YAFT;AAGDC,MAAAA,EAAE,EAAEG;AAHH,KAJH,EAQG;AACDN,MAAAA,KAAK,EAAEM,eAAe,CAACL,KAAhB,CAAsBY,SAD5B;AAEDX,MAAAA,QAAQ,EAAE,YAFT;AAGDC,MAAAA,EAAE,EAAEG;AAHH,KARH;AAaAA,IAAAA,eAAe,CAACL,KAAhB,CAAsBa,QAAtB,GAAiC,QAAjC;AACD;;AACD,MAAME,OAAO,GAAG,SAAVA,OAAU,GAAM;AACpBpB,IAAAA,YAAY,CAACf,OAAb,CAAqB,gBAIf;AAAA,UAHJmB,KAGI,QAHJA,KAGI;AAAA,UAFJG,EAEI,QAFJA,EAEI;AAAA,UADJD,QACI,QADJA,QACI;;AACJ,UAAIF,KAAJ,EAAW;AACTG,QAAAA,EAAE,CAACF,KAAH,CAASgB,WAAT,CAAqBf,QAArB,EAA+BF,KAA/B;AACD,OAFD,MAEO;AACLG,QAAAA,EAAE,CAACF,KAAH,CAASiB,cAAT,CAAwBhB,QAAxB;AACD;AACF,KAVD;AAWD,GAZD;;AAaA,SAAOc,OAAP;AACD;;AACD,SAASG,iBAAT,CAA2BnE,SAA3B,EAAsC;AACpC,MAAMoE,cAAc,GAAG,EAAvB;AACA,KAAGvC,OAAH,CAAWC,IAAX,CAAgB9B,SAAS,CAAC+B,QAA1B,EAAoC,UAAAtB,OAAO,EAAI;AAC7C,QAAIA,OAAO,CAACc,YAAR,CAAqB,aAArB,MAAwC,MAA5C,EAAoD;AAClD6C,MAAAA,cAAc,CAACrB,IAAf,CAAoBtC,OAApB;AACD;AACF,GAJD;AAKA,SAAO2D,cAAP;AACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,WAAaC,YAAb;AACE,0BAAc;AAAA;;AACZ,SAAKC,UAAL,GAAkB,KAAK,CAAvB;AACA,SAAKC,MAAL,GAAc,KAAK,CAAnB;AACA,SAAKA,MAAL,GAAc,EAAd;AACA,SAAKD,UAAL,GAAkB,EAAlB;AACD;;AANH;AAAA;AAAA,WAOE,aAAIE,KAAJ,EAAWxE,SAAX,EAAsB;AACpB,UAAIyE,UAAU,GAAG,KAAKF,MAAL,CAAYnD,OAAZ,CAAoBoD,KAApB,CAAjB;;AACA,UAAIC,UAAU,KAAK,CAAC,CAApB,EAAuB;AACrB,eAAOA,UAAP;AACD;;AACDA,MAAAA,UAAU,GAAG,KAAKF,MAAL,CAAYG,MAAzB;AACA,WAAKH,MAAL,CAAYxB,IAAZ,CAAiByB,KAAjB,EANoB,CAQpB;;AACA,UAAIA,KAAK,CAACG,QAAV,EAAoB;AAClBnE,QAAAA,UAAU,CAACgE,KAAK,CAACG,QAAP,EAAiB,KAAjB,CAAV;AACD;;AACD,UAAMP,cAAc,GAAGD,iBAAiB,CAACnE,SAAD,CAAxC;AACAwB,MAAAA,kBAAkB,CAACxB,SAAD,EAAYwE,KAAK,CAACI,KAAlB,EAAyBJ,KAAK,CAACG,QAA/B,EAAyCP,cAAzC,EAAyD,IAAzD,CAAlB;AACA,UAAMS,cAAc,GAAG3C,WAAW,CAAC,KAAKoC,UAAN,EAAkB,UAAA/B,IAAI;AAAA,eAAIA,IAAI,CAACvC,SAAL,KAAmBA,SAAvB;AAAA,OAAtB,CAAlC;;AACA,UAAI6E,cAAc,KAAK,CAAC,CAAxB,EAA2B;AACzB,aAAKP,UAAL,CAAgBO,cAAhB,EAAgCN,MAAhC,CAAuCxB,IAAvC,CAA4CyB,KAA5C;AACA,eAAOC,UAAP;AACD;;AACD,WAAKH,UAAL,CAAgBvB,IAAhB,CAAqB;AACnBwB,QAAAA,MAAM,EAAE,CAACC,KAAD,CADW;AAEnBxE,QAAAA,SAAS,EAATA,SAFmB;AAGnBgE,QAAAA,OAAO,EAAE,IAHU;AAInBI,QAAAA,cAAc,EAAdA;AAJmB,OAArB;AAMA,aAAOK,UAAP;AACD;AAjCH;AAAA;AAAA,WAkCE,eAAMD,KAAN,EAAa7B,KAAb,EAAoB;AAClB,UAAMkC,cAAc,GAAG3C,WAAW,CAAC,KAAKoC,UAAN,EAAkB,UAAA/B,IAAI;AAAA,eAAIA,IAAI,CAACgC,MAAL,CAAYnD,OAAZ,CAAoBoD,KAApB,MAA+B,CAAC,CAApC;AAAA,OAAtB,CAAlC;AACA,UAAM9B,aAAa,GAAG,KAAK4B,UAAL,CAAgBO,cAAhB,CAAtB;;AACA,UAAI,CAACnC,aAAa,CAACsB,OAAnB,EAA4B;AAC1BtB,QAAAA,aAAa,CAACsB,OAAd,GAAwBvB,eAAe,CAACC,aAAD,EAAgBC,KAAhB,CAAvC;AACD;AACF;AAxCH;AAAA;AAAA,WAyCE,gBAAO6B,KAAP,EAAsC;AAAA,UAAxBM,eAAwB,uEAAN,IAAM;AACpC,UAAML,UAAU,GAAG,KAAKF,MAAL,CAAYnD,OAAZ,CAAoBoD,KAApB,CAAnB;;AACA,UAAIC,UAAU,KAAK,CAAC,CAApB,EAAuB;AACrB,eAAOA,UAAP;AACD;;AACD,UAAMI,cAAc,GAAG3C,WAAW,CAAC,KAAKoC,UAAN,EAAkB,UAAA/B,IAAI;AAAA,eAAIA,IAAI,CAACgC,MAAL,CAAYnD,OAAZ,CAAoBoD,KAApB,MAA+B,CAAC,CAApC;AAAA,OAAtB,CAAlC;AACA,UAAM9B,aAAa,GAAG,KAAK4B,UAAL,CAAgBO,cAAhB,CAAtB;AACAnC,MAAAA,aAAa,CAAC6B,MAAd,CAAqBQ,MAArB,CAA4BrC,aAAa,CAAC6B,MAAd,CAAqBnD,OAArB,CAA6BoD,KAA7B,CAA5B,EAAiE,CAAjE;AACA,WAAKD,MAAL,CAAYQ,MAAZ,CAAmBN,UAAnB,EAA+B,CAA/B,EARoC,CAUpC;;AACA,UAAI/B,aAAa,CAAC6B,MAAd,CAAqBG,MAArB,KAAgC,CAApC,EAAuC;AACrC;AACA,YAAIhC,aAAa,CAACsB,OAAlB,EAA2B;AACzBtB,UAAAA,aAAa,CAACsB,OAAd;AACD;;AACD,YAAIQ,KAAK,CAACG,QAAV,EAAoB;AAClB;AACAnE,UAAAA,UAAU,CAACgE,KAAK,CAACG,QAAP,EAAiBG,eAAjB,CAAV;AACD;;AACDtD,QAAAA,kBAAkB,CAACkB,aAAa,CAAC1C,SAAf,EAA0BwE,KAAK,CAACI,KAAhC,EAAuCJ,KAAK,CAACG,QAA7C,EAAuDjC,aAAa,CAAC0B,cAArE,EAAqF,KAArF,CAAlB;AACA,aAAKE,UAAL,CAAgBS,MAAhB,CAAuBF,cAAvB,EAAuC,CAAvC;AACD,OAXD,MAWO;AACL;AACA,YAAMG,OAAO,GAAGtC,aAAa,CAAC6B,MAAd,CAAqB7B,aAAa,CAAC6B,MAAd,CAAqBG,MAArB,GAA8B,CAAnD,CAAhB,CAFK,CAGL;AACA;AACA;;AACA,YAAIM,OAAO,CAACL,QAAZ,EAAsB;AACpBnE,UAAAA,UAAU,CAACwE,OAAO,CAACL,QAAT,EAAmB,KAAnB,CAAV;AACD;AACF;;AACD,aAAOF,UAAP;AACD;AA1EH;AAAA;AAAA,WA2EE,oBAAWD,KAAX,EAAkB;AAChB,aAAO,KAAKD,MAAL,CAAYG,MAAZ,GAAqB,CAArB,IAA0B,KAAKH,MAAL,CAAY,KAAKA,MAAL,CAAYG,MAAZ,GAAqB,CAAjC,MAAwCF,KAAzE;AACD;AA7EH;;AAAA;AAAA","sourcesContent":["import { unstable_ownerWindow as ownerWindow, unstable_ownerDocument as ownerDocument, unstable_getScrollbarSize as getScrollbarSize } from '@mui/utils';\n// Is a vertical scrollbar displayed?\nfunction isOverflowing(container) {\n  const doc = ownerDocument(container);\n  if (doc.body === container) {\n    return ownerWindow(container).innerWidth > doc.documentElement.clientWidth;\n  }\n  return container.scrollHeight > container.clientHeight;\n}\nexport function ariaHidden(element, show) {\n  if (show) {\n    element.setAttribute('aria-hidden', 'true');\n  } else {\n    element.removeAttribute('aria-hidden');\n  }\n}\nfunction getPaddingRight(element) {\n  return parseInt(ownerWindow(element).getComputedStyle(element).paddingRight, 10) || 0;\n}\nfunction isAriaHiddenForbiddenOnElement(element) {\n  // The forbidden HTML tags are the ones from ARIA specification that\n  // can be children of body and can't have aria-hidden attribute.\n  // cf. https://www.w3.org/TR/html-aria/#docconformance\n  const forbiddenTagNames = ['TEMPLATE', 'SCRIPT', 'STYLE', 'LINK', 'MAP', 'META', 'NOSCRIPT', 'PICTURE', 'COL', 'COLGROUP', 'PARAM', 'SLOT', 'SOURCE', 'TRACK'];\n  const isForbiddenTagName = forbiddenTagNames.indexOf(element.tagName) !== -1;\n  const isInputHidden = element.tagName === 'INPUT' && element.getAttribute('type') === 'hidden';\n  return isForbiddenTagName || isInputHidden;\n}\nfunction ariaHiddenSiblings(container, mountElement, currentElement, elementsToExclude, show) {\n  const blacklist = [mountElement, currentElement, ...elementsToExclude];\n  [].forEach.call(container.children, element => {\n    const isNotExcludedElement = blacklist.indexOf(element) === -1;\n    const isNotForbiddenElement = !isAriaHiddenForbiddenOnElement(element);\n    if (isNotExcludedElement && isNotForbiddenElement) {\n      ariaHidden(element, show);\n    }\n  });\n}\nfunction findIndexOf(items, callback) {\n  let idx = -1;\n  items.some((item, index) => {\n    if (callback(item)) {\n      idx = index;\n      return true;\n    }\n    return false;\n  });\n  return idx;\n}\nfunction handleContainer(containerInfo, props) {\n  const restoreStyle = [];\n  const container = containerInfo.container;\n  if (!props.disableScrollLock) {\n    if (isOverflowing(container)) {\n      // Compute the size before applying overflow hidden to avoid any scroll jumps.\n      const scrollbarSize = getScrollbarSize(ownerDocument(container));\n      restoreStyle.push({\n        value: container.style.paddingRight,\n        property: 'padding-right',\n        el: container\n      });\n      // Use computed style, here to get the real padding to add our scrollbar width.\n      container.style.paddingRight = `${getPaddingRight(container) + scrollbarSize}px`;\n\n      // .mui-fixed is a global helper.\n      const fixedElements = ownerDocument(container).querySelectorAll('.mui-fixed');\n      [].forEach.call(fixedElements, element => {\n        restoreStyle.push({\n          value: element.style.paddingRight,\n          property: 'padding-right',\n          el: element\n        });\n        element.style.paddingRight = `${getPaddingRight(element) + scrollbarSize}px`;\n      });\n    }\n    let scrollContainer;\n    if (container.parentNode instanceof DocumentFragment) {\n      scrollContainer = ownerDocument(container).body;\n    } else {\n      // Support html overflow-y: auto for scroll stability between pages\n      // https://css-tricks.com/snippets/css/force-vertical-scrollbar/\n      const parent = container.parentElement;\n      const containerWindow = ownerWindow(container);\n      scrollContainer = (parent == null ? void 0 : parent.nodeName) === 'HTML' && containerWindow.getComputedStyle(parent).overflowY === 'scroll' ? parent : container;\n    }\n\n    // Block the scroll even if no scrollbar is visible to account for mobile keyboard\n    // screensize shrink.\n    restoreStyle.push({\n      value: scrollContainer.style.overflow,\n      property: 'overflow',\n      el: scrollContainer\n    }, {\n      value: scrollContainer.style.overflowX,\n      property: 'overflow-x',\n      el: scrollContainer\n    }, {\n      value: scrollContainer.style.overflowY,\n      property: 'overflow-y',\n      el: scrollContainer\n    });\n    scrollContainer.style.overflow = 'hidden';\n  }\n  const restore = () => {\n    restoreStyle.forEach(({\n      value,\n      el,\n      property\n    }) => {\n      if (value) {\n        el.style.setProperty(property, value);\n      } else {\n        el.style.removeProperty(property);\n      }\n    });\n  };\n  return restore;\n}\nfunction getHiddenSiblings(container) {\n  const hiddenSiblings = [];\n  [].forEach.call(container.children, element => {\n    if (element.getAttribute('aria-hidden') === 'true') {\n      hiddenSiblings.push(element);\n    }\n  });\n  return hiddenSiblings;\n}\n/**\n * @ignore - do not document.\n *\n * Proper state management for containers and the modals in those containers.\n * Simplified, but inspired by react-overlay's ModalManager class.\n * Used by the Modal to ensure proper styling of containers.\n */\nexport class ModalManager {\n  constructor() {\n    this.containers = void 0;\n    this.modals = void 0;\n    this.modals = [];\n    this.containers = [];\n  }\n  add(modal, container) {\n    let modalIndex = this.modals.indexOf(modal);\n    if (modalIndex !== -1) {\n      return modalIndex;\n    }\n    modalIndex = this.modals.length;\n    this.modals.push(modal);\n\n    // If the modal we are adding is already in the DOM.\n    if (modal.modalRef) {\n      ariaHidden(modal.modalRef, false);\n    }\n    const hiddenSiblings = getHiddenSiblings(container);\n    ariaHiddenSiblings(container, modal.mount, modal.modalRef, hiddenSiblings, true);\n    const containerIndex = findIndexOf(this.containers, item => item.container === container);\n    if (containerIndex !== -1) {\n      this.containers[containerIndex].modals.push(modal);\n      return modalIndex;\n    }\n    this.containers.push({\n      modals: [modal],\n      container,\n      restore: null,\n      hiddenSiblings\n    });\n    return modalIndex;\n  }\n  mount(modal, props) {\n    const containerIndex = findIndexOf(this.containers, item => item.modals.indexOf(modal) !== -1);\n    const containerInfo = this.containers[containerIndex];\n    if (!containerInfo.restore) {\n      containerInfo.restore = handleContainer(containerInfo, props);\n    }\n  }\n  remove(modal, ariaHiddenState = true) {\n    const modalIndex = this.modals.indexOf(modal);\n    if (modalIndex === -1) {\n      return modalIndex;\n    }\n    const containerIndex = findIndexOf(this.containers, item => item.modals.indexOf(modal) !== -1);\n    const containerInfo = this.containers[containerIndex];\n    containerInfo.modals.splice(containerInfo.modals.indexOf(modal), 1);\n    this.modals.splice(modalIndex, 1);\n\n    // If that was the last modal in a container, clean up the container.\n    if (containerInfo.modals.length === 0) {\n      // The modal might be closed before it had the chance to be mounted in the DOM.\n      if (containerInfo.restore) {\n        containerInfo.restore();\n      }\n      if (modal.modalRef) {\n        // In case the modal wasn't in the DOM yet.\n        ariaHidden(modal.modalRef, ariaHiddenState);\n      }\n      ariaHiddenSiblings(containerInfo.container, modal.mount, modal.modalRef, containerInfo.hiddenSiblings, false);\n      this.containers.splice(containerIndex, 1);\n    } else {\n      // Otherwise make sure the next top modal is visible to a screen reader.\n      const nextTop = containerInfo.modals[containerInfo.modals.length - 1];\n      // as soon as a modal is adding its modalRef is undefined. it can't set\n      // aria-hidden because the dom element doesn't exist either\n      // when modal was unmounted before modalRef gets null\n      if (nextTop.modalRef) {\n        ariaHidden(nextTop.modalRef, false);\n      }\n    }\n    return modalIndex;\n  }\n  isTopModal(modal) {\n    return this.modals.length > 0 && this.modals[this.modals.length - 1] === modal;\n  }\n}"]},"metadata":{},"sourceType":"module"}