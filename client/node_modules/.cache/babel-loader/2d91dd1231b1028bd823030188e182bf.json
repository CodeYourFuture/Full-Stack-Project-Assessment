{"ast":null,"code":"'use strict';\n\nvar BN = require('bn.js');\nvar utils = require('../utils');\nvar assert = utils.assert;\nfunction KeyPair(ec, options) {\n  this.ec = ec;\n  this.priv = null;\n  this.pub = null;\n\n  // KeyPair(ec, { priv: ..., pub: ... })\n  if (options.priv) this._importPrivate(options.priv, options.privEnc);\n  if (options.pub) this._importPublic(options.pub, options.pubEnc);\n}\nmodule.exports = KeyPair;\nKeyPair.fromPublic = function fromPublic(ec, pub, enc) {\n  if (pub instanceof KeyPair) return pub;\n  return new KeyPair(ec, {\n    pub: pub,\n    pubEnc: enc\n  });\n};\nKeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {\n  if (priv instanceof KeyPair) return priv;\n  return new KeyPair(ec, {\n    priv: priv,\n    privEnc: enc\n  });\n};\nKeyPair.prototype.validate = function validate() {\n  var pub = this.getPublic();\n  if (pub.isInfinity()) return {\n    result: false,\n    reason: 'Invalid public key'\n  };\n  if (!pub.validate()) return {\n    result: false,\n    reason: 'Public key is not a point'\n  };\n  if (!pub.mul(this.ec.curve.n).isInfinity()) return {\n    result: false,\n    reason: 'Public key * N != O'\n  };\n  return {\n    result: true,\n    reason: null\n  };\n};\nKeyPair.prototype.getPublic = function getPublic(compact, enc) {\n  // compact is optional argument\n  if (typeof compact === 'string') {\n    enc = compact;\n    compact = null;\n  }\n  if (!this.pub) this.pub = this.ec.g.mul(this.priv);\n  if (!enc) return this.pub;\n  return this.pub.encode(enc, compact);\n};\nKeyPair.prototype.getPrivate = function getPrivate(enc) {\n  if (enc === 'hex') return this.priv.toString(16, 2);else return this.priv;\n};\nKeyPair.prototype._importPrivate = function _importPrivate(key, enc) {\n  this.priv = new BN(key, enc || 16);\n\n  // Ensure that the priv won't be bigger than n, otherwise we may fail\n  // in fixed multiplication method\n  this.priv = this.priv.umod(this.ec.curve.n);\n};\nKeyPair.prototype._importPublic = function _importPublic(key, enc) {\n  if (key.x || key.y) {\n    // Montgomery points only have an `x` coordinate.\n    // Weierstrass/Edwards points on the other hand have both `x` and\n    // `y` coordinates.\n    if (this.ec.curve.type === 'mont') {\n      assert(key.x, 'Need x coordinate');\n    } else if (this.ec.curve.type === 'short' || this.ec.curve.type === 'edwards') {\n      assert(key.x && key.y, 'Need both x and y coordinate');\n    }\n    this.pub = this.ec.curve.point(key.x, key.y);\n    return;\n  }\n  this.pub = this.ec.curve.decodePoint(key, enc);\n};\n\n// ECDH\nKeyPair.prototype.derive = function derive(pub) {\n  if (!pub.validate()) {\n    assert(pub.validate(), 'public point not validated');\n  }\n  return pub.mul(this.priv).getX();\n};\n\n// ECDSA\nKeyPair.prototype.sign = function sign(msg, enc, options) {\n  return this.ec.sign(msg, this, enc, options);\n};\nKeyPair.prototype.verify = function verify(msg, signature) {\n  return this.ec.verify(msg, signature, this);\n};\nKeyPair.prototype.inspect = function inspect() {\n  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) + ' pub: ' + (this.pub && this.pub.inspect()) + ' >';\n};","map":null,"metadata":{},"sourceType":"script"}