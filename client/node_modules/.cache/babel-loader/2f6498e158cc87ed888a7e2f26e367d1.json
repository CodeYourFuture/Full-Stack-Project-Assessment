{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\cuney\\\\OneDrive\\\\Belgeler\\\\GitHub\\\\Full-Stack-Project-Assessment\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\nvar _createClass = require(\"C:\\\\Users\\\\cuney\\\\OneDrive\\\\Belgeler\\\\GitHub\\\\Full-Stack-Project-Assessment\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\nvar _possibleConstructorReturn = require(\"C:\\\\Users\\\\cuney\\\\OneDrive\\\\Belgeler\\\\GitHub\\\\Full-Stack-Project-Assessment\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\nvar _get = require(\"C:\\\\Users\\\\cuney\\\\OneDrive\\\\Belgeler\\\\GitHub\\\\Full-Stack-Project-Assessment\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/get\");\nvar _getPrototypeOf = require(\"C:\\\\Users\\\\cuney\\\\OneDrive\\\\Belgeler\\\\GitHub\\\\Full-Stack-Project-Assessment\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\nvar _inherits = require(\"C:\\\\Users\\\\cuney\\\\OneDrive\\\\Belgeler\\\\GitHub\\\\Full-Stack-Project-Assessment\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\nvar MiniPass = require('minipass');\nvar normPath = require('./normalize-windows-path.js');\nvar SLURP = Symbol('slurp');\nmodule.exports = /*#__PURE__*/function (_MiniPass) {\n  _inherits(ReadEntry, _MiniPass);\n  function ReadEntry(header, ex, gex) {\n    var _this;\n    _classCallCheck(this, ReadEntry);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ReadEntry).call(this));\n    // read entries always start life paused.  this is to avoid the\n    // situation where Minipass's auto-ending empty streams results\n    // in an entry ending before we're ready for it.\n    _this.pause();\n    _this.extended = ex;\n    _this.globalExtended = gex;\n    _this.header = header;\n    _this.startBlockSize = 512 * Math.ceil(header.size / 512);\n    _this.blockRemain = _this.startBlockSize;\n    _this.remain = header.size;\n    _this.type = header.type;\n    _this.meta = false;\n    _this.ignore = false;\n    switch (_this.type) {\n      case 'File':\n      case 'OldFile':\n      case 'Link':\n      case 'SymbolicLink':\n      case 'CharacterDevice':\n      case 'BlockDevice':\n      case 'Directory':\n      case 'FIFO':\n      case 'ContiguousFile':\n      case 'GNUDumpDir':\n        break;\n      case 'NextFileHasLongLinkpath':\n      case 'NextFileHasLongPath':\n      case 'OldGnuLongPath':\n      case 'GlobalExtendedHeader':\n      case 'ExtendedHeader':\n      case 'OldExtendedHeader':\n        _this.meta = true;\n        break;\n\n      // NOTE: gnutar and bsdtar treat unrecognized types as 'File'\n      // it may be worth doing the same, but with a warning.\n      default:\n        _this.ignore = true;\n    }\n    _this.path = normPath(header.path);\n    _this.mode = header.mode;\n    if (_this.mode) {\n      _this.mode = _this.mode & 4095;\n    }\n    _this.uid = header.uid;\n    _this.gid = header.gid;\n    _this.uname = header.uname;\n    _this.gname = header.gname;\n    _this.size = header.size;\n    _this.mtime = header.mtime;\n    _this.atime = header.atime;\n    _this.ctime = header.ctime;\n    _this.linkpath = normPath(header.linkpath);\n    _this.uname = header.uname;\n    _this.gname = header.gname;\n    if (ex) {\n      _this[SLURP](ex);\n    }\n    if (gex) {\n      _this[SLURP](gex, true);\n    }\n    return _this;\n  }\n  _createClass(ReadEntry, [{\n    key: \"write\",\n    value: function write(data) {\n      var writeLen = data.length;\n      if (writeLen > this.blockRemain) {\n        throw new Error('writing more to entry than is appropriate');\n      }\n      var r = this.remain;\n      var br = this.blockRemain;\n      this.remain = Math.max(0, r - writeLen);\n      this.blockRemain = Math.max(0, br - writeLen);\n      if (this.ignore) {\n        return true;\n      }\n      if (r >= writeLen) {\n        return _get(_getPrototypeOf(ReadEntry.prototype), \"write\", this).call(this, data);\n      }\n\n      // r < writeLen\n      return _get(_getPrototypeOf(ReadEntry.prototype), \"write\", this).call(this, data.slice(0, r));\n    }\n  }, {\n    key: SLURP,\n    value: function value(ex, global) {\n      for (var k in ex) {\n        // we slurp in everything except for the path attribute in\n        // a global extended header, because that's weird.\n        if (ex[k] !== null && ex[k] !== undefined && !(global && k === 'path')) {\n          this[k] = k === 'path' || k === 'linkpath' ? normPath(ex[k]) : ex[k];\n        }\n      }\n    }\n  }]);\n  return ReadEntry;\n}(MiniPass);","map":null,"metadata":{},"sourceType":"script"}