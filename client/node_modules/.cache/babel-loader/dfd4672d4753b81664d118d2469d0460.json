{"ast":null,"code":"'use strict';\n\nvar _possibleConstructorReturn = require(\"C:\\\\Users\\\\cuney\\\\OneDrive\\\\Belgeler\\\\GitHub\\\\Full-Stack-Project-Assessment\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\nvar _inherits = require(\"C:\\\\Users\\\\cuney\\\\OneDrive\\\\Belgeler\\\\GitHub\\\\Full-Stack-Project-Assessment\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\nvar _get = require(\"C:\\\\Users\\\\cuney\\\\OneDrive\\\\Belgeler\\\\GitHub\\\\Full-Stack-Project-Assessment\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/get\");\nvar _getPrototypeOf = require(\"C:\\\\Users\\\\cuney\\\\OneDrive\\\\Belgeler\\\\GitHub\\\\Full-Stack-Project-Assessment\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\nvar _classCallCheck = require(\"C:\\\\Users\\\\cuney\\\\OneDrive\\\\Belgeler\\\\GitHub\\\\Full-Stack-Project-Assessment\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\nvar _createClass = require(\"C:\\\\Users\\\\cuney\\\\OneDrive\\\\Belgeler\\\\GitHub\\\\Full-Stack-Project-Assessment\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nvar proc = typeof process === 'object' && process ? process : {\n  stdout: null,\n  stderr: null\n};\nvar EE = require('events');\nvar Stream = require('stream');\nvar SD = require('string_decoder').StringDecoder;\nvar EOF = Symbol('EOF');\nvar MAYBE_EMIT_END = Symbol('maybeEmitEnd');\nvar EMITTED_END = Symbol('emittedEnd');\nvar EMITTING_END = Symbol('emittingEnd');\nvar EMITTED_ERROR = Symbol('emittedError');\nvar CLOSED = Symbol('closed');\nvar READ = Symbol('read');\nvar FLUSH = Symbol('flush');\nvar FLUSHCHUNK = Symbol('flushChunk');\nvar ENCODING = Symbol('encoding');\nvar DECODER = Symbol('decoder');\nvar FLOWING = Symbol('flowing');\nvar PAUSED = Symbol('paused');\nvar RESUME = Symbol('resume');\nvar BUFFERLENGTH = Symbol('bufferLength');\nvar BUFFERPUSH = Symbol('bufferPush');\nvar BUFFERSHIFT = Symbol('bufferShift');\nvar OBJECTMODE = Symbol('objectMode');\nvar DESTROYED = Symbol('destroyed');\nvar EMITDATA = Symbol('emitData');\nvar EMITEND = Symbol('emitEnd');\nvar EMITEND2 = Symbol('emitEnd2');\nvar ASYNC = Symbol('async');\nvar defer = function defer(fn) {\n  return Promise.resolve().then(fn);\n};\n\n// TODO remove when Node v8 support drops\nvar doIter = global._MP_NO_ITERATOR_SYMBOLS_ !== '1';\nvar ASYNCITERATOR = doIter && Symbol.asyncIterator || Symbol('asyncIterator not implemented');\nvar ITERATOR = doIter && Symbol.iterator || Symbol('iterator not implemented');\n\n// events that mean 'the stream is over'\n// these are treated specially, and re-emitted\n// if they are listened for after emitting.\nvar isEndish = function isEndish(ev) {\n  return ev === 'end' || ev === 'finish' || ev === 'prefinish';\n};\nvar isArrayBuffer = function isArrayBuffer(b) {\n  return b instanceof ArrayBuffer || typeof b === 'object' && b.constructor && b.constructor.name === 'ArrayBuffer' && b.byteLength >= 0;\n};\nvar isArrayBufferView = function isArrayBufferView(b) {\n  return !Buffer.isBuffer(b) && ArrayBuffer.isView(b);\n};\nvar Pipe = /*#__PURE__*/function () {\n  function Pipe(src, dest, opts) {\n    _classCallCheck(this, Pipe);\n    this.src = src;\n    this.dest = dest;\n    this.opts = opts;\n    this.ondrain = function () {\n      return src[RESUME]();\n    };\n    dest.on('drain', this.ondrain);\n  }\n  _createClass(Pipe, [{\n    key: \"unpipe\",\n    value: function unpipe() {\n      this.dest.removeListener('drain', this.ondrain);\n    } // istanbul ignore next - only here for the prototype\n  }, {\n    key: \"proxyErrors\",\n    value: function proxyErrors() {}\n  }, {\n    key: \"end\",\n    value: function end() {\n      this.unpipe();\n      if (this.opts.end) this.dest.end();\n    }\n  }]);\n  return Pipe;\n}();\nvar PipeProxyErrors = /*#__PURE__*/function (_Pipe) {\n  _inherits(PipeProxyErrors, _Pipe);\n  _createClass(PipeProxyErrors, [{\n    key: \"unpipe\",\n    value: function unpipe() {\n      this.src.removeListener('error', this.proxyErrors);\n      _get(_getPrototypeOf(PipeProxyErrors.prototype), \"unpipe\", this).call(this);\n    }\n  }]);\n  function PipeProxyErrors(src, dest, opts) {\n    var _this;\n    _classCallCheck(this, PipeProxyErrors);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(PipeProxyErrors).call(this, src, dest, opts));\n    _this.proxyErrors = function (er) {\n      return dest.emit('error', er);\n    };\n    src.on('error', _this.proxyErrors);\n    return _this;\n  }\n  return PipeProxyErrors;\n}(Pipe);\nmodule.exports = /*#__PURE__*/function (_Stream) {\n  _inherits(Minipass, _Stream);\n  function Minipass(options) {\n    var _this2;\n    _classCallCheck(this, Minipass);\n    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(Minipass).call(this));\n    _this2[FLOWING] = false;\n    // whether we're explicitly paused\n    _this2[PAUSED] = false;\n    _this2.pipes = [];\n    _this2.buffer = [];\n    _this2[OBJECTMODE] = options && options.objectMode || false;\n    if (_this2[OBJECTMODE]) _this2[ENCODING] = null;else _this2[ENCODING] = options && options.encoding || null;\n    if (_this2[ENCODING] === 'buffer') _this2[ENCODING] = null;\n    _this2[ASYNC] = options && !!options.async || false;\n    _this2[DECODER] = _this2[ENCODING] ? new SD(_this2[ENCODING]) : null;\n    _this2[EOF] = false;\n    _this2[EMITTED_END] = false;\n    _this2[EMITTING_END] = false;\n    _this2[CLOSED] = false;\n    _this2[EMITTED_ERROR] = null;\n    _this2.writable = true;\n    _this2.readable = true;\n    _this2[BUFFERLENGTH] = 0;\n    _this2[DESTROYED] = false;\n    return _this2;\n  }\n  _createClass(Minipass, [{\n    key: \"setEncoding\",\n    value: function setEncoding(enc) {\n      this.encoding = enc;\n    }\n  }, {\n    key: \"write\",\n    value: function write(chunk, encoding, cb) {\n      if (this[EOF]) throw new Error('write after end');\n      if (this[DESTROYED]) {\n        this.emit('error', Object.assign(new Error('Cannot call write after a stream was destroyed'), {\n          code: 'ERR_STREAM_DESTROYED'\n        }));\n        return true;\n      }\n      if (typeof encoding === 'function') cb = encoding, encoding = 'utf8';\n      if (!encoding) encoding = 'utf8';\n      var fn = this[ASYNC] ? defer : function (f) {\n        return f();\n      };\n\n      // convert array buffers and typed array views into buffers\n      // at some point in the future, we may want to do the opposite!\n      // leave strings and buffers as-is\n      // anything else switches us into object mode\n      if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {\n        if (isArrayBufferView(chunk)) chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);else if (isArrayBuffer(chunk)) chunk = Buffer.from(chunk);else if (typeof chunk !== 'string')\n          // use the setter so we throw if we have encoding set\n          this.objectMode = true;\n      }\n\n      // handle object mode up front, since it's simpler\n      // this yields better performance, fewer checks later.\n      if (this[OBJECTMODE]) {\n        /* istanbul ignore if - maybe impossible? */\n        if (this.flowing && this[BUFFERLENGTH] !== 0) this[FLUSH](true);\n        if (this.flowing) this.emit('data', chunk);else this[BUFFERPUSH](chunk);\n        if (this[BUFFERLENGTH] !== 0) this.emit('readable');\n        if (cb) fn(cb);\n        return this.flowing;\n      }\n\n      // at this point the chunk is a buffer or string\n      // don't buffer it up or send it to the decoder\n      if (!chunk.length) {\n        if (this[BUFFERLENGTH] !== 0) this.emit('readable');\n        if (cb) fn(cb);\n        return this.flowing;\n      }\n\n      // fast-path writing strings of same encoding to a stream with\n      // an empty buffer, skipping the buffer/decoder dance\n      if (typeof chunk === 'string' &&\n      // unless it is a string already ready for us to use\n      !(encoding === this[ENCODING] && !this[DECODER].lastNeed)) {\n        chunk = Buffer.from(chunk, encoding);\n      }\n      if (Buffer.isBuffer(chunk) && this[ENCODING]) chunk = this[DECODER].write(chunk);\n\n      // Note: flushing CAN potentially switch us into not-flowing mode\n      if (this.flowing && this[BUFFERLENGTH] !== 0) this[FLUSH](true);\n      if (this.flowing) this.emit('data', chunk);else this[BUFFERPUSH](chunk);\n      if (this[BUFFERLENGTH] !== 0) this.emit('readable');\n      if (cb) fn(cb);\n      return this.flowing;\n    }\n  }, {\n    key: \"read\",\n    value: function read(n) {\n      if (this[DESTROYED]) return null;\n      if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH]) {\n        this[MAYBE_EMIT_END]();\n        return null;\n      }\n      if (this[OBJECTMODE]) n = null;\n      if (this.buffer.length > 1 && !this[OBJECTMODE]) {\n        if (this.encoding) this.buffer = [this.buffer.join('')];else this.buffer = [Buffer.concat(this.buffer, this[BUFFERLENGTH])];\n      }\n      var ret = this[READ](n || null, this.buffer[0]);\n      this[MAYBE_EMIT_END]();\n      return ret;\n    }\n  }, {\n    key: READ,\n    value: function value(n, chunk) {\n      if (n === chunk.length || n === null) this[BUFFERSHIFT]();else {\n        this.buffer[0] = chunk.slice(n);\n        chunk = chunk.slice(0, n);\n        this[BUFFERLENGTH] -= n;\n      }\n      this.emit('data', chunk);\n      if (!this.buffer.length && !this[EOF]) this.emit('drain');\n      return chunk;\n    }\n  }, {\n    key: \"end\",\n    value: function end(chunk, encoding, cb) {\n      if (typeof chunk === 'function') cb = chunk, chunk = null;\n      if (typeof encoding === 'function') cb = encoding, encoding = 'utf8';\n      if (chunk) this.write(chunk, encoding);\n      if (cb) this.once('end', cb);\n      this[EOF] = true;\n      this.writable = false;\n\n      // if we haven't written anything, then go ahead and emit,\n      // even if we're not reading.\n      // we'll re-emit if a new 'end' listener is added anyway.\n      // This makes MP more suitable to write-only use cases.\n      if (this.flowing || !this[PAUSED]) this[MAYBE_EMIT_END]();\n      return this;\n    } // don't let the internal resume be overwritten\n  }, {\n    key: RESUME,\n    value: function value() {\n      if (this[DESTROYED]) return;\n      this[PAUSED] = false;\n      this[FLOWING] = true;\n      this.emit('resume');\n      if (this.buffer.length) this[FLUSH]();else if (this[EOF]) this[MAYBE_EMIT_END]();else this.emit('drain');\n    }\n  }, {\n    key: \"resume\",\n    value: function resume() {\n      return this[RESUME]();\n    }\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      this[FLOWING] = false;\n      this[PAUSED] = true;\n    }\n  }, {\n    key: BUFFERPUSH,\n    value: function value(chunk) {\n      if (this[OBJECTMODE]) this[BUFFERLENGTH] += 1;else this[BUFFERLENGTH] += chunk.length;\n      this.buffer.push(chunk);\n    }\n  }, {\n    key: BUFFERSHIFT,\n    value: function value() {\n      if (this.buffer.length) {\n        if (this[OBJECTMODE]) this[BUFFERLENGTH] -= 1;else this[BUFFERLENGTH] -= this.buffer[0].length;\n      }\n      return this.buffer.shift();\n    }\n  }, {\n    key: FLUSH,\n    value: function value(noDrain) {\n      do {} while (this[FLUSHCHUNK](this[BUFFERSHIFT]()));\n      if (!noDrain && !this.buffer.length && !this[EOF]) this.emit('drain');\n    }\n  }, {\n    key: FLUSHCHUNK,\n    value: function value(chunk) {\n      return chunk ? (this.emit('data', chunk), this.flowing) : false;\n    }\n  }, {\n    key: \"pipe\",\n    value: function pipe(dest, opts) {\n      var _this3 = this;\n      if (this[DESTROYED]) return;\n      var ended = this[EMITTED_END];\n      opts = opts || {};\n      if (dest === proc.stdout || dest === proc.stderr) opts.end = false;else opts.end = opts.end !== false;\n      opts.proxyErrors = !!opts.proxyErrors;\n\n      // piping an ended stream ends immediately\n      if (ended) {\n        if (opts.end) dest.end();\n      } else {\n        this.pipes.push(!opts.proxyErrors ? new Pipe(this, dest, opts) : new PipeProxyErrors(this, dest, opts));\n        if (this[ASYNC]) defer(function () {\n          return _this3[RESUME]();\n        });else this[RESUME]();\n      }\n      return dest;\n    }\n  }, {\n    key: \"unpipe\",\n    value: function unpipe(dest) {\n      var p = this.pipes.find(function (p) {\n        return p.dest === dest;\n      });\n      if (p) {\n        this.pipes.splice(this.pipes.indexOf(p), 1);\n        p.unpipe();\n      }\n    }\n  }, {\n    key: \"addListener\",\n    value: function addListener(ev, fn) {\n      return this.on(ev, fn);\n    }\n  }, {\n    key: \"on\",\n    value: function on(ev, fn) {\n      var _this4 = this;\n      var ret = _get(_getPrototypeOf(Minipass.prototype), \"on\", this).call(this, ev, fn);\n      if (ev === 'data' && !this.pipes.length && !this.flowing) this[RESUME]();else if (ev === 'readable' && this[BUFFERLENGTH] !== 0) _get(_getPrototypeOf(Minipass.prototype), \"emit\", this).call(this, 'readable');else if (isEndish(ev) && this[EMITTED_END]) {\n        _get(_getPrototypeOf(Minipass.prototype), \"emit\", this).call(this, ev);\n        this.removeAllListeners(ev);\n      } else if (ev === 'error' && this[EMITTED_ERROR]) {\n        if (this[ASYNC]) defer(function () {\n          return fn.call(_this4, _this4[EMITTED_ERROR]);\n        });else fn.call(this, this[EMITTED_ERROR]);\n      }\n      return ret;\n    }\n  }, {\n    key: MAYBE_EMIT_END,\n    value: function value() {\n      if (!this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this.buffer.length === 0 && this[EOF]) {\n        this[EMITTING_END] = true;\n        this.emit('end');\n        this.emit('prefinish');\n        this.emit('finish');\n        if (this[CLOSED]) this.emit('close');\n        this[EMITTING_END] = false;\n      }\n    }\n  }, {\n    key: \"emit\",\n    value: function emit(ev, data) {\n      var _this5 = this,\n        _get2;\n      // error and close are only events allowed after calling destroy()\n      if (ev !== 'error' && ev !== 'close' && ev !== DESTROYED && this[DESTROYED]) return;else if (ev === 'data') {\n        return !data ? false : this[ASYNC] ? defer(function () {\n          return _this5[EMITDATA](data);\n        }) : this[EMITDATA](data);\n      } else if (ev === 'end') {\n        return this[EMITEND]();\n      } else if (ev === 'close') {\n        this[CLOSED] = true;\n        // don't emit close before 'end' and 'finish'\n        if (!this[EMITTED_END] && !this[DESTROYED]) return;\n        var _ret = _get(_getPrototypeOf(Minipass.prototype), \"emit\", this).call(this, 'close');\n        this.removeAllListeners('close');\n        return _ret;\n      } else if (ev === 'error') {\n        this[EMITTED_ERROR] = data;\n        var _ret2 = _get(_getPrototypeOf(Minipass.prototype), \"emit\", this).call(this, 'error', data);\n        this[MAYBE_EMIT_END]();\n        return _ret2;\n      } else if (ev === 'resume') {\n        var _ret3 = _get(_getPrototypeOf(Minipass.prototype), \"emit\", this).call(this, 'resume');\n        this[MAYBE_EMIT_END]();\n        return _ret3;\n      } else if (ev === 'finish' || ev === 'prefinish') {\n        var _ret4 = _get(_getPrototypeOf(Minipass.prototype), \"emit\", this).call(this, ev);\n        this.removeAllListeners(ev);\n        return _ret4;\n      }\n\n      // Some other unknown event\n      for (var _len = arguments.length, extra = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n        extra[_key - 2] = arguments[_key];\n      }\n      var ret = (_get2 = _get(_getPrototypeOf(Minipass.prototype), \"emit\", this)).call.apply(_get2, [this, ev, data].concat(extra));\n      this[MAYBE_EMIT_END]();\n      return ret;\n    }\n  }, {\n    key: EMITDATA,\n    value: function value(data) {\n      var _iterator = _createForOfIteratorHelper(this.pipes),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var p = _step.value;\n          if (p.dest.write(data) === false) this.pause();\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      var ret = _get(_getPrototypeOf(Minipass.prototype), \"emit\", this).call(this, 'data', data);\n      this[MAYBE_EMIT_END]();\n      return ret;\n    }\n  }, {\n    key: EMITEND,\n    value: function value() {\n      var _this6 = this;\n      if (this[EMITTED_END]) return;\n      this[EMITTED_END] = true;\n      this.readable = false;\n      if (this[ASYNC]) defer(function () {\n        return _this6[EMITEND2]();\n      });else this[EMITEND2]();\n    }\n  }, {\n    key: EMITEND2,\n    value: function value() {\n      if (this[DECODER]) {\n        var data = this[DECODER].end();\n        if (data) {\n          var _iterator2 = _createForOfIteratorHelper(this.pipes),\n            _step2;\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var p = _step2.value;\n              p.dest.write(data);\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n          _get(_getPrototypeOf(Minipass.prototype), \"emit\", this).call(this, 'data', data);\n        }\n      }\n      var _iterator3 = _createForOfIteratorHelper(this.pipes),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var _p = _step3.value;\n          _p.end();\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      var ret = _get(_getPrototypeOf(Minipass.prototype), \"emit\", this).call(this, 'end');\n      this.removeAllListeners('end');\n      return ret;\n    } // const all = await stream.collect()\n  }, {\n    key: \"collect\",\n    value: function collect() {\n      var _this7 = this;\n      var buf = [];\n      if (!this[OBJECTMODE]) buf.dataLength = 0;\n      // set the promise first, in case an error is raised\n      // by triggering the flow here.\n      var p = this.promise();\n      this.on('data', function (c) {\n        buf.push(c);\n        if (!_this7[OBJECTMODE]) buf.dataLength += c.length;\n      });\n      return p.then(function () {\n        return buf;\n      });\n    } // const data = await stream.concat()\n  }, {\n    key: \"concat\",\n    value: function concat() {\n      var _this8 = this;\n      return this[OBJECTMODE] ? Promise.reject(new Error('cannot concat in objectMode')) : this.collect().then(function (buf) {\n        return _this8[OBJECTMODE] ? Promise.reject(new Error('cannot concat in objectMode')) : _this8[ENCODING] ? buf.join('') : Buffer.concat(buf, buf.dataLength);\n      });\n    } // stream.promise().then(() => done, er => emitted error)\n  }, {\n    key: \"promise\",\n    value: function promise() {\n      var _this9 = this;\n      return new Promise(function (resolve, reject) {\n        _this9.on(DESTROYED, function () {\n          return reject(new Error('stream destroyed'));\n        });\n        _this9.on('error', function (er) {\n          return reject(er);\n        });\n        _this9.on('end', function () {\n          return resolve();\n        });\n      });\n    } // for await (let chunk of stream)\n  }, {\n    key: ASYNCITERATOR,\n    value: function value() {\n      var _this10 = this;\n      var next = function next() {\n        var res = _this10.read();\n        if (res !== null) return Promise.resolve({\n          done: false,\n          value: res\n        });\n        if (_this10[EOF]) return Promise.resolve({\n          done: true\n        });\n        var resolve = null;\n        var reject = null;\n        var onerr = function onerr(er) {\n          _this10.removeListener('data', ondata);\n          _this10.removeListener('end', onend);\n          reject(er);\n        };\n        var ondata = function ondata(value) {\n          _this10.removeListener('error', onerr);\n          _this10.removeListener('end', onend);\n          _this10.pause();\n          resolve({\n            value: value,\n            done: !!_this10[EOF]\n          });\n        };\n        var onend = function onend() {\n          _this10.removeListener('error', onerr);\n          _this10.removeListener('data', ondata);\n          resolve({\n            done: true\n          });\n        };\n        var ondestroy = function ondestroy() {\n          return onerr(new Error('stream destroyed'));\n        };\n        return new Promise(function (res, rej) {\n          reject = rej;\n          resolve = res;\n          _this10.once(DESTROYED, ondestroy);\n          _this10.once('error', onerr);\n          _this10.once('end', onend);\n          _this10.once('data', ondata);\n        });\n      };\n      return {\n        next: next\n      };\n    } // for (let chunk of stream)\n  }, {\n    key: ITERATOR,\n    value: function value() {\n      var _this11 = this;\n      var next = function next() {\n        var value = _this11.read();\n        var done = value === null;\n        return {\n          value: value,\n          done: done\n        };\n      };\n      return {\n        next: next\n      };\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy(er) {\n      if (this[DESTROYED]) {\n        if (er) this.emit('error', er);else this.emit(DESTROYED);\n        return this;\n      }\n      this[DESTROYED] = true;\n\n      // throw away all buffered data, it's never coming out\n      this.buffer.length = 0;\n      this[BUFFERLENGTH] = 0;\n      if (typeof this.close === 'function' && !this[CLOSED]) this.close();\n      if (er) this.emit('error', er);else\n        // if no error to emit, still reject pending promises\n        this.emit(DESTROYED);\n      return this;\n    }\n  }, {\n    key: \"bufferLength\",\n    get: function get() {\n      return this[BUFFERLENGTH];\n    }\n  }, {\n    key: \"encoding\",\n    get: function get() {\n      return this[ENCODING];\n    },\n    set: function set(enc) {\n      var _this12 = this;\n      if (this[OBJECTMODE]) throw new Error('cannot set encoding in objectMode');\n      if (this[ENCODING] && enc !== this[ENCODING] && (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH])) throw new Error('cannot change encoding');\n      if (this[ENCODING] !== enc) {\n        this[DECODER] = enc ? new SD(enc) : null;\n        if (this.buffer.length) this.buffer = this.buffer.map(function (chunk) {\n          return _this12[DECODER].write(chunk);\n        });\n      }\n      this[ENCODING] = enc;\n    }\n  }, {\n    key: \"objectMode\",\n    get: function get() {\n      return this[OBJECTMODE];\n    },\n    set: function set(om) {\n      this[OBJECTMODE] = this[OBJECTMODE] || !!om;\n    }\n  }, {\n    key: 'async',\n    get: function get() {\n      return this[ASYNC];\n    },\n    set: function set(a) {\n      this[ASYNC] = this[ASYNC] || !!a;\n    }\n  }, {\n    key: \"destroyed\",\n    get: function get() {\n      return this[DESTROYED];\n    }\n  }, {\n    key: \"flowing\",\n    get: function get() {\n      return this[FLOWING];\n    }\n  }, {\n    key: \"paused\",\n    get: function get() {\n      return this[PAUSED];\n    }\n  }, {\n    key: \"emittedEnd\",\n    get: function get() {\n      return this[EMITTED_END];\n    }\n  }], [{\n    key: \"isStream\",\n    value: function isStream(s) {\n      return !!s && (s instanceof Minipass || s instanceof Stream || s instanceof EE && (typeof s.pipe === 'function' ||\n      // readable\n      typeof s.write === 'function' && typeof s.end === 'function' // writable\n      ));\n    }\n  }]);\n  return Minipass;\n}(Stream);","map":null,"metadata":{},"sourceType":"script"}