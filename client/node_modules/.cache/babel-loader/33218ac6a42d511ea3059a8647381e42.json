{"ast":null,"code":"'use strict';\n\n// XXX: This shares a lot in common with extract.js\n// maybe some DRY opportunity here?\n\n// tar -t\nvar hlo = require('./high-level-opt.js');\nvar Parser = require('./parse.js');\nvar fs = require('fs');\nvar fsm = require('fs-minipass');\nvar path = require('path');\nvar stripSlash = require('./strip-trailing-slashes.js');\nmodule.exports = function (opt_, files, cb) {\n  if (typeof opt_ === 'function') {\n    cb = opt_, files = null, opt_ = {};\n  } else if (Array.isArray(opt_)) {\n    files = opt_, opt_ = {};\n  }\n  if (typeof files === 'function') {\n    cb = files, files = null;\n  }\n  if (!files) {\n    files = [];\n  } else {\n    files = Array.from(files);\n  }\n  var opt = hlo(opt_);\n  if (opt.sync && typeof cb === 'function') {\n    throw new TypeError('callback not supported for sync tar functions');\n  }\n  if (!opt.file && typeof cb === 'function') {\n    throw new TypeError('callback only supported with file option');\n  }\n  if (files.length) {\n    filesFilter(opt, files);\n  }\n  if (!opt.noResume) {\n    onentryFunction(opt);\n  }\n  return opt.file && opt.sync ? listFileSync(opt) : opt.file ? listFile(opt, cb) : list(opt);\n};\nvar onentryFunction = function onentryFunction(opt) {\n  var onentry = opt.onentry;\n  opt.onentry = onentry ? function (e) {\n    onentry(e);\n    e.resume();\n  } : function (e) {\n    return e.resume();\n  };\n};\n\n// construct a filter that limits the file entries listed\n// include child entries if a dir is included\nvar filesFilter = function filesFilter(opt, files) {\n  var map = new Map(files.map(function (f) {\n    return [stripSlash(f), true];\n  }));\n  var filter = opt.filter;\n  var mapHas = function mapHas(file, r) {\n    var root = r || path.parse(file).root || '.';\n    var ret = file === root ? false : map.has(file) ? map.get(file) : mapHas(path.dirname(file), root);\n    map.set(file, ret);\n    return ret;\n  };\n  opt.filter = filter ? function (file, entry) {\n    return filter(file, entry) && mapHas(stripSlash(file));\n  } : function (file) {\n    return mapHas(stripSlash(file));\n  };\n};\nvar listFileSync = function listFileSync(opt) {\n  var p = list(opt);\n  var file = opt.file;\n  var threw = true;\n  var fd;\n  try {\n    var stat = fs.statSync(file);\n    var readSize = opt.maxReadSize || 16 * 1024 * 1024;\n    if (stat.size < readSize) {\n      p.end(fs.readFileSync(file));\n    } else {\n      var pos = 0;\n      var buf = Buffer.allocUnsafe(readSize);\n      fd = fs.openSync(file, 'r');\n      while (pos < stat.size) {\n        var bytesRead = fs.readSync(fd, buf, 0, readSize, pos);\n        pos += bytesRead;\n        p.write(buf.slice(0, bytesRead));\n      }\n      p.end();\n    }\n    threw = false;\n  } finally {\n    if (threw && fd) {\n      try {\n        fs.closeSync(fd);\n      } catch (er) {}\n    }\n  }\n};\nvar listFile = function listFile(opt, cb) {\n  var parse = new Parser(opt);\n  var readSize = opt.maxReadSize || 16 * 1024 * 1024;\n  var file = opt.file;\n  var p = new Promise(function (resolve, reject) {\n    parse.on('error', reject);\n    parse.on('end', resolve);\n    fs.stat(file, function (er, stat) {\n      if (er) {\n        reject(er);\n      } else {\n        var stream = new fsm.ReadStream(file, {\n          readSize: readSize,\n          size: stat.size\n        });\n        stream.on('error', reject);\n        stream.pipe(parse);\n      }\n    });\n  });\n  return cb ? p.then(cb, cb) : p;\n};\nvar list = function list(opt) {\n  return new Parser(opt);\n};","map":null,"metadata":{},"sourceType":"script"}