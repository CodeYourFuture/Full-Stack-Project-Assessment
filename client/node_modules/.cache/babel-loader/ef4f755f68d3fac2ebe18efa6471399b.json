{"ast":null,"code":"import { useEffect } from 'react';\nimport useCommittedRef from './useCommittedRef';\n/**\n * Creates a `setInterval` that is properly cleaned up when a component unmounted\n *\n * ```tsx\n *  function Timer() {\n *    const [timer, setTimer] = useState(0)\n *    useInterval(() => setTimer(i => i + 1), 1000)\n *\n *    return <span>{timer} seconds past</span>\n *  }\n * ```\n *\n * @param fn an function run on each interval\n * @param ms The milliseconds duration of the interval\n */\n\n/**\n * Creates a pausable `setInterval` that is properly cleaned up when a component unmounted\n *\n * ```tsx\n *  const [paused, setPaused] = useState(false)\n *  const [timer, setTimer] = useState(0)\n *\n *  useInterval(() => setTimer(i => i + 1), 1000, paused)\n *\n *  return (\n *    <span>\n *      {timer} seconds past\n *\n *      <button onClick={() => setPaused(p => !p)}>{paused ? 'Play' : 'Pause' }</button>\n *    </span>\n * )\n * ```\n *\n * @param fn an function run on each interval\n * @param ms The milliseconds duration of the interval\n * @param paused Whether or not the interval is currently running\n */\n\n/**\n * Creates a pausable `setInterval` that _fires_ immediately and is\n * properly cleaned up when a component unmounted\n *\n * ```tsx\n *  const [timer, setTimer] = useState(-1)\n *  useInterval(() => setTimer(i => i + 1), 1000, false, true)\n *\n *  // will update to 0 on the first effect\n *  return <span>{timer} seconds past</span>\n * ```\n *\n * @param fn an function run on each interval\n * @param ms The milliseconds duration of the interval\n * @param paused Whether or not the interval is currently running\n * @param runImmediately Whether to run the function immediately on mount or unpause\n * rather than waiting for the first interval to elapse\n *\n\n */\n\nfunction useInterval(fn, ms) {\n  let paused = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  let runImmediately = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  let handle;\n  const fnRef = useCommittedRef(fn); // this ref is necessary b/c useEffect will sometimes miss a paused toggle\n  // orphaning a setTimeout chain in the aether, so relying on it's refresh logic is not reliable.\n\n  const pausedRef = useCommittedRef(paused);\n\n  const tick = () => {\n    if (pausedRef.current) return;\n    fnRef.current();\n    schedule(); // eslint-disable-line no-use-before-define\n  };\n\n  const schedule = () => {\n    clearTimeout(handle);\n    handle = setTimeout(tick, ms);\n  };\n\n  useEffect(() => {\n    if (runImmediately) {\n      tick();\n    } else {\n      schedule();\n    }\n\n    return () => clearTimeout(handle);\n  }, [paused, runImmediately]);\n}\n\nexport default useInterval;","map":{"version":3,"sources":["/home/coder/CYF/react-learn/Full-Stack-Project-Assessment/client/node_modules/@restart/hooks/esm/useInterval.js"],"names":["useEffect","useCommittedRef","useInterval","fn","ms","paused","runImmediately","handle","fnRef","pausedRef","tick","current","schedule","clearTimeout","setTimeout"],"mappings":"AAAA,SAASA,SAAT,QAA0B,OAA1B;AACA,OAAOC,eAAP,MAA4B,mBAA5B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASC,WAAT,CAAqBC,EAArB,EAAyBC,EAAzB,EAAqE;AAAA,MAAxCC,MAAwC,uEAA/B,KAA+B;AAAA,MAAxBC,cAAwB,uEAAP,KAAO;AACnE,MAAIC,MAAJ;AACA,QAAMC,KAAK,GAAGP,eAAe,CAACE,EAAD,CAA7B,CAFmE,CAGnE;AACA;;AACA,QAAMM,SAAS,GAAGR,eAAe,CAACI,MAAD,CAAjC;;AACA,QAAMK,IAAI,GAAG,MAAM;AACjB,QAAID,SAAS,CAACE,OAAd,EAAuB;AACvBH,IAAAA,KAAK,CAACG,OAAN;AACAC,IAAAA,QAAQ,GAHS,CAGL;AACb,GAJD;;AAMA,QAAMA,QAAQ,GAAG,MAAM;AACrBC,IAAAA,YAAY,CAACN,MAAD,CAAZ;AACAA,IAAAA,MAAM,GAAGO,UAAU,CAACJ,IAAD,EAAON,EAAP,CAAnB;AACD,GAHD;;AAIAJ,EAAAA,SAAS,CAAC,MAAM;AACd,QAAIM,cAAJ,EAAoB;AAClBI,MAAAA,IAAI;AACL,KAFD,MAEO;AACLE,MAAAA,QAAQ;AACT;;AACD,WAAO,MAAMC,YAAY,CAACN,MAAD,CAAzB;AACD,GAPQ,EAON,CAACF,MAAD,EAASC,cAAT,CAPM,CAAT;AAQD;;AACD,eAAeJ,WAAf","sourcesContent":["import { useEffect } from 'react';\nimport useCommittedRef from './useCommittedRef';\n\n/**\n * Creates a `setInterval` that is properly cleaned up when a component unmounted\n *\n * ```tsx\n *  function Timer() {\n *    const [timer, setTimer] = useState(0)\n *    useInterval(() => setTimer(i => i + 1), 1000)\n *\n *    return <span>{timer} seconds past</span>\n *  }\n * ```\n *\n * @param fn an function run on each interval\n * @param ms The milliseconds duration of the interval\n */\n\n/**\n * Creates a pausable `setInterval` that is properly cleaned up when a component unmounted\n *\n * ```tsx\n *  const [paused, setPaused] = useState(false)\n *  const [timer, setTimer] = useState(0)\n *\n *  useInterval(() => setTimer(i => i + 1), 1000, paused)\n *\n *  return (\n *    <span>\n *      {timer} seconds past\n *\n *      <button onClick={() => setPaused(p => !p)}>{paused ? 'Play' : 'Pause' }</button>\n *    </span>\n * )\n * ```\n *\n * @param fn an function run on each interval\n * @param ms The milliseconds duration of the interval\n * @param paused Whether or not the interval is currently running\n */\n\n/**\n * Creates a pausable `setInterval` that _fires_ immediately and is\n * properly cleaned up when a component unmounted\n *\n * ```tsx\n *  const [timer, setTimer] = useState(-1)\n *  useInterval(() => setTimer(i => i + 1), 1000, false, true)\n *\n *  // will update to 0 on the first effect\n *  return <span>{timer} seconds past</span>\n * ```\n *\n * @param fn an function run on each interval\n * @param ms The milliseconds duration of the interval\n * @param paused Whether or not the interval is currently running\n * @param runImmediately Whether to run the function immediately on mount or unpause\n * rather than waiting for the first interval to elapse\n *\n\n */\n\nfunction useInterval(fn, ms, paused = false, runImmediately = false) {\n  let handle;\n  const fnRef = useCommittedRef(fn);\n  // this ref is necessary b/c useEffect will sometimes miss a paused toggle\n  // orphaning a setTimeout chain in the aether, so relying on it's refresh logic is not reliable.\n  const pausedRef = useCommittedRef(paused);\n  const tick = () => {\n    if (pausedRef.current) return;\n    fnRef.current();\n    schedule(); // eslint-disable-line no-use-before-define\n  };\n\n  const schedule = () => {\n    clearTimeout(handle);\n    handle = setTimeout(tick, ms);\n  };\n  useEffect(() => {\n    if (runImmediately) {\n      tick();\n    } else {\n      schedule();\n    }\n    return () => clearTimeout(handle);\n  }, [paused, runImmediately]);\n}\nexport default useInterval;"]},"metadata":{},"sourceType":"module"}