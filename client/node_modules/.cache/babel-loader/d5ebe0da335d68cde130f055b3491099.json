{"ast":null,"code":"'use strict';\n\n// the PEND/UNPEND stuff tracks whether we're ready to emit end/close yet.\n// but the path reservations are required to avoid race conditions where\n// parallelized unpack ops may mess with one another, due to dependencies\n// (like a Link depending on its target) or destructive operations (like\n// clobbering an fs object to create one of a different type.)\nvar _slicedToArray = require(\"C:\\\\Users\\\\cuney\\\\OneDrive\\\\Belgeler\\\\GitHub\\\\Full-Stack-Project-Assessment\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\nvar _classCallCheck = require(\"C:\\\\Users\\\\cuney\\\\OneDrive\\\\Belgeler\\\\GitHub\\\\Full-Stack-Project-Assessment\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\nvar _createClass = require(\"C:\\\\Users\\\\cuney\\\\OneDrive\\\\Belgeler\\\\GitHub\\\\Full-Stack-Project-Assessment\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\nvar _possibleConstructorReturn = require(\"C:\\\\Users\\\\cuney\\\\OneDrive\\\\Belgeler\\\\GitHub\\\\Full-Stack-Project-Assessment\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\nvar _get = require(\"C:\\\\Users\\\\cuney\\\\OneDrive\\\\Belgeler\\\\GitHub\\\\Full-Stack-Project-Assessment\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/get\");\nvar _getPrototypeOf = require(\"C:\\\\Users\\\\cuney\\\\OneDrive\\\\Belgeler\\\\GitHub\\\\Full-Stack-Project-Assessment\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\nvar _inherits = require(\"C:\\\\Users\\\\cuney\\\\OneDrive\\\\Belgeler\\\\GitHub\\\\Full-Stack-Project-Assessment\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nvar assert = require('assert');\nvar Parser = require('./parse.js');\nvar fs = require('fs');\nvar fsm = require('fs-minipass');\nvar path = require('path');\nvar mkdir = require('./mkdir.js');\nvar wc = require('./winchars.js');\nvar pathReservations = require('./path-reservations.js');\nvar stripAbsolutePath = require('./strip-absolute-path.js');\nvar normPath = require('./normalize-windows-path.js');\nvar stripSlash = require('./strip-trailing-slashes.js');\nvar normalize = require('./normalize-unicode.js');\nvar ONENTRY = Symbol('onEntry');\nvar CHECKFS = Symbol('checkFs');\nvar CHECKFS2 = Symbol('checkFs2');\nvar PRUNECACHE = Symbol('pruneCache');\nvar ISREUSABLE = Symbol('isReusable');\nvar MAKEFS = Symbol('makeFs');\nvar FILE = Symbol('file');\nvar DIRECTORY = Symbol('directory');\nvar LINK = Symbol('link');\nvar SYMLINK = Symbol('symlink');\nvar HARDLINK = Symbol('hardlink');\nvar UNSUPPORTED = Symbol('unsupported');\nvar CHECKPATH = Symbol('checkPath');\nvar MKDIR = Symbol('mkdir');\nvar ONERROR = Symbol('onError');\nvar PENDING = Symbol('pending');\nvar PEND = Symbol('pend');\nvar UNPEND = Symbol('unpend');\nvar ENDED = Symbol('ended');\nvar MAYBECLOSE = Symbol('maybeClose');\nvar SKIP = Symbol('skip');\nvar DOCHOWN = Symbol('doChown');\nvar UID = Symbol('uid');\nvar GID = Symbol('gid');\nvar CHECKED_CWD = Symbol('checkedCwd');\nvar crypto = require('crypto');\nvar getFlag = require('./get-write-flag.js');\nvar platform = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform;\nvar isWindows = platform === 'win32';\n\n// Unlinks on Windows are not atomic.\n//\n// This means that if you have a file entry, followed by another\n// file entry with an identical name, and you cannot re-use the file\n// (because it's a hardlink, or because unlink:true is set, or it's\n// Windows, which does not have useful nlink values), then the unlink\n// will be committed to the disk AFTER the new file has been written\n// over the old one, deleting the new file.\n//\n// To work around this, on Windows systems, we rename the file and then\n// delete the renamed file.  It's a sloppy kludge, but frankly, I do not\n// know of a better way to do this, given windows' non-atomic unlink\n// semantics.\n//\n// See: https://github.com/npm/node-tar/issues/183\n/* istanbul ignore next */\nvar unlinkFile = function unlinkFile(path, cb) {\n  if (!isWindows) {\n    return fs.unlink(path, cb);\n  }\n  var name = path + '.DELETE.' + crypto.randomBytes(16).toString('hex');\n  fs.rename(path, name, function (er) {\n    if (er) {\n      return cb(er);\n    }\n    fs.unlink(name, cb);\n  });\n};\n\n/* istanbul ignore next */\nvar unlinkFileSync = function unlinkFileSync(path) {\n  if (!isWindows) {\n    return fs.unlinkSync(path);\n  }\n  var name = path + '.DELETE.' + crypto.randomBytes(16).toString('hex');\n  fs.renameSync(path, name);\n  fs.unlinkSync(name);\n};\n\n// this.gid, entry.gid, this.processUid\nvar uint32 = function uint32(a, b, c) {\n  return a === a >>> 0 ? a : b === b >>> 0 ? b : c;\n};\n\n// clear the cache if it's a case-insensitive unicode-squashing match.\n// we can't know if the current file system is case-sensitive or supports\n// unicode fully, so we check for similarity on the maximally compatible\n// representation.  Err on the side of pruning, since all it's doing is\n// preventing lstats, and it's not the end of the world if we get a false\n// positive.\n// Note that on windows, we always drop the entire cache whenever a\n// symbolic link is encountered, because 8.3 filenames are impossible\n// to reason about, and collisions are hazards rather than just failures.\nvar cacheKeyNormalize = function cacheKeyNormalize(path) {\n  return normalize(stripSlash(normPath(path))).toLowerCase();\n};\nvar pruneCache = function pruneCache(cache, abs) {\n  abs = cacheKeyNormalize(abs);\n  var _iterator = _createForOfIteratorHelper(cache.keys()),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _path = _step.value;\n      var pnorm = cacheKeyNormalize(_path);\n      if (pnorm === abs || pnorm.indexOf(abs + '/') === 0) {\n        cache.delete(_path);\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n};\nvar dropCache = function dropCache(cache) {\n  var _iterator2 = _createForOfIteratorHelper(cache.keys()),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var key = _step2.value;\n      cache.delete(key);\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n};\nvar Unpack = /*#__PURE__*/function (_Parser) {\n  _inherits(Unpack, _Parser);\n  function Unpack(opt) {\n    var _this;\n    _classCallCheck(this, Unpack);\n    if (!opt) {\n      opt = {};\n    }\n    opt.ondone = function (_) {\n      _this[ENDED] = true;\n      _this[MAYBECLOSE]();\n    };\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Unpack).call(this, opt));\n    _this[CHECKED_CWD] = false;\n    _this.reservations = pathReservations();\n    _this.transform = typeof opt.transform === 'function' ? opt.transform : null;\n    _this.writable = true;\n    _this.readable = false;\n    _this[PENDING] = 0;\n    _this[ENDED] = false;\n    _this.dirCache = opt.dirCache || new Map();\n    if (typeof opt.uid === 'number' || typeof opt.gid === 'number') {\n      // need both or neither\n      if (typeof opt.uid !== 'number' || typeof opt.gid !== 'number') {\n        throw new TypeError('cannot set owner without number uid and gid');\n      }\n      if (opt.preserveOwner) {\n        throw new TypeError('cannot preserve owner in archive and also set owner explicitly');\n      }\n      _this.uid = opt.uid;\n      _this.gid = opt.gid;\n      _this.setOwner = true;\n    } else {\n      _this.uid = null;\n      _this.gid = null;\n      _this.setOwner = false;\n    }\n\n    // default true for root\n    if (opt.preserveOwner === undefined && typeof opt.uid !== 'number') {\n      _this.preserveOwner = process.getuid && process.getuid() === 0;\n    } else {\n      _this.preserveOwner = !!opt.preserveOwner;\n    }\n    _this.processUid = (_this.preserveOwner || _this.setOwner) && process.getuid ? process.getuid() : null;\n    _this.processGid = (_this.preserveOwner || _this.setOwner) && process.getgid ? process.getgid() : null;\n\n    // mostly just for testing, but useful in some cases.\n    // Forcibly trigger a chown on every entry, no matter what\n    _this.forceChown = opt.forceChown === true;\n\n    // turn ><?| in filenames into 0xf000-higher encoded forms\n    _this.win32 = !!opt.win32 || isWindows;\n\n    // do not unpack over files that are newer than what's in the archive\n    _this.newer = !!opt.newer;\n\n    // do not unpack over ANY files\n    _this.keep = !!opt.keep;\n\n    // do not set mtime/atime of extracted entries\n    _this.noMtime = !!opt.noMtime;\n\n    // allow .., absolute path entries, and unpacking through symlinks\n    // without this, warn and skip .., relativize absolutes, and error\n    // on symlinks in extraction path\n    _this.preservePaths = !!opt.preservePaths;\n\n    // unlink files and links before writing. This breaks existing hard\n    // links, and removes symlink directories rather than erroring\n    _this.unlink = !!opt.unlink;\n    _this.cwd = normPath(path.resolve(opt.cwd || process.cwd()));\n    _this.strip = +opt.strip || 0;\n    // if we're not chmodding, then we don't need the process umask\n    _this.processUmask = opt.noChmod ? 0 : process.umask();\n    _this.umask = typeof opt.umask === 'number' ? opt.umask : _this.processUmask;\n\n    // default mode for dirs created as parents\n    _this.dmode = opt.dmode || 511 & ~_this.umask;\n    _this.fmode = opt.fmode || 438 & ~_this.umask;\n    _this.on('entry', function (entry) {\n      return _this[ONENTRY](entry);\n    });\n    return _this;\n  }\n\n  // a bad or damaged archive is a warning for Parser, but an error\n  // when extracting.  Mark those errors as unrecoverable, because\n  // the Unpack contract cannot be met.\n  _createClass(Unpack, [{\n    key: \"warn\",\n    value: function warn(code, msg) {\n      var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      if (code === 'TAR_BAD_ARCHIVE' || code === 'TAR_ABORT') {\n        data.recoverable = false;\n      }\n      return _get(_getPrototypeOf(Unpack.prototype), \"warn\", this).call(this, code, msg, data);\n    }\n  }, {\n    key: MAYBECLOSE,\n    value: function value() {\n      if (this[ENDED] && this[PENDING] === 0) {\n        this.emit('prefinish');\n        this.emit('finish');\n        this.emit('end');\n      }\n    }\n  }, {\n    key: CHECKPATH,\n    value: function value(entry) {\n      if (this.strip) {\n        var parts = normPath(entry.path).split('/');\n        if (parts.length < this.strip) {\n          return false;\n        }\n        entry.path = parts.slice(this.strip).join('/');\n        if (entry.type === 'Link') {\n          var linkparts = normPath(entry.linkpath).split('/');\n          if (linkparts.length >= this.strip) {\n            entry.linkpath = linkparts.slice(this.strip).join('/');\n          } else {\n            return false;\n          }\n        }\n      }\n      if (!this.preservePaths) {\n        var p = normPath(entry.path);\n        var _parts = p.split('/');\n        if (_parts.includes('..') || isWindows && /^[a-z]:\\.\\.$/i.test(_parts[0])) {\n          this.warn('TAR_ENTRY_ERROR', \"path contains '..'\", {\n            entry: entry,\n            path: p\n          });\n          return false;\n        }\n\n        // strip off the root\n        var _stripAbsolutePath = stripAbsolutePath(p),\n          _stripAbsolutePath2 = _slicedToArray(_stripAbsolutePath, 2),\n          root = _stripAbsolutePath2[0],\n          stripped = _stripAbsolutePath2[1];\n        if (root) {\n          entry.path = stripped;\n          this.warn('TAR_ENTRY_INFO', \"stripping \".concat(root, \" from absolute path\"), {\n            entry: entry,\n            path: p\n          });\n        }\n      }\n      if (path.isAbsolute(entry.path)) {\n        entry.absolute = normPath(path.resolve(entry.path));\n      } else {\n        entry.absolute = normPath(path.resolve(this.cwd, entry.path));\n      }\n\n      // if we somehow ended up with a path that escapes the cwd, and we are\n      // not in preservePaths mode, then something is fishy!  This should have\n      // been prevented above, so ignore this for coverage.\n      /* istanbul ignore if - defense in depth */\n      if (!this.preservePaths && entry.absolute.indexOf(this.cwd + '/') !== 0 && entry.absolute !== this.cwd) {\n        this.warn('TAR_ENTRY_ERROR', 'path escaped extraction target', {\n          entry: entry,\n          path: normPath(entry.path),\n          resolvedPath: entry.absolute,\n          cwd: this.cwd\n        });\n        return false;\n      }\n\n      // an archive can set properties on the extraction directory, but it\n      // may not replace the cwd with a different kind of thing entirely.\n      if (entry.absolute === this.cwd && entry.type !== 'Directory' && entry.type !== 'GNUDumpDir') {\n        return false;\n      }\n\n      // only encode : chars that aren't drive letter indicators\n      if (this.win32) {\n        var _path$win32$parse = path.win32.parse(entry.absolute),\n          aRoot = _path$win32$parse.root;\n        entry.absolute = aRoot + wc.encode(entry.absolute.slice(aRoot.length));\n        var _path$win32$parse2 = path.win32.parse(entry.path),\n          pRoot = _path$win32$parse2.root;\n        entry.path = pRoot + wc.encode(entry.path.slice(pRoot.length));\n      }\n      return true;\n    }\n  }, {\n    key: ONENTRY,\n    value: function value(entry) {\n      if (!this[CHECKPATH](entry)) {\n        return entry.resume();\n      }\n      assert.equal(typeof entry.absolute, 'string');\n      switch (entry.type) {\n        case 'Directory':\n        case 'GNUDumpDir':\n          if (entry.mode) {\n            entry.mode = entry.mode | 448;\n          }\n\n        // eslint-disable-next-line no-fallthrough\n        case 'File':\n        case 'OldFile':\n        case 'ContiguousFile':\n        case 'Link':\n        case 'SymbolicLink':\n          return this[CHECKFS](entry);\n        case 'CharacterDevice':\n        case 'BlockDevice':\n        case 'FIFO':\n        default:\n          return this[UNSUPPORTED](entry);\n      }\n    }\n  }, {\n    key: ONERROR,\n    value: function value(er, entry) {\n      // Cwd has to exist, or else nothing works. That's serious.\n      // Other errors are warnings, which raise the error in strict\n      // mode, but otherwise continue on.\n      if (er.name === 'CwdError') {\n        this.emit('error', er);\n      } else {\n        this.warn('TAR_ENTRY_ERROR', er, {\n          entry: entry\n        });\n        this[UNPEND]();\n        entry.resume();\n      }\n    }\n  }, {\n    key: MKDIR,\n    value: function value(dir, mode, cb) {\n      mkdir(normPath(dir), {\n        uid: this.uid,\n        gid: this.gid,\n        processUid: this.processUid,\n        processGid: this.processGid,\n        umask: this.processUmask,\n        preserve: this.preservePaths,\n        unlink: this.unlink,\n        cache: this.dirCache,\n        cwd: this.cwd,\n        mode: mode,\n        noChmod: this.noChmod\n      }, cb);\n    }\n  }, {\n    key: DOCHOWN,\n    value: function value(entry) {\n      // in preserve owner mode, chown if the entry doesn't match process\n      // in set owner mode, chown if setting doesn't match process\n      return this.forceChown || this.preserveOwner && (typeof entry.uid === 'number' && entry.uid !== this.processUid || typeof entry.gid === 'number' && entry.gid !== this.processGid) || typeof this.uid === 'number' && this.uid !== this.processUid || typeof this.gid === 'number' && this.gid !== this.processGid;\n    }\n  }, {\n    key: UID,\n    value: function value(entry) {\n      return uint32(this.uid, entry.uid, this.processUid);\n    }\n  }, {\n    key: GID,\n    value: function value(entry) {\n      return uint32(this.gid, entry.gid, this.processGid);\n    }\n  }, {\n    key: FILE,\n    value: function value(entry, fullyDone) {\n      var _this2 = this;\n      var mode = entry.mode & 4095 || this.fmode;\n      var stream = new fsm.WriteStream(entry.absolute, {\n        flags: getFlag(entry.size),\n        mode: mode,\n        autoClose: false\n      });\n      stream.on('error', function (er) {\n        if (stream.fd) {\n          fs.close(stream.fd, function () {});\n        }\n\n        // flush all the data out so that we aren't left hanging\n        // if the error wasn't actually fatal.  otherwise the parse\n        // is blocked, and we never proceed.\n        stream.write = function () {\n          return true;\n        };\n        _this2[ONERROR](er, entry);\n        fullyDone();\n      });\n      var actions = 1;\n      var done = function done(er) {\n        if (er) {\n          /* istanbul ignore else - we should always have a fd by now */\n          if (stream.fd) {\n            fs.close(stream.fd, function () {});\n          }\n          _this2[ONERROR](er, entry);\n          fullyDone();\n          return;\n        }\n        if (--actions === 0) {\n          fs.close(stream.fd, function (er) {\n            if (er) {\n              _this2[ONERROR](er, entry);\n            } else {\n              _this2[UNPEND]();\n            }\n            fullyDone();\n          });\n        }\n      };\n      stream.on('finish', function (_) {\n        // if futimes fails, try utimes\n        // if utimes fails, fail with the original error\n        // same for fchown/chown\n        var abs = entry.absolute;\n        var fd = stream.fd;\n        if (entry.mtime && !_this2.noMtime) {\n          actions++;\n          var atime = entry.atime || new Date();\n          var mtime = entry.mtime;\n          fs.futimes(fd, atime, mtime, function (er) {\n            return er ? fs.utimes(abs, atime, mtime, function (er2) {\n              return done(er2 && er);\n            }) : done();\n          });\n        }\n        if (_this2[DOCHOWN](entry)) {\n          actions++;\n          var uid = _this2[UID](entry);\n          var gid = _this2[GID](entry);\n          fs.fchown(fd, uid, gid, function (er) {\n            return er ? fs.chown(abs, uid, gid, function (er2) {\n              return done(er2 && er);\n            }) : done();\n          });\n        }\n        done();\n      });\n      var tx = this.transform ? this.transform(entry) || entry : entry;\n      if (tx !== entry) {\n        tx.on('error', function (er) {\n          _this2[ONERROR](er, entry);\n          fullyDone();\n        });\n        entry.pipe(tx);\n      }\n      tx.pipe(stream);\n    }\n  }, {\n    key: DIRECTORY,\n    value: function value(entry, fullyDone) {\n      var _this3 = this;\n      var mode = entry.mode & 4095 || this.dmode;\n      this[MKDIR](entry.absolute, mode, function (er) {\n        if (er) {\n          _this3[ONERROR](er, entry);\n          fullyDone();\n          return;\n        }\n        var actions = 1;\n        var done = function done(_) {\n          if (--actions === 0) {\n            fullyDone();\n            _this3[UNPEND]();\n            entry.resume();\n          }\n        };\n        if (entry.mtime && !_this3.noMtime) {\n          actions++;\n          fs.utimes(entry.absolute, entry.atime || new Date(), entry.mtime, done);\n        }\n        if (_this3[DOCHOWN](entry)) {\n          actions++;\n          fs.chown(entry.absolute, _this3[UID](entry), _this3[GID](entry), done);\n        }\n        done();\n      });\n    }\n  }, {\n    key: UNSUPPORTED,\n    value: function value(entry) {\n      entry.unsupported = true;\n      this.warn('TAR_ENTRY_UNSUPPORTED', \"unsupported entry type: \".concat(entry.type), {\n        entry: entry\n      });\n      entry.resume();\n    }\n  }, {\n    key: SYMLINK,\n    value: function value(entry, done) {\n      this[LINK](entry, entry.linkpath, 'symlink', done);\n    }\n  }, {\n    key: HARDLINK,\n    value: function value(entry, done) {\n      var linkpath = normPath(path.resolve(this.cwd, entry.linkpath));\n      this[LINK](entry, linkpath, 'link', done);\n    }\n  }, {\n    key: PEND,\n    value: function value() {\n      this[PENDING]++;\n    }\n  }, {\n    key: UNPEND,\n    value: function value() {\n      this[PENDING]--;\n      this[MAYBECLOSE]();\n    }\n  }, {\n    key: SKIP,\n    value: function value(entry) {\n      this[UNPEND]();\n      entry.resume();\n    } // Check if we can reuse an existing filesystem entry safely and\n    // overwrite it, rather than unlinking and recreating\n    // Windows doesn't report a useful nlink, so we just never reuse entries\n  }, {\n    key: ISREUSABLE,\n    value: function value(entry, st) {\n      return entry.type === 'File' && !this.unlink && st.isFile() && st.nlink <= 1 && !isWindows;\n    } // check if a thing is there, and if so, try to clobber it\n  }, {\n    key: CHECKFS,\n    value: function value(entry) {\n      var _this4 = this;\n      this[PEND]();\n      var paths = [entry.path];\n      if (entry.linkpath) {\n        paths.push(entry.linkpath);\n      }\n      this.reservations.reserve(paths, function (done) {\n        return _this4[CHECKFS2](entry, done);\n      });\n    }\n  }, {\n    key: PRUNECACHE,\n    value: function value(entry) {\n      // if we are not creating a directory, and the path is in the dirCache,\n      // then that means we are about to delete the directory we created\n      // previously, and it is no longer going to be a directory, and neither\n      // is any of its children.\n      // If a symbolic link is encountered, all bets are off.  There is no\n      // reasonable way to sanitize the cache in such a way we will be able to\n      // avoid having filesystem collisions.  If this happens with a non-symlink\n      // entry, it'll just fail to unpack, but a symlink to a directory, using an\n      // 8.3 shortname or certain unicode attacks, can evade detection and lead\n      // to arbitrary writes to anywhere on the system.\n      if (entry.type === 'SymbolicLink') {\n        dropCache(this.dirCache);\n      } else if (entry.type !== 'Directory') {\n        pruneCache(this.dirCache, entry.absolute);\n      }\n    }\n  }, {\n    key: CHECKFS2,\n    value: function value(entry, fullyDone) {\n      var _this5 = this;\n      this[PRUNECACHE](entry);\n      var done = function done(er) {\n        _this5[PRUNECACHE](entry);\n        fullyDone(er);\n      };\n      var checkCwd = function checkCwd() {\n        _this5[MKDIR](_this5.cwd, _this5.dmode, function (er) {\n          if (er) {\n            _this5[ONERROR](er, entry);\n            done();\n            return;\n          }\n          _this5[CHECKED_CWD] = true;\n          start();\n        });\n      };\n      var start = function start() {\n        if (entry.absolute !== _this5.cwd) {\n          var parent = normPath(path.dirname(entry.absolute));\n          if (parent !== _this5.cwd) {\n            return _this5[MKDIR](parent, _this5.dmode, function (er) {\n              if (er) {\n                _this5[ONERROR](er, entry);\n                done();\n                return;\n              }\n              afterMakeParent();\n            });\n          }\n        }\n        afterMakeParent();\n      };\n      var afterMakeParent = function afterMakeParent() {\n        fs.lstat(entry.absolute, function (lstatEr, st) {\n          if (st && (_this5.keep || _this5.newer && st.mtime > entry.mtime)) {\n            _this5[SKIP](entry);\n            done();\n            return;\n          }\n          if (lstatEr || _this5[ISREUSABLE](entry, st)) {\n            return _this5[MAKEFS](null, entry, done);\n          }\n          if (st.isDirectory()) {\n            if (entry.type === 'Directory') {\n              var needChmod = !_this5.noChmod && entry.mode && (st.mode & 4095) !== entry.mode;\n              var afterChmod = function afterChmod(er) {\n                return _this5[MAKEFS](er, entry, done);\n              };\n              if (!needChmod) {\n                return afterChmod();\n              }\n              return fs.chmod(entry.absolute, entry.mode, afterChmod);\n            }\n            // Not a dir entry, have to remove it.\n            // NB: the only way to end up with an entry that is the cwd\n            // itself, in such a way that == does not detect, is a\n            // tricky windows absolute path with UNC or 8.3 parts (and\n            // preservePaths:true, or else it will have been stripped).\n            // In that case, the user has opted out of path protections\n            // explicitly, so if they blow away the cwd, c'est la vie.\n            if (entry.absolute !== _this5.cwd) {\n              return fs.rmdir(entry.absolute, function (er) {\n                return _this5[MAKEFS](er, entry, done);\n              });\n            }\n          }\n\n          // not a dir, and not reusable\n          // don't remove if the cwd, we want that error\n          if (entry.absolute === _this5.cwd) {\n            return _this5[MAKEFS](null, entry, done);\n          }\n          unlinkFile(entry.absolute, function (er) {\n            return _this5[MAKEFS](er, entry, done);\n          });\n        });\n      };\n      if (this[CHECKED_CWD]) {\n        start();\n      } else {\n        checkCwd();\n      }\n    }\n  }, {\n    key: MAKEFS,\n    value: function value(er, entry, done) {\n      if (er) {\n        this[ONERROR](er, entry);\n        done();\n        return;\n      }\n      switch (entry.type) {\n        case 'File':\n        case 'OldFile':\n        case 'ContiguousFile':\n          return this[FILE](entry, done);\n        case 'Link':\n          return this[HARDLINK](entry, done);\n        case 'SymbolicLink':\n          return this[SYMLINK](entry, done);\n        case 'Directory':\n        case 'GNUDumpDir':\n          return this[DIRECTORY](entry, done);\n      }\n    }\n  }, {\n    key: LINK,\n    value: function value(entry, linkpath, link, done) {\n      var _this6 = this;\n      // XXX: get the type ('symlink' or 'junction') for windows\n      fs[link](linkpath, entry.absolute, function (er) {\n        if (er) {\n          _this6[ONERROR](er, entry);\n        } else {\n          _this6[UNPEND]();\n          entry.resume();\n        }\n        done();\n      });\n    }\n  }]);\n  return Unpack;\n}(Parser);\nvar callSync = function callSync(fn) {\n  try {\n    return [null, fn()];\n  } catch (er) {\n    return [er, null];\n  }\n};\nvar UnpackSync = /*#__PURE__*/function (_Unpack) {\n  _inherits(UnpackSync, _Unpack);\n  function UnpackSync() {\n    _classCallCheck(this, UnpackSync);\n    return _possibleConstructorReturn(this, _getPrototypeOf(UnpackSync).apply(this, arguments));\n  }\n  _createClass(UnpackSync, [{\n    key: MAKEFS,\n    value: function value(er, entry) {\n      return _get(_getPrototypeOf(UnpackSync.prototype), MAKEFS, this).call(this, er, entry, function () {});\n    }\n  }, {\n    key: CHECKFS,\n    value: function value(entry) {\n      this[PRUNECACHE](entry);\n      if (!this[CHECKED_CWD]) {\n        var _er = this[MKDIR](this.cwd, this.dmode);\n        if (_er) {\n          return this[ONERROR](_er, entry);\n        }\n        this[CHECKED_CWD] = true;\n      }\n\n      // don't bother to make the parent if the current entry is the cwd,\n      // we've already checked it.\n      if (entry.absolute !== this.cwd) {\n        var parent = normPath(path.dirname(entry.absolute));\n        if (parent !== this.cwd) {\n          var mkParent = this[MKDIR](parent, this.dmode);\n          if (mkParent) {\n            return this[ONERROR](mkParent, entry);\n          }\n        }\n      }\n      var _callSync = callSync(function () {\n          return fs.lstatSync(entry.absolute);\n        }),\n        _callSync2 = _slicedToArray(_callSync, 2),\n        lstatEr = _callSync2[0],\n        st = _callSync2[1];\n      if (st && (this.keep || this.newer && st.mtime > entry.mtime)) {\n        return this[SKIP](entry);\n      }\n      if (lstatEr || this[ISREUSABLE](entry, st)) {\n        return this[MAKEFS](null, entry);\n      }\n      if (st.isDirectory()) {\n        if (entry.type === 'Directory') {\n          var needChmod = !this.noChmod && entry.mode && (st.mode & 4095) !== entry.mode;\n          var _ref = needChmod ? callSync(function () {\n              fs.chmodSync(entry.absolute, entry.mode);\n            }) : [],\n            _ref2 = _slicedToArray(_ref, 1),\n            _er2 = _ref2[0];\n          return this[MAKEFS](_er2, entry);\n        }\n        // not a dir entry, have to remove it\n        var _callSync3 = callSync(function () {\n            return fs.rmdirSync(entry.absolute);\n          }),\n          _callSync4 = _slicedToArray(_callSync3, 1),\n          _er3 = _callSync4[0];\n        this[MAKEFS](_er3, entry);\n      }\n\n      // not a dir, and not reusable.\n      // don't remove if it's the cwd, since we want that error.\n      var _ref3 = entry.absolute === this.cwd ? [] : callSync(function () {\n          return unlinkFileSync(entry.absolute);\n        }),\n        _ref4 = _slicedToArray(_ref3, 1),\n        er = _ref4[0];\n      this[MAKEFS](er, entry);\n    }\n  }, {\n    key: FILE,\n    value: function value(entry, done) {\n      var _this7 = this;\n      var mode = entry.mode & 4095 || this.fmode;\n      var oner = function oner(er) {\n        var closeError;\n        try {\n          fs.closeSync(fd);\n        } catch (e) {\n          closeError = e;\n        }\n        if (er || closeError) {\n          _this7[ONERROR](er || closeError, entry);\n        }\n        done();\n      };\n      var fd;\n      try {\n        fd = fs.openSync(entry.absolute, getFlag(entry.size), mode);\n      } catch (er) {\n        return oner(er);\n      }\n      var tx = this.transform ? this.transform(entry) || entry : entry;\n      if (tx !== entry) {\n        tx.on('error', function (er) {\n          return _this7[ONERROR](er, entry);\n        });\n        entry.pipe(tx);\n      }\n      tx.on('data', function (chunk) {\n        try {\n          fs.writeSync(fd, chunk, 0, chunk.length);\n        } catch (er) {\n          oner(er);\n        }\n      });\n      tx.on('end', function (_) {\n        var er = null;\n        // try both, falling futimes back to utimes\n        // if either fails, handle the first error\n        if (entry.mtime && !_this7.noMtime) {\n          var atime = entry.atime || new Date();\n          var mtime = entry.mtime;\n          try {\n            fs.futimesSync(fd, atime, mtime);\n          } catch (futimeser) {\n            try {\n              fs.utimesSync(entry.absolute, atime, mtime);\n            } catch (utimeser) {\n              er = futimeser;\n            }\n          }\n        }\n        if (_this7[DOCHOWN](entry)) {\n          var uid = _this7[UID](entry);\n          var gid = _this7[GID](entry);\n          try {\n            fs.fchownSync(fd, uid, gid);\n          } catch (fchowner) {\n            try {\n              fs.chownSync(entry.absolute, uid, gid);\n            } catch (chowner) {\n              er = er || fchowner;\n            }\n          }\n        }\n        oner(er);\n      });\n    }\n  }, {\n    key: DIRECTORY,\n    value: function value(entry, done) {\n      var mode = entry.mode & 4095 || this.dmode;\n      var er = this[MKDIR](entry.absolute, mode);\n      if (er) {\n        this[ONERROR](er, entry);\n        done();\n        return;\n      }\n      if (entry.mtime && !this.noMtime) {\n        try {\n          fs.utimesSync(entry.absolute, entry.atime || new Date(), entry.mtime);\n        } catch (er) {}\n      }\n      if (this[DOCHOWN](entry)) {\n        try {\n          fs.chownSync(entry.absolute, this[UID](entry), this[GID](entry));\n        } catch (er) {}\n      }\n      done();\n      entry.resume();\n    }\n  }, {\n    key: MKDIR,\n    value: function value(dir, mode) {\n      try {\n        return mkdir.sync(normPath(dir), {\n          uid: this.uid,\n          gid: this.gid,\n          processUid: this.processUid,\n          processGid: this.processGid,\n          umask: this.processUmask,\n          preserve: this.preservePaths,\n          unlink: this.unlink,\n          cache: this.dirCache,\n          cwd: this.cwd,\n          mode: mode\n        });\n      } catch (er) {\n        return er;\n      }\n    }\n  }, {\n    key: LINK,\n    value: function value(entry, linkpath, link, done) {\n      try {\n        fs[link + 'Sync'](linkpath, entry.absolute);\n        done();\n        entry.resume();\n      } catch (er) {\n        return this[ONERROR](er, entry);\n      }\n    }\n  }]);\n  return UnpackSync;\n}(Unpack);\nUnpack.Sync = UnpackSync;\nmodule.exports = Unpack;","map":null,"metadata":{},"sourceType":"script"}