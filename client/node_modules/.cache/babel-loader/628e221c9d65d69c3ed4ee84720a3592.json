{"ast":null,"code":"'use strict';\n\n// tar -r\nvar hlo = require('./high-level-opt.js');\nvar Pack = require('./pack.js');\nvar fs = require('fs');\nvar fsm = require('fs-minipass');\nvar t = require('./list.js');\nvar path = require('path');\n\n// starting at the head of the file, read a Header\n// If the checksum is invalid, that's our position to start writing\n// If it is, jump forward by the specified size (round up to 512)\n// and try again.\n// Write the new Pack stream starting there.\n\nvar Header = require('./header.js');\nmodule.exports = function (opt_, files, cb) {\n  var opt = hlo(opt_);\n  if (!opt.file) {\n    throw new TypeError('file is required');\n  }\n  if (opt.gzip) {\n    throw new TypeError('cannot append to compressed archives');\n  }\n  if (!files || !Array.isArray(files) || !files.length) {\n    throw new TypeError('no files or directories specified');\n  }\n  files = Array.from(files);\n  return opt.sync ? replaceSync(opt, files) : replace(opt, files, cb);\n};\nvar replaceSync = function replaceSync(opt, files) {\n  var p = new Pack.Sync(opt);\n  var threw = true;\n  var fd;\n  var position;\n  try {\n    try {\n      fd = fs.openSync(opt.file, 'r+');\n    } catch (er) {\n      if (er.code === 'ENOENT') {\n        fd = fs.openSync(opt.file, 'w+');\n      } else {\n        throw er;\n      }\n    }\n    var st = fs.fstatSync(fd);\n    var headBuf = Buffer.alloc(512);\n    POSITION: for (position = 0; position < st.size; position += 512) {\n      for (var bufPos = 0, bytes = 0; bufPos < 512; bufPos += bytes) {\n        bytes = fs.readSync(fd, headBuf, bufPos, headBuf.length - bufPos, position + bufPos);\n        if (position === 0 && headBuf[0] === 0x1f && headBuf[1] === 0x8b) {\n          throw new Error('cannot append to compressed archives');\n        }\n        if (!bytes) {\n          break POSITION;\n        }\n      }\n      var h = new Header(headBuf);\n      if (!h.cksumValid) {\n        break;\n      }\n      var entryBlockSize = 512 * Math.ceil(h.size / 512);\n      if (position + entryBlockSize + 512 > st.size) {\n        break;\n      }\n      // the 512 for the header we just parsed will be added as well\n      // also jump ahead all the blocks for the body\n      position += entryBlockSize;\n      if (opt.mtimeCache) {\n        opt.mtimeCache.set(h.path, h.mtime);\n      }\n    }\n    threw = false;\n    streamSync(opt, p, position, fd, files);\n  } finally {\n    if (threw) {\n      try {\n        fs.closeSync(fd);\n      } catch (er) {}\n    }\n  }\n};\nvar streamSync = function streamSync(opt, p, position, fd, files) {\n  var stream = new fsm.WriteStreamSync(opt.file, {\n    fd: fd,\n    start: position\n  });\n  p.pipe(stream);\n  addFilesSync(p, files);\n};\nvar replace = function replace(opt, files, cb) {\n  files = Array.from(files);\n  var p = new Pack(opt);\n  var getPos = function getPos(fd, size, cb_) {\n    var cb = function cb(er, pos) {\n      if (er) {\n        fs.close(fd, function (_) {\n          return cb_(er);\n        });\n      } else {\n        cb_(null, pos);\n      }\n    };\n    var position = 0;\n    if (size === 0) {\n      return cb(null, 0);\n    }\n    var bufPos = 0;\n    var headBuf = Buffer.alloc(512);\n    var onread = function onread(er, bytes) {\n      if (er) {\n        return cb(er);\n      }\n      bufPos += bytes;\n      if (bufPos < 512 && bytes) {\n        return fs.read(fd, headBuf, bufPos, headBuf.length - bufPos, position + bufPos, onread);\n      }\n      if (position === 0 && headBuf[0] === 0x1f && headBuf[1] === 0x8b) {\n        return cb(new Error('cannot append to compressed archives'));\n      }\n\n      // truncated header\n      if (bufPos < 512) {\n        return cb(null, position);\n      }\n      var h = new Header(headBuf);\n      if (!h.cksumValid) {\n        return cb(null, position);\n      }\n      var entryBlockSize = 512 * Math.ceil(h.size / 512);\n      if (position + entryBlockSize + 512 > size) {\n        return cb(null, position);\n      }\n      position += entryBlockSize + 512;\n      if (position >= size) {\n        return cb(null, position);\n      }\n      if (opt.mtimeCache) {\n        opt.mtimeCache.set(h.path, h.mtime);\n      }\n      bufPos = 0;\n      fs.read(fd, headBuf, 0, 512, position, onread);\n    };\n    fs.read(fd, headBuf, 0, 512, position, onread);\n  };\n  var promise = new Promise(function (resolve, reject) {\n    p.on('error', reject);\n    var flag = 'r+';\n    var onopen = function onopen(er, fd) {\n      if (er && er.code === 'ENOENT' && flag === 'r+') {\n        flag = 'w+';\n        return fs.open(opt.file, flag, onopen);\n      }\n      if (er) {\n        return reject(er);\n      }\n      fs.fstat(fd, function (er, st) {\n        if (er) {\n          return fs.close(fd, function () {\n            return reject(er);\n          });\n        }\n        getPos(fd, st.size, function (er, position) {\n          if (er) {\n            return reject(er);\n          }\n          var stream = new fsm.WriteStream(opt.file, {\n            fd: fd,\n            start: position\n          });\n          p.pipe(stream);\n          stream.on('error', reject);\n          stream.on('close', resolve);\n          addFilesAsync(p, files);\n        });\n      });\n    };\n    fs.open(opt.file, flag, onopen);\n  });\n  return cb ? promise.then(cb, cb) : promise;\n};\nvar addFilesSync = function addFilesSync(p, files) {\n  files.forEach(function (file) {\n    if (file.charAt(0) === '@') {\n      t({\n        file: path.resolve(p.cwd, file.slice(1)),\n        sync: true,\n        noResume: true,\n        onentry: function onentry(entry) {\n          return p.add(entry);\n        }\n      });\n    } else {\n      p.add(file);\n    }\n  });\n  p.end();\n};\nvar addFilesAsync = function addFilesAsync(p, files) {\n  while (files.length) {\n    var file = files.shift();\n    if (file.charAt(0) === '@') {\n      return t({\n        file: path.resolve(p.cwd, file.slice(1)),\n        noResume: true,\n        onentry: function onentry(entry) {\n          return p.add(entry);\n        }\n      }).then(function (_) {\n        return addFilesAsync(p, files);\n      });\n    } else {\n      p.add(file);\n    }\n  }\n  p.end();\n};","map":null,"metadata":{},"sourceType":"script"}